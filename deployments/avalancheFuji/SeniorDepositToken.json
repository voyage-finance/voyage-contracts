{
  "address": "0xFf4A0f4a4d56c91791351ED690aab2dc04140396",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "Burn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "underlyingAsset",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "liquidityManagerProxy",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "tokenDecimals",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "tokenName",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "tokenSymbol",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "params",
          "type": "bytes"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "Mint",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "SENIOR_DEPOSIT_TOKEN_REVISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        }
      ],
      "name": "burn",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        }
      ],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "subtractedValue",
          "type": "uint256"
        }
      ],
      "name": "decreaseAllowance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "addedValue",
          "type": "uint256"
        }
      ],
      "name": "increaseAllowance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract AddressResolver",
          "name": "_addressResolver",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_underlyingAsset",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "_seniorDepositTokenDecimals",
          "type": "uint8"
        },
        {
          "internalType": "string",
          "name": "_seniorDepositTokenName",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "_seniorDepositTokenSymbol",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "_params",
          "type": "bytes"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isInitialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lockTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        }
      ],
      "name": "mint",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "pendingWithdrawal",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "scaledBalanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "scaledTotalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalPendingWithdrawal",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_target",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "transferUnderlyingTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "withdrawalAble",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x10cd81d7832d1d8b51faab56c346f16627233aed8962f1cc7ec411f6b8d8eb91",
  "receipt": {
    "to": null,
    "from": "0x4C616d9377Fa8d928385F0b11Ab16D4bf0f2d544",
    "contractAddress": "0xFf4A0f4a4d56c91791351ED690aab2dc04140396",
    "transactionIndex": 1,
    "gasUsed": "2183153",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x21e4ac5fa083397b4b172e5e818fa61e73532f74aca3ff01679d7ed1da194651",
    "transactionHash": "0x10cd81d7832d1d8b51faab56c346f16627233aed8962f1cc7ec411f6b8d8eb91",
    "logs": [],
    "blockNumber": 9624734,
    "cumulativeGasUsed": "2367699",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "871331f2b15163ae262450cdbd5935c8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityManagerProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tokenDecimals\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SENIOR_DEPOSIT_TOKEN_REVISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"_addressResolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_seniorDepositTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_seniorDepositTokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_seniorDepositTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"scaledBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaledTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferUnderlyingTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"withdrawalAble\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"See {IERC20-allowance}.\"},\"approve(address,uint256)\":{\"details\":\"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.\"},\"balanceOf(address)\":{\"details\":\"Calculates the balance of the user: principal balance + interest generated by the principal\",\"params\":{\"_user\":\"The user whose balance is calculated\"},\"returns\":{\"_0\":\"The balance of the user*\"}},\"burn(address,uint256,uint256)\":{\"details\":\"Burns JuniorDepositToken from `_user` and sends the equivalent amount of underlying to `_receiverOfUnderlying` - Only callable by the LiquidityManagerProxy, as extra state updates there need to the managed\",\"params\":{\"_amount\":\"The amount being burned\",\"_index\":\"The new liquidity index of the reserve*\",\"_user\":\"The owner of the JuniorDepositToken, getting them burned\"}},\"decimals()\":{\"details\":\"Returns the decimals places of the token.\"},\"decreaseAllowance(address,uint256)\":{\"details\":\"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.\"},\"increaseAllowance(address,uint256)\":{\"details\":\"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.\"},\"initialize(address,address,uint8,string,string,bytes)\":{\"details\":\"Initializes the JuniorDepositToken\",\"params\":{\"_addressResolver\":\"The address of the AddressResolver\",\"_seniorDepositTokenDecimals\":\"The decimals of the SeniorDepositToken, same as the underlying asset's\",\"_seniorDepositTokenName\":\"The name of the SeniorDepositToken\",\"_seniorDepositTokenSymbol\":\"The symbol of the SeniorDepositToken*\",\"_underlyingAsset\":\"The address of the underlying asset of this SeniorDepositToken\"}},\"isInitialized()\":{\"details\":\"Returns true if the contract has been initialized*\"},\"mint(address,uint256,uint256)\":{\"details\":\"Mints `_amount` junior deposit token to `_user`\",\"params\":{\"_amount\":\"The amount of tokens getting minted\",\"_index\":\"The new liquidity index of the reserve\",\"_user\":\"The address receiving the minted tokens\"},\"returns\":{\"_0\":\"`true` if the previous balance of the user was 0*\"}},\"name()\":{\"details\":\"Returns the name of the token.\"},\"scaledBalanceOf(address)\":{\"details\":\"Returns the scaled balance of the user. The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index at the moment of the update\",\"params\":{\"_user\":\"The user whose balance is calculated\"},\"returns\":{\"_0\":\"THe scaled balance of the user*\"}},\"symbol()\":{\"details\":\"Returns the symbol of the token, usually a shorter version of the name.\"},\"totalSupply()\":{\"details\":\"calculates the total supply of the specific junior deposit token since the balance of every single user increases over time, the totally supply does that too.\",\"returns\":{\"_0\":\"the current total supply*\"}},\"transfer(address,uint256)\":{\"details\":\"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/tokenization/SeniorDepositToken.sol\":\"SeniorDepositToken\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"contracts/component/Voyager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/access/AccessControl.sol';\\nimport '../libraries/acl/ExtCallACL.sol';\\nimport '../libraries/acl/ExtCallACLProxy.sol';\\nimport '../libraries/ownership/Ownable.sol';\\nimport '../libraries/types/DataTypes.sol';\\nimport '../libraries/logic/ReserveLogic.sol';\\nimport '../component/infra/AddressResolver.sol';\\nimport '../component/vault/VaultManager.sol';\\nimport '../component/vault/VaultManagerProxy.sol';\\nimport '../component/liquidity/LiquidityManager.sol';\\nimport '../component/loan/LoanManager.sol';\\nimport '../interfaces/IACLManager.sol';\\nimport './infra/MessageBus.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract Voyager is MessageBus {\\n    modifier onlyWhitelisted(bytes32 func) {\\n        require(\\n            ExtCallACL(getExtCallACLProxyAddress()).isWhitelistedAddress(\\n                msg.sender\\n            ),\\n            'Voyager: not whitelisted address'\\n        );\\n        require(\\n            ExtCallACL(getExtCallACLProxyAddress()).isWhitelistedFunction(func),\\n            'Voyager: not whitelisted functions'\\n        );\\n        _;\\n    }\\n\\n    modifier onlyProtocolManager() {\\n        _requireCallerAdmin();\\n        _;\\n    }\\n\\n    event CallResult(bool, bytes);\\n\\n    /************************************** HouseKeeping Interfaces **************************************/\\n    /**\\n     * @dev Update addressResolver contract address\\n     * @param _addressResolver address of the resolver contract\\n     **/\\n    function setAddressResolverAddress(address _addressResolver)\\n        external\\n        onlyOwner\\n    {\\n        addressResolver = AddressResolver(_addressResolver);\\n    }\\n\\n    function whitelistAddress(address[] calldata _address)\\n        external\\n        onlyProtocolManager\\n    {\\n        ExtCallACL extCallACL = ExtCallACL(getExtCallACLProxyAddress());\\n        extCallACL.whitelistAddress(_address);\\n    }\\n\\n    function whitelistFunction(bytes32[] calldata _function)\\n        external\\n        onlyProtocolManager\\n    {\\n        ExtCallACL extCallACL = ExtCallACL(getExtCallACLProxyAddress());\\n        extCallACL.whitelistFunction(_function);\\n    }\\n\\n    /************************************** Liquidity Manager Interfaces **************************************/\\n\\n    /**\\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying tokens: Either\\n     * Junior Deposit Token or Senior Deposit token\\n     * @param _asset The address of the underlying asset to deposit\\n     * @param _tranche The tranche of the liquidity pool the user wants to deposit to\\n     * @param _amount The amount to be deposited\\n     * @param _onBehalfOf The address that will receive the deposit tokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of deposit token\\n     *   is a different wallet\\n     **/\\n    function deposit(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche,\\n        uint256 _amount,\\n        address _onBehalfOf\\n    ) external {\\n        LiquidityManager(getLiquidityManagerProxyAddress()).deposit(\\n            _asset,\\n            _tranche,\\n            _amount,\\n            msg.sender,\\n            _onBehalfOf\\n        );\\n    }\\n\\n    function withdraw(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche,\\n        uint256 _amount\\n    ) external {\\n        LiquidityManager(getLiquidityManagerProxyAddress()).withdraw(\\n            _asset,\\n            _tranche,\\n            _amount,\\n            payable(msg.sender)\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns the normalized income per unit of asset\\n     * @param _asset The address of the underlying asset of the reserve\\n     * @param _tranche The tranche of the reserve, either Junior or Senior\\n     * @return The reserve's normalized income\\n     **/\\n    function getReserveNormalizedIncome(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256) {\\n        return\\n            LiquidityManager(getLiquidityManagerProxyAddress())\\n                .getReserveNormalizedIncome(_asset, _tranche);\\n    }\\n\\n    /**\\n     * @dev Returns the reserve flags\\n     * @param _asset The address of asset\\n     * @return The state flags representing active, frozen, borrowing enabled\\n     **/\\n    function getReserveFlags(address _asset)\\n        external\\n        view\\n        returns (\\n            bool,\\n            bool,\\n            bool\\n        )\\n    {\\n        return\\n            LiquidityManager(getLiquidityManagerProxyAddress()).getFlags(\\n                _asset\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns the configuration of the reserve\\n     * @param _asset The address of the underlying asset of the reserve\\n     * @return The state of the reserve\\n     **/\\n    function getConfiguration(address _asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveConfigurationMap memory)\\n    {\\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\\n        return\\n            LiquidityManager(getLiquidityManagerProxyAddress())\\n                .getConfiguration(_asset);\\n    }\\n\\n    /**\\n     * @dev Get current liquidity rate for a specific reserve for it junior tranche or senior tranche\\n     * @param _asset The address of the underlying asset of the reserve\\n     * @param _tranche Either junior tranche or senior tranche\\n     **/\\n    function liquidityRate(address _asset, ReserveLogic.Tranche _tranche)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            LiquidityManager(getLiquidityManagerProxyAddress())\\n                .getLiquidityRate(_asset, _tranche);\\n    }\\n\\n    /************************************** Loan Manager Interfaces **************************************/\\n\\n    // todo remove _grossAssetValue\\n    function borrow(\\n        address _asset,\\n        uint256 _amount,\\n        address payable _vault,\\n        uint256 _grossAssetValue\\n    ) external onlyWhitelisted('borrow') {\\n        LoanManager(addressResolver.getLoanManagerProxy()).borrow(\\n            msg.sender,\\n            _asset,\\n            _amount,\\n            _vault,\\n            _grossAssetValue\\n        );\\n    }\\n\\n    /************************************** Vault Manager Interfaces **************************************/\\n\\n    /**\\n     * @dev Create an empty Vault for msg.sender, in addition to this, a vault also deploy\\n     * a SecurityDepositEscrow contract which the fund will be held in\\n     \\u00d7 @return address of Vault\\n     **/\\n    function createVault(\\n        address _to,\\n        address _reserve,\\n        bytes32 _salt\\n    ) external onlyWhitelisted('createVault') returns (address) {\\n        address vaultManagerProxy = getVaultManagerProxyAddress();\\n        VaultManager vaultManager = VaultManager(vaultManagerProxy);\\n        return vaultManager.createVault(_to, _reserve, _salt);\\n    }\\n\\n    function initVault(address _vault, address _reserve) external {\\n        address vaultManagerProxy = getVaultManagerProxyAddress();\\n        VaultManager vaultManager = VaultManager(vaultManagerProxy);\\n        vaultManager.initVault(_vault, _reserve);\\n    }\\n\\n    /**\\n     * @dev Deposit specific amount of security deposit to user owned Vault\\n     * @param _vaultUser the user address that will be sponsored\\n     * @param _reserve address of reserve\\n     * @param _amount deposit amount\\n     **/\\n    function depositSecurity(\\n        address _vaultUser,\\n        address _reserve,\\n        uint256 _amount\\n    ) external onlyWhitelisted('depositSecurity') {\\n        VaultManager(getVaultManagerProxyAddress()).depositSecurity(\\n            msg.sender,\\n            _vaultUser,\\n            _reserve,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Redeem specific amount of security deposit to user owned Vault\\n     * @param _vaultUser the user address that has be sponsored\\n     * @param _reserve address of reserve\\n     * @param _amount deposit amount\\n     **/\\n    function redeemSecurity(\\n        address _vaultUser,\\n        address _reserve,\\n        uint256 _amount\\n    ) external onlyWhitelisted('redeemSecurity') {\\n        VaultManager(getVaultManagerProxyAddress()).redeemSecurity(\\n            payable(msg.sender),\\n            _vaultUser,\\n            _reserve,\\n            _amount\\n        );\\n    }\\n\\n    // todo placeholder functions, more detail should be impl in the future\\n    function slash(\\n        address _vaultUser,\\n        address _reserve,\\n        address payable _to,\\n        uint256 _amount\\n    ) external {\\n        VaultManager(getVaultManagerProxyAddress()).slash(\\n            _vaultUser,\\n            _reserve,\\n            _to,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Get maximum reserve amount the use can borrow\\n     * @param _user user address\\n     * @param _reserve reserve contract address\\n     **/\\n    function getCreditLimit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            VaultManagerProxy(getVaultManagerProxyAddress()).getCreditLimit(\\n                _user,\\n                _reserve\\n            );\\n    }\\n\\n    /**\\n     * @dev Get available credit\\n     * @param _user user address\\n     * @param _reserve address of reserve\\n     **/\\n    function getAvailableCredit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            VaultManagerProxy(getVaultManagerProxyAddress()).getAvailableCredit(\\n                _user,\\n                _reserve\\n            );\\n    }\\n\\n    // deprecated\\n    function eligibleAmount(\\n        address _vaultUser,\\n        address _reserve,\\n        address _sponsor\\n    ) external view returns (uint256) {\\n        return\\n            VaultManager(getVaultManagerProxyAddress()).getWithdrawableDeposit(\\n                _vaultUser,\\n                _reserve,\\n                _sponsor\\n            );\\n    }\\n\\n    /************************************** View Interfaces **************************************/\\n\\n    /**\\n     * @dev Get ExtCallACLProxy contract address\\n     **/\\n    function getExtCallACLProxyAddress() public view returns (address payable) {\\n        address extCallACLProxyAddress = AddressResolver(addressResolver)\\n            .getExtCallProxyName();\\n        return payable(extCallACLProxyAddress);\\n    }\\n\\n    /************************************** Internal Interfaces **************************************/\\n\\n    function _requireCallerAdmin() internal view {\\n        IACLManager aclManager = IACLManager(addressResolver.getAclManager());\\n        require(aclManager.isProtocolManager(tx.origin), 'Not vault admin');\\n    }\\n}\\n\",\"keccak256\":\"0x697bf35ef5c13453e67b740889fd9ef5976895fd9b0de55bc9d19a55a8190bea\",\"license\":\"GPL-3.0\"},\"contracts/component/infra/AddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../interfaces/IAddressResolver.sol';\\nimport '../../libraries/ownership/Ownable.sol';\\n\\ncontract AddressResolver is IAddressResolver, Ownable {\\n    bytes32 public constant voyageName = 'voyager';\\n    bytes32 public constant aclManagerName = 'aclManager';\\n    bytes32 public constant liquidityManagerProxyName = 'liquidityManagerProxy';\\n    bytes32 public constant liquidityManagerName = 'liquidityManager';\\n    bytes32 public constant liquidityManagerStorageName =\\n        'liquidityManagerStorage';\\n    bytes32 public constant liquidityDepositEscrowName =\\n        'liquidityDepositEscrow';\\n    bytes32 public constant loanManagerProxyName = 'loanManagerProxy';\\n    bytes32 public constant loanManagerName = 'loanManager';\\n    bytes32 public constant vaultManagerProxyName = 'vaultManagerProxy';\\n    bytes32 public constant vaultManagerName = 'vaultManager';\\n    bytes32 public constant vaultStorageName = 'vaultStorage';\\n    bytes32 public constant juniorDepositTokenName = 'juniorDepositToken';\\n    bytes32 public constant seniorDepositTokenName = 'seniorDepositToken';\\n    bytes32 public constant securityDepositTokenName = 'securityDepositToken';\\n    bytes32 public constant stableDebtTokenName = 'stableDebtToken';\\n    bytes32 public constant extCallACLProxyName = 'extCallACLProxy';\\n\\n    mapping(bytes32 => address) public repository;\\n\\n    function importAddresses(\\n        bytes32[] calldata names,\\n        address[] calldata destinations\\n    ) external onlyOwner {\\n        require(\\n            names.length == destinations.length,\\n            'Input lengths must match'\\n        );\\n\\n        for (uint256 i = 0; i < names.length; i++) {\\n            bytes32 name = names[i];\\n            address destination = destinations[i];\\n            repository[name] = destination;\\n            emit AddressImported(name, destination);\\n        }\\n    }\\n\\n    function getVoyage() external view returns (address) {\\n        return repository[voyageName];\\n    }\\n\\n    function getLiquidityManagerProxy() external view returns (address) {\\n        return repository[liquidityManagerProxyName];\\n    }\\n\\n    function getLiquidityManagerStorage() external view returns (address) {\\n        return repository[liquidityManagerStorageName];\\n    }\\n\\n    function getLiquidityDepositEscrow() external view returns (address) {\\n        return repository[liquidityDepositEscrowName];\\n    }\\n\\n    function getLoanManagerProxy() external view returns (address) {\\n        return repository[loanManagerProxyName];\\n    }\\n\\n    function getLoanManager() external view returns (address) {\\n        return repository[loanManagerName];\\n    }\\n\\n    function getVaultManagerProxy() external view returns (address) {\\n        return repository[vaultManagerProxyName];\\n    }\\n\\n    function getVaultManager() external view returns (address) {\\n        return repository[vaultManagerName];\\n    }\\n\\n    function getVaultStorage() external view returns (address) {\\n        return repository[vaultStorageName];\\n    }\\n\\n    function getJuniorDepositToken() external view returns (address) {\\n        return repository[juniorDepositTokenName];\\n    }\\n\\n    function getSeniorDepositToken() external view returns (address) {\\n        return repository[seniorDepositTokenName];\\n    }\\n\\n    function getStableDebtToken() external view returns (address) {\\n        return repository[stableDebtTokenName];\\n    }\\n\\n    function getExtCallProxyName() external view returns (address) {\\n        return repository[extCallACLProxyName];\\n    }\\n\\n    function getAclManager() external view returns (address) {\\n        return repository[aclManagerName];\\n    }\\n\\n    function getAddress(bytes32 name) external view returns (address) {\\n        return repository[name];\\n    }\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason)\\n        external\\n        view\\n        returns (address)\\n    {\\n        address _foundAddress = repository[name];\\n        require(_foundAddress != address(0), reason);\\n        return _foundAddress;\\n    }\\n}\\n\",\"keccak256\":\"0x3f823e26ce0648ca639b3e9a87621589379b0ecf829f8c9c90f9bd6df5a203ab\",\"license\":\"GPL-3.0\"},\"contracts/component/infra/MessageBus.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport './AddressResolver.sol';\\nimport '../../interfaces/IMessageBus.sol';\\nimport '../../interfaces/IStableDebtToken.sol';\\nimport '../../interfaces/IVaultManager.sol';\\nimport '../../libraries/ownership/Ownable.sol';\\nimport '../../libraries/types/DataTypes.sol';\\nimport '../../libraries/helpers/Errors.sol';\\nimport '../liquidity/LiquidityManager.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\\nimport '../vault/VaultManager.sol';\\nimport '../vault/VaultManagerProxy.sol';\\n\\n/**\\n * todo it might be a bad name here, it actually performs as the centralise place\\n * for querying each other among the internal components\\n **/\\ncontract MessageBus is IMessageBus, Ownable {\\n    AddressResolver public addressResolver;\\n\\n    /**\\n     * @dev Get addressResolver contract address\\n     * @return address of the resolver contract\\n     **/\\n    function getAddressResolverAddress() external view returns (address) {\\n        return address(addressResolver);\\n    }\\n\\n    /************************************** LiquidityManager Functions **************************************/\\n\\n    /**\\n     * @dev Get LiquidityManagerProxy contract address\\n     **/\\n    function getLiquidityManagerProxyAddress()\\n        public\\n        view\\n        returns (address payable)\\n    {\\n        address liquidityManagerProxyAddress = addressResolver\\n            .getLiquidityManagerProxy();\\n        return payable(liquidityManagerProxyAddress);\\n    }\\n\\n    /**\\n     * @dev Returns the state and configuration of the reserve\\n     * @param _asset The address of the underlying asset of the reserve\\n     * @return The state of the reserve\\n     **/\\n    function getReserveData(address _asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveData memory)\\n    {\\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\\n        return\\n            LiquidityManager(getLiquidityManagerProxyAddress()).getReserveData(\\n                _asset\\n            );\\n    }\\n\\n    /************************************** Vault Functions **************************************/\\n\\n    function getVaultConfig(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.VaultConfig memory)\\n    {\\n        require(Address.isContract(_reserve), Errors.LM_NOT_CONTRACT);\\n        return\\n            VaultManagerProxy(getVaultManagerProxyAddress()).getVaultConfig(\\n                _reserve\\n            );\\n    }\\n\\n    /**\\n     * @dev Get vault address\\n     * @param _user The owner of the vault\\n     **/\\n    function getVault(address _user) external view returns (address) {\\n        return VaultManagerProxy(getVaultManagerProxyAddress()).getVault(_user);\\n    }\\n\\n    function getSecurityDeposit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint256 amt = VaultManagerProxy(getVaultManagerProxyAddress())\\n            .getSecurityDeposit(_user, _reserve);\\n        return amt;\\n    }\\n\\n    /**\\n     * @dev Get VaultManagerProxy contract address\\n     * @return address of the VaultManager\\n     **/\\n    function getVaultManagerProxyAddress()\\n        public\\n        view\\n        returns (address payable)\\n    {\\n        address vaultManagerProxyAddress = addressResolver\\n            .getVaultManagerProxy();\\n        return payable(vaultManagerProxyAddress);\\n    }\\n\\n    /************************************** Stable Debt Token Functions **************************************/\\n\\n    function getCompoundedDebt(address _user) external view returns (uint256) {\\n        return IERC20(addressResolver.getStableDebtToken()).balanceOf(_user);\\n    }\\n\\n    function getAggregateOptimalRepaymentRate(address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            IStableDebtToken(addressResolver.getStableDebtToken())\\n                .getAggregateOptimalRepaymentRate(_user);\\n    }\\n\\n    function getAggregateActualRepaymentRate(address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            IStableDebtToken(addressResolver.getStableDebtToken())\\n                .getAggregateActualRepaymentRate(_user);\\n    }\\n}\\n\",\"keccak256\":\"0xa0dba48ba302bf8bf98bdc75c5e4cb3e896632a9afea067699b14ebec24ae568\",\"license\":\"GPL-3.0\"},\"contracts/component/liquidity/DefaultReserveInterestRateStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../libraries/math/WadRayMath.sol';\\nimport '../../interfaces/IReserveInterestRateStrategy.sol';\\nimport '../../tokenization/IInitializableDepositToken.sol';\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\\n    using WadRayMath for uint256;\\n    using SafeMath for uint256;\\n    /**\\n     * this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates\\n     * Expressed in RAY\\n     **/\\n    uint256 public immutable OPTIMAL_UTILIZATION_RATE;\\n\\n    // Base interest rate set by governance. Expressed in ray\\n    uint256 internal immutable baseBorrowRate;\\n\\n    // Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\\n    uint256 internal immutable stableRateSlope1;\\n\\n    // Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\\n    uint256 internal immutable stableRateSlope2;\\n\\n    constructor(\\n        uint256 _optimalUtilizationRate,\\n        uint256 _stableRateSlope1,\\n        uint256 _stableRateSlope2,\\n        uint256 _baseBorrowRate\\n    ) public {\\n        OPTIMAL_UTILIZATION_RATE = _optimalUtilizationRate;\\n        baseBorrowRate = _baseBorrowRate;\\n        stableRateSlope1 = _stableRateSlope1;\\n        stableRateSlope2 = _stableRateSlope2;\\n    }\\n\\n    struct CalcInterestRatesLocalVars {\\n        uint256 totalDebt;\\n        uint256 currentStableBorrowRate;\\n        uint256 currentLiquidityRate;\\n        uint256 utilizationRate;\\n    }\\n\\n    /**\\n     * @dev Calculates the interest rates depending on the reserve's state and configuration\\n     * @param reserve The address of the reserve\\n     * @param seniorDepositTokenAddress The address of senior deposit token\\n     * @param liquidityAdded The liquidity added during the operation\\n     * @param liquidityTaken The liquidity taken during the operation\\n     * @param totalStableDebt The total borrowed from the reserve a stable rate\\n     * @param averageBorrowRate The current average borrow rate\\n     **/\\n    function calculateInterestRates(\\n        address reserve,\\n        address seniorDepositTokenAddress,\\n        uint256 liquidityAdded,\\n        uint256 liquidityTaken,\\n        uint256 totalStableDebt,\\n        uint256 averageBorrowRate\\n    ) external view returns (uint256, uint256) {\\n        uint256 totalPendingWithdrawal = IInitializableDepositToken(\\n            seniorDepositTokenAddress\\n        ).totalPendingWithdrawal();\\n\\n        uint256 availableLiquidity = IERC20(reserve).balanceOf(\\n            seniorDepositTokenAddress\\n        ) - totalPendingWithdrawal;\\n\\n        availableLiquidity = availableLiquidity.add(liquidityAdded).sub(\\n            liquidityTaken\\n        );\\n        return\\n            calculateInterestRates(\\n                reserve,\\n                availableLiquidity,\\n                totalStableDebt,\\n                averageBorrowRate\\n            );\\n    }\\n\\n    /**\\n     * @dev Calculates the interest rates depending on the reserve's state and configurations.\\n     * @param reserve The address of the reserve\\n     * @param availableLiquidity The liquidity available in the corresponding aToken\\n     * @param totalStableDebt The total borrowed from the reserve a stable rate\\n     * @return The liquidity rate, the stable borrow rate\\n     * @param averageBorrowRate The current average borrow rate\\n     **/\\n    function calculateInterestRates(\\n        address reserve,\\n        uint256 availableLiquidity,\\n        uint256 totalStableDebt,\\n        uint256 averageBorrowRate\\n    ) public view returns (uint256, uint256) {\\n        CalcInterestRatesLocalVars memory vars;\\n\\n        vars.totalDebt = totalStableDebt;\\n        vars.currentStableBorrowRate = baseBorrowRate;\\n        vars.currentLiquidityRate = 0;\\n\\n        vars.utilizationRate = vars.totalDebt == 0\\n            ? 0\\n            : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\\n\\n        if (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) {\\n            vars.currentStableBorrowRate = vars\\n                .currentStableBorrowRate\\n                .add(stableRateSlope1)\\n                .add(\\n                    stableRateSlope2\\n                        .rayMul(\\n                            vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE)\\n                        )\\n                        .rayDiv(WadRayMath.Ray().sub(OPTIMAL_UTILIZATION_RATE))\\n                );\\n        } else {\\n            vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(\\n                stableRateSlope1.rayMul(vars.utilizationRate).rayDiv(\\n                    OPTIMAL_UTILIZATION_RATE\\n                )\\n            );\\n        }\\n\\n        vars.currentLiquidityRate = averageBorrowRate.rayMul(\\n            vars.utilizationRate\\n        );\\n        return (vars.currentLiquidityRate, vars.currentStableBorrowRate);\\n    }\\n}\\n\",\"keccak256\":\"0x543f855c606610495ba9611de1f01a881b08b7d710d0dced7cf8754a922e9f92\",\"license\":\"GPL-3.0\"},\"contracts/component/liquidity/LiquidityManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport './ReserveManager.sol';\\nimport '../../libraries/helpers/Errors.sol';\\nimport '../../libraries/logic/ReserveLogic.sol';\\nimport '../../libraries/math/WadRayMath.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '../../interfaces/IReserveManager.sol';\\nimport '../../interfaces/ILiquidityManager.sol';\\nimport '../../tokenization/JuniorDepositToken.sol';\\nimport '../../tokenization/SeniorDepositToken.sol';\\n\\ncontract LiquidityManager is ReserveManager, ILiquidityManager {\\n    using WadRayMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    constructor(address payable _proxy, address _voyager)\\n        ReserveManager(_proxy, _voyager)\\n    {}\\n\\n    /************************************** User Functions **************************************/\\n\\n    function deposit(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche,\\n        uint256 _amount,\\n        address _user,\\n        address _onBehalfOf\\n    ) external onlyProxy {\\n        LiquidityManagerStorage lms = LiquidityManagerStorage(\\n            liquidityManagerStorageAddress()\\n        );\\n        DataTypes.ReserveData memory reserve = getReserveData(_asset);\\n\\n        lms.updateStateOnDeposit(_asset, _tranche, _amount);\\n\\n        address vToken;\\n        uint256 liquidityIndex;\\n\\n        if (ReserveLogic.Tranche.JUNIOR == _tranche) {\\n            vToken = reserve.juniorDepositTokenAddress;\\n            liquidityIndex = getJuniorLiquidityIndex(_asset);\\n        } else {\\n            vToken = reserve.seniorDepositTokenAddress;\\n            liquidityIndex = getSeniorLiquidityIndex(_asset);\\n        }\\n        IVToken(vToken).mint(_onBehalfOf, _amount, liquidityIndex);\\n        IERC20(_asset).safeTransferFrom(_user, vToken, _amount);\\n        emitDeposit(_asset, _user, _tranche, _amount);\\n    }\\n\\n    function withdraw(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche,\\n        uint256 _amount,\\n        address payable _user\\n    ) external onlyProxy {\\n        LiquidityManagerStorage lms = LiquidityManagerStorage(\\n            liquidityManagerStorageAddress()\\n        );\\n        DataTypes.ReserveData memory reserve = getReserveData(_asset);\\n\\n        address vToken;\\n        uint256 liquidityIndex;\\n        if (ReserveLogic.Tranche.JUNIOR == _tranche) {\\n            vToken = reserve.juniorDepositTokenAddress;\\n            liquidityIndex = getJuniorLiquidityIndex(_asset);\\n        } else {\\n            vToken = reserve.seniorDepositTokenAddress;\\n            liquidityIndex = getSeniorLiquidityIndex(_asset);\\n        }\\n\\n        uint256 userBalance = IERC20(vToken).balanceOf(_user);\\n\\n        uint256 amountToWithdraw = _amount;\\n\\n        if (_amount == type(uint256).max) {\\n            amountToWithdraw = userBalance;\\n        }\\n\\n        IVToken(vToken).burn(_user, amountToWithdraw, liquidityIndex);\\n        lms.updateStateOnWithdraw(_asset, _tranche);\\n\\n        emitWithdraw(_asset, _user, _tranche, _amount);\\n    }\\n\\n    /************************************** View Functions **************************************/\\n\\n    // todo @ian @xiaohuo this case, total balance should be the same as withdrawable amount\\n    function withdrawAbleAmount(\\n        address _reserve,\\n        address _user,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256) {\\n        DataTypes.ReserveData memory reserve = getReserveData(_reserve);\\n        address vToken;\\n        if (ReserveLogic.Tranche.JUNIOR == _tranche) {\\n            vToken = reserve.juniorDepositTokenAddress;\\n        } else {\\n            vToken = reserve.seniorDepositTokenAddress;\\n        }\\n        return IERC20(vToken).balanceOf(_user);\\n    }\\n\\n    function totalDepositAndDebt() external {\\n        AddressResolver addressResolver = voyager.addressResolver();\\n        addressResolver.getStableDebtToken();\\n    }\\n\\n    function balance(\\n        address _reserve,\\n        address _user,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256) {\\n        DataTypes.ReserveData memory reserve = getReserveData(_reserve);\\n        address vToken;\\n        if (ReserveLogic.Tranche.JUNIOR == _tranche) {\\n            vToken = reserve.juniorDepositTokenAddress;\\n        } else {\\n            vToken = reserve.seniorDepositTokenAddress;\\n        }\\n        return IERC20(vToken).balanceOf(_user);\\n    }\\n\\n    function getReserveNormalizedIncome(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256) {\\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\\n        return\\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\\n                .getReserveNormalizedIncome(_asset, _tranche);\\n    }\\n\\n    /******************************************** Events *******************************************/\\n\\n    function trancheToBytes32(ReserveLogic.Tranche tranche)\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return ReserveLogic.trancheToBytes32(tranche);\\n    }\\n\\n    event Deposit(\\n        address indexed asset,\\n        address indexed user,\\n        uint8 indexed tranche,\\n        uint256 amount\\n    );\\n    bytes32 internal constant DEPOSIT_SIG =\\n        keccak256('Deposit(address,address,uint8,uint256)');\\n\\n    bytes32 internal constant WITHDRAW_SIG =\\n        keccak256('Withdraw(address,address,uint8,uint256)');\\n\\n    function emitDeposit(\\n        address asset,\\n        address user,\\n        ReserveLogic.Tranche tranche,\\n        uint256 amount\\n    ) internal {\\n        proxy._emit(\\n            abi.encode(amount),\\n            4,\\n            DEPOSIT_SIG,\\n            addressToBytes32(asset),\\n            addressToBytes32(user),\\n            trancheToBytes32(tranche)\\n        );\\n    }\\n\\n    function emitWithdraw(\\n        address asset,\\n        address user,\\n        ReserveLogic.Tranche tranche,\\n        uint256 amount\\n    ) internal {\\n        proxy._emit(\\n            abi.encode(amount),\\n            4,\\n            WITHDRAW_SIG,\\n            addressToBytes32(asset),\\n            addressToBytes32(user),\\n            trancheToBytes32(tranche)\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xf45274e22b58000919350e640e7ee909d68feb7db4d282e5b8d3aaf60c5cbef6\",\"license\":\"GPL-3.0\"},\"contracts/component/liquidity/LiquidityManagerProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../libraries/proxy/Proxy.sol';\\nimport '../../interfaces/IReserveManager.sol';\\nimport '../../interfaces/ILiquidityManager.sol';\\nimport '../../interfaces/ILiquidityManagerProxy.sol';\\nimport '../../interfaces/IVoyagerComponent.sol';\\nimport '../../libraries/logic/ReserveLogic.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract LiquidityManagerProxy is Proxy, ILiquidityManagerProxy {\\n    function getLiquidityRate(address _reserve, ReserveLogic.Tranche _tranche)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            IReserveManager(address(target)).getLiquidityRate(\\n                _reserve,\\n                _tranche\\n            );\\n    }\\n\\n    function getReserveData(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.ReserveData memory)\\n    {\\n        return IReserveManager(address(target)).getReserveData(_reserve);\\n    }\\n\\n    function getLiquidityAndDebt(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.DepositAndDebt memory)\\n    {\\n        return IVoyagerComponent(address(target)).getDepositAndDebt(_reserve);\\n    }\\n\\n    function getReserveList() external view returns (address[] memory) {\\n        return IReserveManager(address(target)).getReserveList();\\n    }\\n\\n    function getConfiguration(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.ReserveConfigurationMap memory)\\n    {\\n        return IReserveManager(address(target)).getConfiguration(_reserve);\\n    }\\n\\n    function getFlags(address _asset)\\n        external\\n        view\\n        returns (\\n            bool,\\n            bool,\\n            bool\\n        )\\n    {\\n        return IReserveManager(address(target)).getFlags(_asset);\\n    }\\n\\n    function getReserveNormalizedIncome(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256) {\\n        return\\n            ILiquidityManager(address(target)).getReserveNormalizedIncome(\\n                _asset,\\n                _tranche\\n            );\\n    }\\n\\n    function withdrawAbleAmount(\\n        address _reserve,\\n        address _user,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256) {\\n        return\\n            ILiquidityManager(address(target)).withdrawAbleAmount(\\n                _reserve,\\n                _user,\\n                _tranche\\n            );\\n    }\\n\\n    function balance(\\n        address _reserve,\\n        address _user,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256) {\\n        return\\n            ILiquidityManager(address(target)).balance(\\n                _reserve,\\n                _user,\\n                _tranche\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xd888ed22aa4b5ac6d0043342013c04983d267a4c8659a6d8e37a014492c789c9\",\"license\":\"GPL-3.0\"},\"contracts/component/liquidity/ReserveManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../Voyager.sol';\\nimport '../../libraries/helpers/Errors.sol';\\nimport 'openzeppelin-solidity/contracts/utils/Address.sol';\\nimport '../shared/storage/LiquidityManagerStorage.sol';\\nimport '../infra/AddressResolver.sol';\\nimport '../../libraries/proxy/Proxyable.sol';\\nimport '../../libraries/logic/ReserveLogic.sol';\\nimport '../../interfaces/IReserveManager.sol';\\nimport '../../interfaces/IVoyagerComponent.sol';\\nimport '../../interfaces/IStableDebtToken.sol';\\nimport '../../interfaces/IACLManager.sol';\\n\\nabstract contract ReserveManager is\\n    Proxyable,\\n    IReserveManager,\\n    IVoyagerComponent\\n{\\n    constructor(address payable _proxy, address _voyager) Proxyable(_proxy) {\\n        voyager = Voyager(_voyager);\\n    }\\n\\n    modifier onlyAdmin() {\\n        _requireCallerAdmin();\\n        _;\\n    }\\n\\n    /************************************** HouseKeeping Functions **************************************/\\n\\n    /**\\n     * @dev Pause the protocol\\n     **/\\n    function pause() external onlyProxy onlyAdmin {\\n        LiquidityManagerStorage(liquidityManagerStorageAddress()).pause();\\n    }\\n\\n    /**\\n     * @dev UnPause the protocol\\n     **/\\n    function unPause() external onlyProxy onlyAdmin {\\n        LiquidityManagerStorage(liquidityManagerStorageAddress()).unPause();\\n    }\\n\\n    /**\\n     * @dev Initializes a reserve, activating it, assigning two deposit tokens and an interest rate strategy\\n     * Only callable by protocol operator\\n     * @param _asset The address of the underlying asset of the reserve\\n     * @param _juniorDepositTokenAddress The address of the junior deposit token that will be assigned to the reserve\\n     * @param _seniorDepositTokenAddress The address of the senior deposit token that will be assigned to the reserve\\n     * @param _stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\\n     * @param _interestRateStrategyAddress The address of the interest rate strategy contract\\n     * @param _optimalIncomeRatio The ratio of income ratio\\n     **/\\n    function initReserve(\\n        address _asset,\\n        address _juniorDepositTokenAddress,\\n        address _seniorDepositTokenAddress,\\n        address _stableDebtAddress,\\n        address _interestRateStrategyAddress,\\n        address _healthStrategyAddress,\\n        uint256 _optimalIncomeRatio\\n    ) external onlyProxy onlyAdmin {\\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\\n        LiquidityManagerStorage(liquidityManagerStorageAddress()).initReserve(\\n            _asset,\\n            _juniorDepositTokenAddress,\\n            _seniorDepositTokenAddress,\\n            _stableDebtAddress,\\n            _interestRateStrategyAddress,\\n            _healthStrategyAddress,\\n            _optimalIncomeRatio\\n        );\\n        emitReserveInitialized(\\n            _asset,\\n            _juniorDepositTokenAddress,\\n            _seniorDepositTokenAddress,\\n            _stableDebtAddress,\\n            _interestRateStrategyAddress,\\n            _healthStrategyAddress\\n        );\\n    }\\n\\n    /**\\n     * @dev Active a reserve for borrowing\\n     * @param _asset The address of the reserve\\n     **/\\n    function activeReserve(address _asset) external onlyProxy onlyAdmin {\\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\\n        LiquidityManagerStorage(liquidityManagerStorageAddress()).activeReserve(\\n                _asset\\n            );\\n        emitReserveActivated(_asset);\\n    }\\n\\n    /************************************** View Functions **************************************/\\n\\n    function getReserveData(address _asset)\\n        public\\n        view\\n        returns (DataTypes.ReserveData memory)\\n    {\\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\\n        return\\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\\n                .getReserveData(_asset);\\n    }\\n\\n    function getReserveList() external view returns (address[] memory) {\\n        return\\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\\n                .getReserveList();\\n    }\\n\\n    function getConfiguration(address _asset)\\n        public\\n        view\\n        returns (DataTypes.ReserveConfigurationMap memory)\\n    {\\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\\n        return\\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\\n                .getConfiguration(_asset);\\n    }\\n\\n    function getFlags(address _asset)\\n        public\\n        view\\n        returns (\\n            bool,\\n            bool,\\n            bool\\n        )\\n    {\\n        return\\n            LiquidityManagerStorage(liquidityManagerStorageAddress()).getFlags(\\n                _asset\\n            );\\n    }\\n\\n    function getLiquidityRate(address _asset, ReserveLogic.Tranche _tranche)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\\n        return\\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\\n                .getLiquidityRate(_asset, _tranche);\\n    }\\n\\n    function getJuniorLiquidityIndex(address _asset)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\\n                .getJuniorLiquidityIndex(_asset);\\n    }\\n\\n    function getSeniorLiquidityIndex(address _asset)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\\n                .getSeniorLiquidityIndex(_asset);\\n    }\\n\\n    /************************************** Private Functions **************************************/\\n\\n    function _requireCallerAdmin() internal {\\n        Voyager v = Voyager(voyager);\\n        AddressResolver addressResolver = v.addressResolver();\\n        address aclAddress = addressResolver.getAclManager();\\n        IACLManager aclManager = IACLManager(aclAddress);\\n        require(\\n            aclManager.isLiquidityManager(messageSender),\\n            'Not vault admin'\\n        );\\n    }\\n\\n    /******************************************** Events *******************************************/\\n\\n    function addressToBytes32(address input) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(input)));\\n    }\\n\\n    event ReserveInitialized(\\n        address indexed _asset,\\n        address _juniorDepositTokenAddress,\\n        address _seniorDepositTokenAddress,\\n        uint256 _juniorIncomeAllocation,\\n        uint256 _seniorIncomeAllocation,\\n        address _stableDebtAddress,\\n        address _interestRateStrategyAddress,\\n        address _healthStrategyAddress\\n    );\\n    bytes32 internal constant RESERVE_INITIALIZED_SIG =\\n        keccak256(\\n            'ReserveInitialized(address,address,address,uint256,uint256,address,address,address)'\\n        );\\n\\n    function emitReserveInitialized(\\n        address _asset,\\n        address _juniorDepositTokenAddress,\\n        address _seniorDepositTokenAddress,\\n        address _stableDebtAddress,\\n        address _interestRateStrategyAddress,\\n        address _healthStrategyAddress\\n    ) internal {\\n        proxy._emit(\\n            abi.encode(\\n                _juniorDepositTokenAddress,\\n                _seniorDepositTokenAddress,\\n                _stableDebtAddress,\\n                _interestRateStrategyAddress,\\n                _healthStrategyAddress\\n            ),\\n            2,\\n            RESERVE_INITIALIZED_SIG,\\n            addressToBytes32(_asset),\\n            0,\\n            0\\n        );\\n    }\\n\\n    event ReserveActivated(address indexed _asset);\\n    bytes32 internal constant RESERVE_ACTIVATED_SIG =\\n        keccak256('ReserveActivated(address)');\\n\\n    function emitReserveActivated(address _asset) internal {\\n        bytes memory data;\\n        proxy._emit(\\n            data,\\n            2,\\n            RESERVE_ACTIVATED_SIG,\\n            addressToBytes32(_asset),\\n            0,\\n            0\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x3fd97aaa5804fb4e1a0c33f97c4bbc16fd91b782be89e6732dbed3381f075154\",\"license\":\"GPL-3.0\"},\"contracts/component/loan/LoanManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\nimport '../../libraries/proxy/Proxyable.sol';\\nimport '../../interfaces/IVoyagerComponent.sol';\\nimport '../../libraries/helpers/Errors.sol';\\nimport '../../libraries/math/WadRayMath.sol';\\nimport '../../libraries/types/DataTypes.sol';\\nimport '../../interfaces/IMessageBus.sol';\\nimport '../../interfaces/IHealthStrategy.sol';\\nimport '../../interfaces/IInitializableDebtToken.sol';\\nimport '../../interfaces/IVault.sol';\\nimport '../../interfaces/IVToken.sol';\\nimport '../Voyager.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract LoanManager is Proxyable, IVoyagerComponent {\\n    using SafeMath for uint256;\\n    using WadRayMath for uint256;\\n\\n    constructor(address payable _proxy, address _voyager) Proxyable(_proxy) {\\n        voyager = Voyager(_voyager);\\n    }\\n\\n    struct ExecuteBorrowParams {\\n        address asset;\\n        address user;\\n        uint256 amount;\\n    }\\n\\n    function borrow(\\n        address _user,\\n        address _asset,\\n        uint256 _amount,\\n        address payable _vault,\\n        uint256 _grossAssetValue\\n    ) external requireNotPaused onlyProxy {\\n        // todo use min security deposit\\n        require(_amount >= 1e19, Errors.LOM_INVALID_AMOUNT);\\n\\n        // 0. check if the user owns the vault\\n        require(voyager.getVault(_user) == _vault, Errors.LOM_NOT_VAULT_OWNER);\\n\\n        // 1. check if pool liquidity is sufficient\\n        DataTypes.ReserveData memory reserveData = voyager.getReserveData(\\n            _asset\\n        );\\n\\n        uint256 availableSeniorLiquidity = IERC20(\\n            reserveData.seniorDepositTokenAddress\\n        ).totalSupply();\\n        uint256 totalDebt = IERC20(reserveData.debtTokenAddress).totalSupply();\\n        require(\\n            availableSeniorLiquidity - totalDebt >= _amount,\\n            Errors.LOM_RESERVE_NOT_SUFFICIENT\\n        );\\n\\n        uint256 availableJuniorLiquidity = IERC20(_asset).balanceOf(\\n            reserveData.juniorDepositTokenAddress\\n        );\\n        require(\\n            availableJuniorLiquidity >= 0,\\n            'invalid available junior liquidity'\\n        );\\n\\n        // 2. check HF\\n        IHealthStrategy healthStrategy = IHealthStrategy(\\n            reserveData.healthStrategyAddress\\n        );\\n        DataTypes.HealthRiskParameter memory hrp;\\n        hrp.securityDeposit = voyager.getSecurityDeposit(_user, _asset);\\n        hrp.currentBorrowRate = reserveData.currentBorrowRate;\\n        hrp.compoundedDebt = voyager.getCompoundedDebt(_user);\\n        hrp.grossAssetValue = _grossAssetValue;\\n        hrp.aggregateOptimalRepaymentRate = voyager\\n            .getAggregateOptimalRepaymentRate(_user);\\n        hrp.aggregateActualRepaymentRate = voyager\\n            .getAggregateActualRepaymentRate(_user);\\n\\n        uint256 hr = healthStrategy.calculateHealthRisk(hrp);\\n\\n        require(hr >= WadRayMath.ray(), Errors.LOM_HEALTH_RISK_BELOW_ONE);\\n\\n        // 3. check credit limit\\n        uint256 availableCreditLimit = voyager.getAvailableCredit(\\n            _user,\\n            _asset\\n        );\\n\\n        require(\\n            availableCreditLimit >= _amount,\\n            Errors.LOM_CREDIT_NOT_SUFFICIENT\\n        );\\n\\n        // 4. increase vault debt\\n        IVault(_vault).increaseTotalDebt(_amount);\\n\\n        // 5. mint debt token and transfer underlying token\\n        address debtToken = voyager.addressResolver().getStableDebtToken();\\n        IInitializableDebtToken(debtToken).mint(\\n            _vault,\\n            _amount,\\n            healthStrategy.getLoanTenure(),\\n            reserveData.currentBorrowRate\\n        );\\n\\n        // 6. update liquidity index and interest rate\\n        LiquidityManagerStorage lms = LiquidityManagerStorage(\\n            liquidityManagerStorageAddress()\\n        );\\n\\n        lms.updateStateOnBorrow(_asset, _amount);\\n\\n        IVToken(reserveData.seniorDepositTokenAddress).transferUnderlyingTo(\\n            _vault,\\n            _amount\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xb727c8902623f0a77af373306ce302c79ce9f7496bb00cd1e0da7c3b9d481c84\",\"license\":\"GPL-3.0\"},\"contracts/component/shared/storage/LiquidityManagerStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../../libraries/state/State.sol';\\nimport '../../../libraries/types/DataTypes.sol';\\nimport '../../../libraries/logic/ReserveLogic.sol';\\nimport '../../../libraries/logic/ValidationLogic.sol';\\nimport '../../../libraries/configuration/ReserveConfiguration.sol';\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\\n\\ncontract LiquidityManagerStorage is State {\\n    using ReserveLogic for DataTypes.ReserveData;\\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n    using SafeMath for uint256;\\n\\n    mapping(address => DataTypes.ReserveData) internal _reserves;\\n\\n    // List of reserves as a map (reserveId => reserve)\\n    mapping(uint256 => address) internal _reserveList;\\n\\n    // Maximum number of active reserves there have been in the protocol. It is the upper bound of the reserves list\\n    uint16 internal _reservesCount;\\n\\n    bool internal _paused;\\n\\n    constructor(address _liquidityManager) State(_liquidityManager) {}\\n\\n    function initReserve(\\n        address _asset,\\n        address _juniorDepositTokenAddress,\\n        address _seniorDepositTokenAddress,\\n        address _stableDebtAddress,\\n        address _interestRateStrategyAddress,\\n        address _healthStrategyAddress,\\n        uint256 _optimalIncomeRatio\\n    ) external onlyAssociatedContract {\\n        _reserves[_asset].init(\\n            _juniorDepositTokenAddress,\\n            _seniorDepositTokenAddress,\\n            _stableDebtAddress,\\n            _interestRateStrategyAddress,\\n            _healthStrategyAddress,\\n            _optimalIncomeRatio\\n        );\\n\\n        _reserveList[_reservesCount] = _asset;\\n        _reservesCount++;\\n    }\\n\\n    function updateStateOnDeposit(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche,\\n        uint256 _amount\\n    ) public onlyAssociatedContract {\\n        DataTypes.ReserveData storage reserve = _reserves[_asset];\\n        ValidationLogic.validateDeposit(reserve, _amount);\\n        reserve.updateState(_tranche);\\n        if (ReserveLogic.Tranche.JUNIOR == _tranche) {\\n            reserve.updateInterestRates(\\n                _asset,\\n                reserve.juniorDepositTokenAddress,\\n                reserve.seniorDepositTokenAddress,\\n                0,\\n                0\\n            );\\n        } else {\\n            reserve.updateInterestRates(\\n                _asset,\\n                reserve.juniorDepositTokenAddress,\\n                reserve.seniorDepositTokenAddress,\\n                _amount,\\n                0\\n            );\\n        }\\n    }\\n\\n    function updateStateOnWithdraw(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche\\n    ) public onlyAssociatedContract {\\n        DataTypes.ReserveData storage reserve = _reserves[_asset];\\n        reserve.updateState(_tranche);\\n        reserve.updateInterestRates(\\n            _asset,\\n            reserve.juniorDepositTokenAddress,\\n            reserve.seniorDepositTokenAddress,\\n            0,\\n            0\\n        );\\n    }\\n\\n    function updateStateOnBorrow(address _asset, uint256 _amount)\\n        public\\n        onlyAssociatedContract\\n    {\\n        DataTypes.ReserveData storage reserve = _reserves[_asset];\\n        reserve.updateState(ReserveLogic.Tranche.SENIOR);\\n        reserve.updateInterestRates(\\n            _asset,\\n            reserve.juniorDepositTokenAddress,\\n            reserve.seniorDepositTokenAddress,\\n            0,\\n            _amount\\n        );\\n    }\\n\\n    function activeReserve(address _asset) public onlyAssociatedContract {\\n        DataTypes.ReserveConfigurationMap\\n            memory currentConfig = getConfiguration(_asset);\\n        currentConfig.setActive(true);\\n        setConfiguration(_asset, currentConfig.data);\\n    }\\n\\n    function pause() public onlyAssociatedContract {\\n        _paused = true;\\n    }\\n\\n    function unPause() public onlyAssociatedContract {\\n        _paused = false;\\n    }\\n\\n    /*********************************************** View functions ***********************************************/\\n\\n    function getFlags(address _asset)\\n        public\\n        view\\n        returns (\\n            bool,\\n            bool,\\n            bool\\n        )\\n    {\\n        DataTypes.ReserveConfigurationMap\\n            memory currentConfig = getConfiguration(_asset);\\n        return currentConfig.getFlags();\\n    }\\n\\n    function getReserveData(address _asset)\\n        public\\n        view\\n        returns (DataTypes.ReserveData memory)\\n    {\\n        return _reserves[_asset];\\n    }\\n\\n    function getReserveList() public view returns (address[] memory) {\\n        address[] memory reserveList = new address[](_reservesCount);\\n        for (uint256 i = 0; i < _reservesCount; i++) {\\n            reserveList[i] = _reserveList[i];\\n        }\\n        return reserveList;\\n    }\\n\\n    function getConfiguration(address _asset)\\n        public\\n        view\\n        returns (DataTypes.ReserveConfigurationMap memory)\\n    {\\n        return _reserves[_asset].configuration;\\n    }\\n\\n    function setConfiguration(address _asset, uint256 configuration) internal {\\n        _reserves[_asset].configuration.data = configuration;\\n    }\\n\\n    function getLiquidityRate(address _asset, ReserveLogic.Tranche _tranche)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _reserves[_asset].getLiquidityRate(_tranche);\\n    }\\n\\n    function getJuniorLiquidityIndex(address _asset)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _reserves[_asset].juniorLiquidityIndex;\\n    }\\n\\n    function getSeniorLiquidityIndex(address _asset)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _reserves[_asset].seniorLiquidityIndex;\\n    }\\n\\n    function getReserveNormalizedIncome(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche\\n    ) public view returns (uint256) {\\n        return _reserves[_asset].getNormalizedIncome(_tranche);\\n    }\\n\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    function getDepositAndDebt(address _reserve)\\n        public\\n        view\\n        returns (DataTypes.DepositAndDebt memory)\\n    {\\n        DataTypes.ReserveData storage reserve = _reserves[_reserve];\\n        DataTypes.DepositAndDebt memory res;\\n        res.juniorDepositAmount = IERC20(reserve.juniorDepositTokenAddress)\\n            .totalSupply();\\n        res.seniorDepositAmount = IERC20(reserve.seniorDepositTokenAddress)\\n            .totalSupply();\\n        (res.totalDebt, res.avgStableRate) = IStableDebtToken(\\n            reserve.debtTokenAddress\\n        ).getTotalSupplyAndAvgRate();\\n        return res;\\n    }\\n}\\n\",\"keccak256\":\"0x714da0295270f514e346821ddc498a82ac7b772545eba0d46f2d1d576f1a1ce1\",\"license\":\"GPL-3.0\"},\"contracts/component/staking/RewardsDistributionRecipient.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../libraries/ownership/Ownable.sol';\\n\\nabstract contract RewardsDistributionRecipient is Ownable {\\n    address public rewardsDistribution;\\n\\n    function notifyRewardAmount(uint256 reward) external virtual;\\n\\n    modifier onlyRewardsDistribution() {\\n        require(\\n            msg.sender == rewardsDistribution,\\n            'Caller is not RewardsDistribution contract'\\n        );\\n        _;\\n    }\\n\\n    function setRewardsDistribution(address _rewardsDistribution)\\n        external\\n        onlyOwner\\n    {\\n        rewardsDistribution = _rewardsDistribution;\\n    }\\n}\\n\",\"keccak256\":\"0x0ada077c7d1b5ed5f6786d032e0a6ebeccae5460cd08dcadc06f62ec4db0bfda\",\"license\":\"GPL-3.0\"},\"contracts/component/staking/StakingRewards.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '../../libraries/helpers/Pausable.sol';\\nimport 'openzeppelin-solidity/contracts/security/ReentrancyGuard.sol';\\nimport './RewardsDistributionRecipient.sol';\\n\\ncontract StakingRewards is\\n    ReentrancyGuard,\\n    RewardsDistributionRecipient,\\n    Pausable\\n{\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 public stakingToken;\\n    IERC20 public rewardsToken;\\n    uint256 public periodFinish = 0;\\n    uint256 public rewardRate = 0;\\n    uint256 public rewardsDuration = 7 days;\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n\\n    mapping(address => uint256) userRewardPerTokenPaid;\\n    mapping(address => uint256) public rewards;\\n\\n    uint256 private _totalSupply;\\n    mapping(address => uint256) private _balances;\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n    event RewardsDurationUpdated(uint256 newDuration);\\n    event Recovered(address token, uint256 amount);\\n\\n    modifier updateReward(address account) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        if (account != address(0)) {\\n            rewards[account] = earned(account);\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    constructor(address _stakingToken, address _rewardsToken) {\\n        stakingToken = IERC20(_stakingToken);\\n        rewardsToken = IERC20(_rewardsToken);\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (_totalSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored.add(\\n                lastTimeRewardApplicable()\\n                    .sub(lastUpdateTime)\\n                    .mul(rewardRate)\\n                    .mul(1e18)\\n                    .div(_totalSupply)\\n            );\\n    }\\n\\n    function stake(uint256 amount)\\n        external\\n        nonReentrant\\n        notPaused\\n        updateReward(msg.sender)\\n    {\\n        require(amount > 0, 'Cannot stake 0');\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    function withdraw(uint256 amount)\\n        public\\n        nonReentrant\\n        updateReward(msg.sender)\\n    {\\n        require(amount > 0, 'Cannot withdraw 0');\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        stakingToken.safeTransfer(msg.sender, amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function earned(address account) public view returns (uint256) {\\n        return\\n            _balances[account]\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\n                .div(1e18)\\n                .add(rewards[account]);\\n    }\\n\\n    function getRewardForDuration() external view returns (uint256) {\\n        return rewardRate.mul(rewardsDuration);\\n    }\\n\\n    function getReward() public nonReentrant updateReward(msg.sender) {\\n        uint256 reward = rewards[msg.sender];\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n            rewardsToken.safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    function notifyRewardAmount(uint256 reward)\\n        external\\n        override\\n        onlyRewardsDistribution\\n        updateReward(address(0))\\n    {\\n        if (block.timestamp >= periodFinish) {\\n            rewardRate = reward.div(rewardsDuration);\\n        } else {\\n            uint256 remaining = periodFinish.sub(block.timestamp);\\n            uint256 leftover = remaining.mul(rewardRate);\\n            rewardRate = reward.add(leftover).div(rewardsDuration);\\n        }\\n\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\n        // This keeps the reward rate in the right range, preventing overflows due to\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\n        uint256 balance = rewardsToken.balanceOf(address(this));\\n        require(\\n            rewardRate <= balance.div(rewardsDuration),\\n            'Provided reward too high'\\n        );\\n\\n        lastUpdateTime = block.timestamp;\\n        periodFinish = block.timestamp.add(rewardsDuration);\\n        emit RewardAdded(reward);\\n    }\\n\\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\\n        require(\\n            block.timestamp > periodFinish,\\n            'Previous rewards period must be complete before changing the duration for the new period'\\n        );\\n        rewardsDuration = _rewardsDuration;\\n        emit RewardsDurationUpdated(rewardsDuration);\\n    }\\n}\\n\",\"keccak256\":\"0xe1f5684233b7b5d2fb7eae0bbf0da879236e494aa3b654d58a2634cf1b182a39\",\"license\":\"GPL-3.0\"},\"contracts/component/vault/BaseSecurityEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/utils/Address.sol';\\nimport 'openzeppelin-solidity/contracts/security/ReentrancyGuard.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '../../libraries/EthAddressLib.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract BaseSecurityEscrow is ReentrancyGuard {\\n    using Address for address payable;\\n    using SafeERC20 for ERC20;\\n\\n    struct Deposit {\\n        uint256 amount;\\n        uint40 depositTime;\\n    }\\n\\n    event Deposited(address indexed payee, address token, uint256 amount);\\n    event Withdrawn(address indexed payee, address token, uint256 amount);\\n\\n    // reserve address => amount\\n    mapping(address => uint256) private _deposits;\\n    // reserve address => user address => deposit record\\n    mapping(address => mapping(address => Deposit[])) private _depositRecords;\\n\\n    uint40 private _lockupTimeInSeconds = 7 days;\\n\\n    /**\\n     * @dev Stores the sent amount as credit to be withdrawn.\\n     * @param _reserve the asset address\\n     * @param _user user address who deposit to this escrow\\n     * @param _amount token amount need to transfer\\n     */\\n    function _deposit(\\n        address _reserve,\\n        address _user,\\n        uint256 _amount\\n    ) internal {\\n        if (_reserve != EthAddressLib.ethAddress()) {\\n            require(\\n                msg.value == 0,\\n                'User is sending ETH along with the ERC20 transfer.'\\n            );\\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\\n        } else {\\n            require(\\n                msg.value == _amount,\\n                'The amount and the value sent to deposit do not match'\\n            );\\n        }\\n        _deposits[_reserve] += _amount;\\n        Deposit memory deposit = Deposit(_amount, uint40(block.timestamp));\\n        _depositRecords[_reserve][_user].push(deposit);\\n        emit Deposited(_user, _reserve, _amount);\\n    }\\n\\n    function eligibleAmount(address _reserve, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        Deposit[] storage deposits = _depositRecords[_reserve][_user];\\n        uint256 eligibleAmount = 0;\\n        for (uint256 i = 0; i < deposits.length; i++) {\\n            if (\\n                uint40(block.timestamp) - deposits[i].depositTime >\\n                _lockupTimeInSeconds\\n            ) {\\n                eligibleAmount += deposits[i].amount;\\n            }\\n        }\\n        return eligibleAmount;\\n    }\\n\\n    /**\\n     * @dev Withdraw accumulated balance for a payee, only beyond _lockupTimeInSeconds\\n     * @param _reserve the asset address\\n     * @param _user user address who deposit to this escrow\\n     */\\n    function _withdraw(\\n        address _reserve,\\n        address payable _user,\\n        uint256 _amount\\n    ) internal {\\n        Deposit[] storage deposits = _depositRecords[_reserve][_user];\\n        uint256 eligibleAmount = 0;\\n        uint40 lastUpdateTime;\\n        for (uint256 i = 0; i < deposits.length; i++) {\\n            if (\\n                uint40(block.timestamp) - deposits[i].depositTime >\\n                _lockupTimeInSeconds\\n            ) {\\n                eligibleAmount += deposits[i].amount;\\n                lastUpdateTime = deposits[i].depositTime;\\n                delete deposits[i];\\n            }\\n        }\\n\\n        require(\\n            eligibleAmount >= _amount,\\n            'Do not have enough amount to withdraw'\\n        );\\n        // todo check borrow amount\\n        // if there is any amount left from eligible amount, push it back\\n        if (eligibleAmount > _amount) {\\n            uint256 leftAmount = eligibleAmount - _amount;\\n            Deposit memory leftDeposit = Deposit(leftAmount, lastUpdateTime);\\n            _depositRecords[_reserve][_user].push(leftDeposit);\\n        }\\n\\n        _deposits[_reserve] -= _amount;\\n        transferToUser(_reserve, _user, _amount);\\n        emit Withdrawn(_user, _reserve, _amount);\\n    }\\n\\n    /**\\n     * @dev get accumulated amount of deposit.\\n     * @param _reserve the address of the reserve where the transfer is happening\\n     * @return accumulated deposit amount\\n     **/\\n    function getDepositAmount(address _reserve) public view returns (uint256) {\\n        return _deposits[_reserve];\\n    }\\n\\n    /**\\n     * @dev get all records of deposit.\\n     * @param _reserve the address of the reserve where the transfer is happening\\n     * @param _user the address of the user receiving the transfer\\n     * @return deposit records\\n     **/\\n    function getDepositRecords(address _reserve, address _user)\\n        public\\n        view\\n        returns (Deposit[] memory)\\n    {\\n        Deposit[] storage deposits = _depositRecords[_reserve][_user];\\n        return deposits;\\n    }\\n\\n    /**\\n     * @dev transfers to the user a specific amount from the reserve.\\n     * @param _reserve the address of the reserve where the transfer is happening\\n     * @param _user the address of the user receiving the transfer\\n     * @param _amount the amount being transferred\\n     **/\\n    function transferToUser(\\n        address _reserve,\\n        address payable _user,\\n        uint256 _amount\\n    ) internal {\\n        if (_reserve != EthAddressLib.ethAddress()) {\\n            ERC20(_reserve).safeTransfer(_user, _amount);\\n        } else {\\n            //solium-disable-next-line\\n            (bool result, ) = _user.call{value: _amount}('');\\n            require(result, 'Transfer of ETH failed');\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb1d8511b81c3c13d9176832043671321537cac11101c2f4102f47cc5883d9e2a\",\"license\":\"GPL-3.0\"},\"contracts/component/vault/SecurityDepositEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../libraries/ownership/Ownable.sol';\\nimport './BaseSecurityEscrow.sol';\\n\\ncontract SecurityDepositEscrow is BaseSecurityEscrow {\\n    address public vault;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == vault, 'Not vault');\\n        _;\\n    }\\n\\n    constructor(address _vault) {\\n        vault = _vault;\\n    }\\n\\n    function getVersion() external view returns (string memory) {\\n        string memory version = 'SecurityDepositEscrow 0.0.1';\\n        return version;\\n    }\\n\\n    // placeholder function\\n    function slash(\\n        address _reserve,\\n        address payable _to,\\n        uint256 _amount\\n    ) public payable nonReentrant onlyOwner {\\n        transferToUser(_reserve, _to, _amount);\\n    }\\n\\n    function deposit(\\n        address _reserve,\\n        address _user,\\n        uint256 _amount\\n    ) public payable nonReentrant onlyOwner {\\n        _deposit(_reserve, _user, _amount);\\n    }\\n\\n    function withdraw(\\n        address _reserve,\\n        address payable _user,\\n        uint256 _amount\\n    ) public onlyOwner {\\n        _withdraw(_reserve, _user, _amount);\\n    }\\n}\\n\",\"keccak256\":\"0xa73cc51f6bece11daea3a57055cdca9299c98d5e7c6f7f899fe8184d75dec289\",\"license\":\"GPL-3.0\"},\"contracts/component/vault/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/security/ReentrancyGuard.sol';\\nimport './SecurityDepositEscrow.sol';\\nimport '../infra/AddressResolver.sol';\\nimport '../Voyager.sol';\\nimport '../staking/StakingRewards.sol';\\nimport '../../tokenization/SecurityDepositToken.sol';\\nimport '../../tokenization/StableDebtToken.sol';\\nimport '../../libraries/math/WadRayMath.sol';\\nimport '../../interfaces/IVault.sol';\\nimport '../../interfaces/IVaultManagerProxy.sol';\\nimport './VaultManager.sol';\\nimport '../../interfaces/IACLManager.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract Vault is ReentrancyGuard, IVault {\\n    using WadRayMath for uint256;\\n    bytes32 public constant BORROWER = keccak256('BORROWER');\\n\\n    address public voyager;\\n    address[] public players;\\n    bool public initialized;\\n    SecurityDepositEscrow public securityDepositEscrow;\\n    SecurityDepositToken public securityDepositToken;\\n    StableDebtToken public stableDebtToken;\\n    StakingRewards public stakingContract;\\n\\n    uint256 public totalDebt;\\n    // todo oracle\\n    uint256 public gav;\\n\\n    modifier onlyLoanManager() {\\n        _requireCallerLoanManager();\\n        _;\\n    }\\n\\n    modifier onlyVaultManager() {\\n        _requireVaultManager();\\n        _;\\n    }\\n\\n    modifier onlyVaultManagerContract() {\\n        _requireCallerLoanManagerContract();\\n        _;\\n    }\\n\\n    function initialize(\\n        address _voyager,\\n        SecurityDepositEscrow _securityDepositEscrow\\n    ) external {\\n        if (!initialized) {\\n            voyager = _voyager;\\n            securityDepositEscrow = _securityDepositEscrow;\\n            initialized = true;\\n        }\\n    }\\n\\n    function initSecurityDepositToken(address _reserve)\\n        external\\n        onlyVaultManager\\n    {\\n        require(\\n            address(securityDepositToken) == address(0),\\n            'Vault: security deposit token has been initialized'\\n        );\\n        ERC20 token = ERC20(_reserve);\\n        securityDepositToken = new SecurityDepositToken(\\n            _reserve,\\n            token.decimals(),\\n            token.name(),\\n            token.symbol()\\n        );\\n    }\\n\\n    function initStakingContract(address _reserve) external onlyVaultManager {\\n        require(\\n            address(stakingContract) == address(0),\\n            'Vault: staking contract has been initialized'\\n        );\\n        require(\\n            address(securityDepositToken) != address(0),\\n            'Vault: security deposit token has not been initialized'\\n        );\\n        stakingContract = new StakingRewards(\\n            address(securityDepositToken),\\n            _reserve\\n        );\\n    }\\n\\n    /**\\n     * @dev Transfer some deposit security\\n     * @param _sponsor user address who deposit to this escrow\\n     * @param _reserve reserve address\\n     * @param _amount deposit amount\\n     **/\\n    function depositSecurity(\\n        address _sponsor,\\n        address _reserve,\\n        uint256 _amount\\n    ) external payable nonReentrant onlyVaultManager {\\n        address vmp = Voyager(voyager).addressResolver().getVaultManagerProxy();\\n        IVaultManagerProxy vaultManagerProxy = IVaultManagerProxy(vmp);\\n        DataTypes.VaultConfig memory vaultConfig = vaultManagerProxy\\n            .getVaultConfig(_reserve);\\n\\n        // check max security deposit amount for this _reserve\\n        uint256 maxAllowedAmount = vaultConfig.maxSecurityDeposit;\\n        uint256 depositedAmount = securityDepositEscrow.getDepositAmount(\\n            _reserve\\n        );\\n        require(\\n            depositedAmount + _amount < maxAllowedAmount,\\n            'Vault: deposit amount exceed'\\n        );\\n\\n        // check min security deposit amount for this _reserve\\n        uint256 minAllowedAmount = vaultConfig.minSecurityDeposit;\\n        require(minAllowedAmount <= _amount, 'Vault: deposit too small');\\n\\n        securityDepositEscrow.deposit(_reserve, _sponsor, _amount);\\n        securityDepositToken.mintOnDeposit(_sponsor, _amount);\\n    }\\n\\n    /**\\n     * @dev Redeem underlying reserve\\n     * @param _sponsor sponsor address\\n     * @param _reserve reserve address\\n     * @param _amount redeem amount\\n     **/\\n    function redeemSecurity(\\n        address payable _sponsor,\\n        address _reserve,\\n        uint256 _amount\\n    ) external payable nonReentrant onlyVaultManager {\\n        require(\\n            _amount <= _getWithdrawableDeposit(_sponsor, _reserve),\\n            'Vault: cannot redeem more than withdrawable deposit amount'\\n        );\\n        securityDepositEscrow.withdraw(\\n            _reserve,\\n            _sponsor,\\n            _underlyingBalance(_sponsor, _reserve)\\n        );\\n        securityDepositToken.burnOnRedeem(_sponsor, _amount);\\n    }\\n\\n    function increaseTotalDebt(uint256 _amount)\\n        external\\n        onlyVaultManagerContract\\n    {\\n        totalDebt += _amount;\\n    }\\n\\n    // placeholder function\\n    function slash(\\n        address _reserve,\\n        address payable _to,\\n        uint256 _amount\\n    ) external nonReentrant onlyVaultManager {\\n        securityDepositEscrow.slash(_reserve, _to, _amount);\\n    }\\n\\n    /************************************** View Functions **************************************/\\n\\n    /**\\n     * @dev get current security amount\\n     * @param _reserve underlying asset address\\n     **/\\n    function getCurrentSecurityDeposit(address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return securityDepositEscrow.getDepositAmount(_reserve);\\n    }\\n\\n    function getActualSecurityDeposit(address _reserve)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return ERC20(_reserve).balanceOf(address(securityDepositEscrow));\\n    }\\n\\n    /**\\n     * @dev Get total debt of the vault\\n     **/\\n    function getTotalDebt() external view returns (uint256) {\\n        return totalDebt;\\n    }\\n\\n    function getGav() external view returns (uint256) {\\n        return gav;\\n    }\\n\\n    function getWithdrawableDeposit(address _sponsor, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _getWithdrawableDeposit(_sponsor, _reserve);\\n    }\\n\\n    function underlyingBalance(address _sponsor, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _underlyingBalance(_sponsor, _reserve);\\n    }\\n\\n    function getSecurityDepositTokenAddress() external view returns (address) {\\n        return address(securityDepositToken);\\n    }\\n\\n    function getStakingContractAddress() external view returns (address) {\\n        return address(stakingContract);\\n    }\\n\\n    /**\\n     * @dev Get SecurityDepositEscrow contract address\\n     * @return address\\n     **/\\n    function getSecurityDepositEscrowAddress() external view returns (address) {\\n        return address(securityDepositEscrow);\\n    }\\n\\n    function getVersion() external view returns (string memory) {\\n        string memory version = 'Vault 0.0.1';\\n        return version;\\n    }\\n\\n    /************************************** Internal Functions **************************************/\\n\\n    function _requireCallerLoanManager() internal {\\n        Voyager v = Voyager(voyager);\\n        IACLManager aclManager = IACLManager(\\n            v.addressResolver().getAclManager()\\n        );\\n        require(\\n            aclManager.isLoanManager(msg.sender),\\n            'Not loan manager contract'\\n        );\\n    }\\n\\n    function _requireCallerLoanManagerContract() internal {\\n        Voyager v = Voyager(voyager);\\n        IACLManager aclManager = IACLManager(\\n            v.addressResolver().getAclManager()\\n        );\\n        require(\\n            aclManager.isLoanManagerContract(msg.sender),\\n            'Not loan manager'\\n        );\\n    }\\n\\n    function _requireVaultManager() internal {\\n        Voyager v = Voyager(voyager);\\n        IACLManager aclManager = IACLManager(\\n            v.addressResolver().getAclManager()\\n        );\\n        require(\\n            aclManager.isVaultManagerContract(msg.sender),\\n            'Not vault manager contract'\\n        );\\n    }\\n\\n    function _getVaultManagerAddress() internal view returns (address) {\\n        Voyager v = Voyager(voyager);\\n        return v.addressResolver().getVaultManager();\\n    }\\n\\n    function _underlyingBalance(address _sponsor, address _reserve)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 amountToRedeemInRay = securityDepositToken\\n            .balanceOf(_sponsor)\\n            .wadToRay()\\n            .rayDiv(securityDepositToken.totalSupply().wadToRay())\\n            .rayMul(getActualSecurityDeposit(_reserve).wadToRay());\\n        return amountToRedeemInRay.rayToWad();\\n    }\\n\\n    function getVaultManagerProxyAddress() private returns (address) {\\n        Voyager voyager = Voyager(voyager);\\n        address addressResolver = voyager.getAddressResolverAddress();\\n        return AddressResolver(addressResolver).getVaultManagerProxy();\\n    }\\n\\n    function _getUnusedDeposits(address _sponsor, address _reserve)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        address vmp = Voyager(voyager).addressResolver().getVaultManagerProxy();\\n        IVaultManagerProxy vaultManagerProxy = IVaultManagerProxy(vmp);\\n        DataTypes.VaultConfig memory vaultConfig = vaultManagerProxy\\n            .getVaultConfig(_reserve);\\n\\n        uint256 securityRequirement = vaultConfig.securityDepositRequirement;\\n        return\\n            securityDepositToken.balanceOf(_sponsor) -\\n            totalDebt.wadToRay().rayMul(securityRequirement);\\n    }\\n\\n    function _eligibleAmount(address _reserve, address _sponsor)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return securityDepositEscrow.eligibleAmount(_reserve, _sponsor);\\n    }\\n\\n    function _getWithdrawableDeposit(address _sponsor, address _reserve)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 withdrawableAmount = _getUnusedDeposits(_sponsor, _reserve);\\n        uint256 eligibleAmount = _eligibleAmount(_reserve, _sponsor);\\n        if (eligibleAmount < withdrawableAmount) {\\n            withdrawableAmount = eligibleAmount;\\n        }\\n        return withdrawableAmount;\\n    }\\n}\\n\",\"keccak256\":\"0xdb92067ec52dfa27fb08c4153a39dbbcc32bb2ae000b8b539cf215c5aaa2a3bf\",\"license\":\"GPL-3.0\"},\"contracts/component/vault/VaultFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport './Vault.sol';\\nimport '../../interfaces/IVaultFactory.sol';\\nimport 'openzeppelin-solidity/contracts/utils/Create2.sol';\\n\\ncontract VaultFactory is IVaultFactory {\\n    function createVault(bytes32 salt) external returns (address) {\\n        bytes memory bytecode = type(Vault).creationCode;\\n        return Create2.deploy(0, salt, type(Vault).creationCode);\\n    }\\n}\\n\",\"keccak256\":\"0x813b1ad103508cd4a790dc163b2b2cf1441e63d2a00138f1908e8cc2330763e1\",\"license\":\"GPL-3.0\"},\"contracts/component/vault/VaultManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\nimport 'openzeppelin-solidity/contracts/security/ReentrancyGuard.sol';\\nimport '../../libraries/proxy/Proxyable.sol';\\nimport '../../libraries/math/WadRayMath.sol';\\nimport '../../interfaces/IVaultManager.sol';\\nimport '../../interfaces/IAddressResolver.sol';\\nimport '../../interfaces/IVaultFactory.sol';\\nimport '../../interfaces/IVault.sol';\\nimport '../../interfaces/IACLManager.sol';\\nimport './VaultStorage.sol';\\nimport './VaultFactory.sol';\\n\\ncontract VaultManager is ReentrancyGuard, Proxyable, IVaultManager {\\n    using WadRayMath for uint256;\\n    using SafeMath for uint256;\\n\\n    IAddressResolver public addressResolver;\\n    address public vaultFactory;\\n\\n    constructor(\\n        address payable _proxy,\\n        address _addressResolver,\\n        address _voyager,\\n        address _vaultFactory\\n    ) public Proxyable(_proxy) {\\n        addressResolver = IAddressResolver(_addressResolver);\\n        vaultFactory = _vaultFactory;\\n    }\\n\\n    modifier onlyAdmin() {\\n        _requireCallerAdmin();\\n        _;\\n    }\\n\\n    /************************************** User Functions **************************************/\\n\\n    /**\\n     * @dev Create a Vault for user\\n     * @param _user the address of the player\\n     **/\\n    function createVault(\\n        address _user,\\n        address _reserve,\\n        bytes32 _salt\\n    ) external onlyProxy returns (address) {\\n        address vault = VaultFactory(vaultFactory).createVault(_salt);\\n        require(vault != address(0), 'deploy vault failed');\\n        uint256 len = VaultStorage(getVaultStorageAddress()).pushNewVault(\\n            _user,\\n            vault\\n        );\\n        proxy._emit(\\n            abi.encode(vault, len),\\n            2,\\n            keccak256('VaultCreated(address, address, uint256)'),\\n            bytes32(abi.encodePacked(_user)),\\n            0,\\n            0\\n        );\\n        return vault;\\n    }\\n\\n    function initVault(address _vault, address _reserve) external onlyProxy {\\n        SecurityDepositEscrow securityDepositEscrow = new SecurityDepositEscrow(\\n            _vault\\n        );\\n        IVault(_vault).initialize(\\n            addressResolver.getVoyage(),\\n            securityDepositEscrow\\n        );\\n        IVault(_vault).initSecurityDepositToken(_reserve);\\n    }\\n\\n    /**\\n     * @dev Delegate call to Vault's depositSecurity\\n     * @param _sponsor who actual deposits the reserve into the amount\\n     * @param _vaultUser user address\\n     * @param _reserve reserve address\\n     * @param _amount amount user is willing to deposit\\n     */\\n    function depositSecurity(\\n        address _sponsor,\\n        address _vaultUser,\\n        address _reserve,\\n        uint256 _amount\\n    ) external onlyProxy {\\n        address vaultAddress = _getVault(_vaultUser);\\n        IVault(vaultAddress).depositSecurity(_sponsor, _reserve, _amount);\\n        _emit(\\n            _sponsor,\\n            _vaultUser,\\n            _reserve,\\n            _amount,\\n            keccak256('SecurityDeposited(address, address, address, uint256)')\\n        );\\n    }\\n\\n    /**\\n     * @dev  Delegate call to Vault's redeemSecurity\\n     * @param _sponsor sponsor address\\n     * @param _vaultUser user address\\n     * @param _reserve reserve address\\n     * @param _amount redeem amount\\n     **/\\n    function redeemSecurity(\\n        address payable _sponsor,\\n        address _vaultUser,\\n        address _reserve,\\n        uint256 _amount\\n    ) external onlyProxy {\\n        address vaultAddress = _getVault(_vaultUser);\\n        Vault(vaultAddress).redeemSecurity(_sponsor, _reserve, _amount);\\n        proxy._emit(\\n            abi.encode(_vaultUser, _reserve, _amount),\\n            2,\\n            keccak256('SecurityRedeemed(address, address, address, uint256)'),\\n            bytes32(abi.encodePacked(_sponsor)),\\n            0,\\n            0\\n        );\\n    }\\n\\n    // placeholder function\\n    function slash(\\n        address _vaultUser,\\n        address _reserve,\\n        address payable _to,\\n        uint256 _amount\\n    ) public nonReentrant onlyProxy {\\n        address vaultAddress = _getVault(_vaultUser);\\n        return Vault(vaultAddress).slash(_reserve, _to, _amount);\\n    }\\n\\n    /************************ HouseKeeping Function ******************************/\\n\\n    /**\\n     * @dev Set max security deposit for _reserve\\n     * @param _reserve reserve address\\n     * @param _amount max amount sponsor can deposit\\n     */\\n    function setMaxSecurityDeposit(address _reserve, uint256 _amount)\\n        external\\n        onlyProxy\\n        onlyAdmin\\n    {\\n        VaultStorage(getVaultStorageAddress()).setMaxSecurityDeposit(\\n            _reserve,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Set min security deposit for _reserve\\n     * @param _reserve reserve address\\n     * @param _amount min amount sponsor can deposit\\n     */\\n    function setMinSecurityDeposit(address _reserve, uint256 _amount)\\n        external\\n        onlyProxy\\n        onlyAdmin\\n    {\\n        VaultStorage(getVaultStorageAddress()).setMinSecurityDeposit(\\n            _reserve,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Update the security deposit requirement\\n     * @param _reserve reserve address\\n     * @param _requirement expressed in Ray\\n     */\\n    function setSecurityDepositRequirement(\\n        address _reserve,\\n        uint256 _requirement\\n    ) external onlyProxy onlyAdmin {\\n        VaultStorage(getVaultStorageAddress()).setSecurityDepositRequirement(\\n            _reserve,\\n            _requirement\\n        );\\n    }\\n\\n    /************************************** View Functions **************************************/\\n\\n    function getVaultConfig(address _reserve)\\n        external\\n        view\\n        onlyProxy\\n        returns (DataTypes.VaultConfig memory)\\n    {\\n        return VaultStorage(getVaultStorageAddress()).getVaultConfig(_reserve);\\n    }\\n\\n    /**\\n     * @dev Get available credit\\n     * @param _user user address\\n     * @param _reserve reserve address\\n     **/\\n    function getAvailableCredit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint256 creditLimit = getCreditLimit(_user, _reserve);\\n        uint256 accumulatedDebt = IVault(_getVault(_user)).getTotalDebt();\\n        return creditLimit - accumulatedDebt;\\n    }\\n\\n    /**\\n     * @dev Get credit limit for a specific reserve\\n     * @param _user user address\\n     * @return _reserve reserve address\\n     **/\\n    function getCreditLimit(address _user, address _reserve)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 currentSecurityDeposit = _getSecurityDeposit(_user, _reserve);\\n        DataTypes.VaultConfig memory vc = VaultStorage(getVaultStorageAddress())\\n            .getVaultConfig(_reserve);\\n        uint256 securityDepositRequirement = vc.securityDepositRequirement;\\n        require(\\n            securityDepositRequirement != 0,\\n            'security deposit requirement cannot be 0'\\n        );\\n        uint256 creditLimitInRay = currentSecurityDeposit.wadToRay().rayDiv(\\n            securityDepositRequirement\\n        );\\n        return creditLimitInRay.rayToWad();\\n    }\\n\\n    function getSecurityDeposit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _getSecurityDeposit(_user, _reserve);\\n    }\\n\\n    function getVaultStorageAddress() private view returns (address) {\\n        return addressResolver.getVaultStorage();\\n    }\\n\\n    function getSecurityDepositTokenAddress(address vault)\\n        private\\n        view\\n        returns (address)\\n    {\\n        return IVault(vault).getSecurityDepositTokenAddress();\\n    }\\n\\n    /**\\n     * @dev Get existing Vault contract address for user\\n     * @param _user the address of the player\\n     * @return Vault address\\n     **/\\n    function getVault(address _user) external view returns (address) {\\n        return _getVault(_user);\\n    }\\n\\n    function getAllVaults() external view returns (address[] memory) {\\n        return VaultStorage(getVaultStorageAddress()).getAllVaults();\\n    }\\n\\n    function getWithdrawableDeposit(\\n        address _vaultUser,\\n        address _reserve,\\n        address _sponsor\\n    ) public view returns (uint256) {\\n        address vaultAddress = _getVault(_vaultUser);\\n        return IVault(vaultAddress).getWithdrawableDeposit(_sponsor, _reserve);\\n    }\\n\\n    function getGav(address _user) external view returns (uint256) {\\n        return IVault(_getVault(_user)).getGav();\\n    }\\n\\n    /************************************** Private Functions **************************************/\\n\\n    function _getSecurityDeposit(address _user, address _reserve)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        address vaultAddress = _getVault(_user);\\n        uint256 currentSecurityDeposit = IVault(vaultAddress)\\n            .getCurrentSecurityDeposit(_reserve);\\n        return currentSecurityDeposit;\\n    }\\n\\n    function _getVault(address _user) internal view returns (address) {\\n        return VaultStorage(getVaultStorageAddress()).getVaultAddress(_user);\\n    }\\n\\n    function _requireCallerAdmin() internal {\\n        IACLManager aclManager = IACLManager(\\n            addressResolver.getAddress('aclManager')\\n        );\\n        require(aclManager.isVaultManager(messageSender), 'Not vault admin');\\n    }\\n\\n    function _emit(\\n        address _sponsor,\\n        address _vaultUser,\\n        address _reserve,\\n        uint256 _amount,\\n        bytes32 _topic\\n    ) internal {\\n        proxy._emit(\\n            abi.encode(_vaultUser, _reserve, _amount),\\n            2,\\n            _topic,\\n            bytes32(abi.encodePacked(_sponsor)),\\n            0,\\n            0\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x643bcdba191bfe9a3da566736ebd8a7c6f267a0b0a56957c95882f118ab5fda5\",\"license\":\"GPL-3.0\"},\"contracts/component/vault/VaultManagerProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../libraries/proxy/Proxy.sol';\\nimport '../../interfaces/IVaultManager.sol';\\nimport '../../interfaces/IVaultManagerProxy.sol';\\n\\ncontract VaultManagerProxy is Proxy, IVaultManagerProxy {\\n    /************************** Immutable static call for target contract **************************/\\n\\n    function getVaultConfig(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.VaultConfig memory)\\n    {\\n        return IVaultManager(address(target)).getVaultConfig(_reserve);\\n    }\\n\\n    function getCreditLimit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return IVaultManager(address(target)).getCreditLimit(_user, _reserve);\\n    }\\n\\n    function getAvailableCredit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            IVaultManager(address(target)).getAvailableCredit(_user, _reserve);\\n    }\\n\\n    function getSecurityDeposit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            IVaultManager(address(target)).getSecurityDeposit(_user, _reserve);\\n    }\\n\\n    function getWithdrawableDeposit(\\n        address _vaultUser,\\n        address _reserve,\\n        address _sponsor\\n    ) external view returns (uint256) {\\n        return\\n            IVaultManager(address(target)).getWithdrawableDeposit(\\n                _vaultUser,\\n                _reserve,\\n                _sponsor\\n            );\\n    }\\n\\n    function getVault(address _user) external view returns (address) {\\n        return IVaultManager(address(target)).getVault(_user);\\n    }\\n\\n    function getAllVaults() external view returns (address[] memory) {\\n        return IVaultManager(address(target)).getAllVaults();\\n    }\\n\\n    function getGav(address _user) external view returns (uint256) {\\n        return IVaultManager(address(target)).getGav(_user);\\n    }\\n}\\n\",\"keccak256\":\"0x915a2e22ed48c824418528df0d163a7c3662553d9c9eee77113526068960f1ab\",\"license\":\"GPL-3.0\"},\"contracts/component/vault/VaultStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../libraries/state/State.sol';\\nimport '../../libraries/types/DataTypes.sol';\\nimport '../../libraries/math/WadRayMath.sol';\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\n\\n// central storage for all vaults\\ncontract VaultStorage is State {\\n    using WadRayMath for uint256;\\n    using SafeMath for uint256;\\n\\n    address[] public allVaults;\\n    // player address => vault address\\n    mapping(address => address) public getVault;\\n\\n    mapping(address => DataTypes.VaultConfig) public vaultConfig;\\n\\n    constructor(address _vaultManager) State(_vaultManager) {}\\n\\n    function pushNewVault(address _player, address vault)\\n        external\\n        onlyAssociatedContract\\n        returns (uint256)\\n    {\\n        allVaults.push(vault);\\n        require(getVault[_player] == address(0), 'vault exists');\\n        getVault[_player] = vault;\\n        return allVaults.length;\\n    }\\n\\n    function setMaxSecurityDeposit(address _reserve, uint256 _amount)\\n        external\\n        onlyAssociatedContract\\n    {\\n        vaultConfig[_reserve].maxSecurityDeposit = _amount;\\n    }\\n\\n    function setMinSecurityDeposit(address _reserve, uint256 _amount)\\n        external\\n        onlyAssociatedContract\\n    {\\n        vaultConfig[_reserve].minSecurityDeposit = _amount;\\n    }\\n\\n    function setSecurityDepositRequirement(\\n        address _reserve,\\n        uint256 _requirement\\n    ) external onlyAssociatedContract {\\n        vaultConfig[_reserve].securityDepositRequirement = _requirement;\\n    }\\n\\n    /**\\n     * @dev Get Vault address for a specific user\\n     * @param _user the address of the player\\n     **/\\n    function getVaultAddress(address _user) external view returns (address) {\\n        return getVault[_user];\\n    }\\n\\n    /**\\n     * @dev Get all credit account addresses\\n     **/\\n    function getAllVaults() external view returns (address[] memory) {\\n        return allVaults;\\n    }\\n\\n    function getVaultConfig(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.VaultConfig memory)\\n    {\\n        return vaultConfig[_reserve];\\n    }\\n}\\n\",\"keccak256\":\"0xd86672816e5ae04063c0a62e2205086d93e036cd9274d5ac155fe65b7d13c7ec\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IACLManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\ninterface IACLManager {\\n    function grantLiquidityManager(address _admin) external;\\n\\n    function isLiquidityManager(address _admin) external view returns (bool);\\n\\n    function grantVaultManager(address _admin) external;\\n\\n    function isVaultManager(address _admin) external view returns (bool);\\n\\n    function grantPoolManager(address _admin) external;\\n\\n    function grantLoanManager(address _admin) external;\\n\\n    function isLoanManager(address _admin) external view returns (bool);\\n\\n    function isProtocolManager(address _admin) external view returns (bool);\\n\\n    function grantLiquidityManagerContract(address _admin) external;\\n\\n    function isLiquidityManagerContract(address _admin)\\n        external\\n        view\\n        returns (bool);\\n\\n    function grantLoanManagerContract(address _admin) external;\\n\\n    function isLoanManagerContract(address _admin) external view returns (bool);\\n\\n    function grantVaultManagerContract(address _admin) external;\\n\\n    function isVaultManagerContract(address _admin)\\n        external\\n        view\\n        returns (bool);\\n\\n    function grantVaultConfigurator(address _amin) external;\\n\\n    function isVaultConfigurator(address _admin) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xe4949e53b82d9df7cf439c8968be9f0ddbe58e3189061538b70ff598b690a35d\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\ninterface IAddressResolver {\\n    event AddressImported(bytes32 name, address destination);\\n\\n    function importAddresses(\\n        bytes32[] calldata names,\\n        address[] calldata destinations\\n    ) external;\\n\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason)\\n        external\\n        view\\n        returns (address);\\n\\n    function getVoyage() external view returns (address);\\n\\n    function getLiquidityManagerProxy() external view returns (address);\\n\\n    function getLiquidityManagerStorage() external view returns (address);\\n\\n    function getLiquidityDepositEscrow() external view returns (address);\\n\\n    function getLoanManagerProxy() external view returns (address);\\n\\n    function getLoanManager() external view returns (address);\\n\\n    function getVaultManagerProxy() external view returns (address);\\n\\n    function getVaultManager() external view returns (address);\\n\\n    function getStableDebtToken() external view returns (address);\\n\\n    function getExtCallProxyName() external view returns (address);\\n\\n    function getAclManager() external view returns (address);\\n\\n    function getVaultStorage() external view returns (address);\\n\\n    function getJuniorDepositToken() external view returns (address);\\n\\n    function getSeniorDepositToken() external view returns (address);\\n}\\n\",\"keccak256\":\"0x824133c52ed69c9d3870132e7915df2775d6d24971b0f3be21b178fdf757f029\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IHealthStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../libraries/types/DataTypes.sol';\\n\\ninterface IHealthStrategy {\\n    function getPremiumFactor() external view returns (uint256);\\n\\n    function getLoanTenure() external view returns (uint256);\\n\\n    function getWeightedLTV() external view returns (uint256);\\n\\n    function getWeightedRepaymentRatio() external view returns (uint256);\\n\\n    function calculateHealthRisk(DataTypes.HealthRiskParameter memory)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0xb5846e09c5c14a9365b2c5994acbc2d41459600e68b603d8cd12d5f6e1a5d8b7\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IInitializableDebtToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nabstract contract IInitializableDebtToken {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    uint256 private lastInitializedRevision = 0;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private initializing;\\n\\n    /**\\n     * @dev Emitted when a debt token is initialized\\n     * @param underlyingAsset The address of the underlying asset\\n     * @param debtTokenDecimals the decimals of the debt token\\n     * @param debtTokenName the name of the debt token\\n     * @param debtTokenSymbol the symbol of the debt token\\n     * @param params A set of encoded parameters for additional initialization\\n     **/\\n    event Initialized(\\n        address indexed underlyingAsset,\\n        uint8 debtTokenDecimals,\\n        string debtTokenName,\\n        string debtTokenSymbol,\\n        bytes params\\n    );\\n\\n    /**\\n     * @dev Modifier to use in the initializer function of a contract.\\n     */\\n    modifier initializer() {\\n        uint256 revision = getRevision();\\n        require(\\n            initializing ||\\n                isConstructor() ||\\n                revision > lastInitializedRevision,\\n            'Contract instance has already been initialized'\\n        );\\n\\n        bool isTopLevelCall = !initializing;\\n        if (isTopLevelCall) {\\n            initializing = true;\\n            lastInitializedRevision = revision;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev returns the revision number of the contract\\n     * Needs to be defined in the inherited class as a constant.\\n     **/\\n    function getRevision() internal pure virtual returns (uint256);\\n\\n    /**\\n     * @dev Returns true if the contract has been initialized\\n     **/\\n    function isInitialized() public view returns (bool) {\\n        return !initializing && getRevision() <= lastInitializedRevision;\\n    }\\n\\n    // todo return value\\n    function mint(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _tenure,\\n        uint256 _rate\\n    ) external virtual;\\n\\n    /**\\n     * @dev Returns true if and only if the function is running in the constructor\\n     **/\\n    function isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        uint256 cs;\\n        //solium-disable-next-line\\n        assembly {\\n            cs := extcodesize(address())\\n        }\\n        return cs == 0;\\n    }\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\",\"keccak256\":\"0x039d40f57de228bbc6991bb2d7ca3203986f3bf803d4da625e635bce71c5d29d\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/ILiquidityManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../libraries/logic/ReserveLogic.sol';\\n\\ninterface ILiquidityManager {\\n    function getReserveNormalizedIncome(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256);\\n\\n    function deposit(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche,\\n        uint256 _amount,\\n        address _user,\\n        address _onBehalfOf\\n    ) external;\\n\\n    function withdraw(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche,\\n        uint256 _amount,\\n        address payable _user\\n    ) external;\\n\\n    function withdrawAbleAmount(\\n        address _reserve,\\n        address _user,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256);\\n\\n    function balance(\\n        address _reserve,\\n        address _user,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xdabaf0f68ec03d717893313c892065a08adefe74d3160c97f954a0b9c731de6d\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/ILiquidityManagerProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../libraries/logic/ReserveLogic.sol';\\n\\ninterface ILiquidityManagerProxy {\\n    function getLiquidityRate(address _reserve, ReserveLogic.Tranche _tranche)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getReserveData(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.ReserveData memory);\\n\\n    function getLiquidityAndDebt(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.DepositAndDebt memory);\\n\\n    function getFlags(address _asset)\\n        external\\n        view\\n        returns (\\n            bool,\\n            bool,\\n            bool\\n        );\\n\\n    function getConfiguration(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.ReserveConfigurationMap memory);\\n\\n    function getReserveNormalizedIncome(\\n        address _asset,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256);\\n\\n    function withdrawAbleAmount(\\n        address _reserve,\\n        address _user,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256);\\n\\n    function balance(\\n        address _reserve,\\n        address _user,\\n        ReserveLogic.Tranche _tranche\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd4fc75511a9280ec88e8f10ba92d23a6a8b9a46dd9b240e48ae8d067d0fe3c44\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IMessageBus.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../libraries/types/DataTypes.sol';\\n\\ninterface IMessageBus {\\n    function getAddressResolverAddress() external view returns (address);\\n\\n    function getVault(address _user) external view returns (address);\\n\\n    function getReserveData(address _asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveData memory);\\n\\n    function getSecurityDeposit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCompoundedDebt(address _user) external view returns (uint256);\\n\\n    function getAggregateOptimalRepaymentRate(address _user)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getAggregateActualRepaymentRate(address _user)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0x7c9e70ab2e574912e7d16709f9b659bc4be47948142d795423843bf2c0a5f504\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IReserveInterestRateStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\n/**\\n@title IReserveInterestRateStrategyInterface interface\\n@notice Interface for the calculation of the interest rates.\\n*/\\n\\ninterface IReserveInterestRateStrategy {\\n    function calculateInterestRates(\\n        address reserve,\\n        uint256 availableLiquidity,\\n        uint256 totalStableDebt,\\n        uint256 averageBorrowRate\\n    ) external view returns (uint256, uint256);\\n\\n    function calculateInterestRates(\\n        address reserve,\\n        address liquidityEscrow,\\n        uint256 liquidityAdded,\\n        uint256 liquidityTaken,\\n        uint256 totalStableDebt,\\n        uint256 averageBorrowRate\\n    ) external view returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0xdef4da289a16168b03272c81a29078c7dc7b5df89b415d927471575277b1781b\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IReserveManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../libraries/logic/ReserveLogic.sol';\\n\\ninterface IReserveManager {\\n    function initReserve(\\n        address _asset,\\n        address _juniorDepositTokenAddress,\\n        address _seniorDepositTokenAddress,\\n        address _stableDebtAddress,\\n        address _interestRateStrategyAddress,\\n        address _healthStrategyAddress,\\n        uint256 _optimalIncomeRatio\\n    ) external;\\n\\n    function activeReserve(address _asset) external;\\n\\n    function getReserveData(address _asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveData memory);\\n\\n    function getReserveList() external view returns (address[] memory);\\n\\n    function getConfiguration(address _asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveConfigurationMap memory);\\n\\n    function getFlags(address _asset)\\n        external\\n        view\\n        returns (\\n            bool,\\n            bool,\\n            bool\\n        );\\n\\n    function getLiquidityRate(address _reserve, ReserveLogic.Tranche _tranche)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0x5e74263b6781174c5e0285627aad84f3b7ed11a3ada3b321f20d442e35224869\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IStableDebtToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\ninterface IStableDebtToken {\\n    /**\\n     * @dev Emitted when new stable debt is minted\\n     * @param user The address of the user who triggered the minting\\n     * @param amount The amount minted (user entered amount + balance increase from interest)\\n     * @param currentBalance The current balance of the user\\n     * @param balanceIncrease The increase in balance since the last action of the user\\n     * @param newRate The rate of the debt after the minting\\n     * @param avgStableRate The next average stable rate after the minting\\n     * @param newTotalSupply The next total supply of the stable debt token after the action\\n     **/\\n    event Mint(\\n        address indexed user,\\n        uint256 amount,\\n        uint256 currentBalance,\\n        uint256 balanceIncrease,\\n        uint256 newRate,\\n        uint256 avgStableRate,\\n        uint256 newTotalSupply\\n    );\\n\\n    function getAverageStableRate() external view returns (uint256);\\n\\n    function getTotalSupplyAndAvgRate()\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function getAggregateOptimalRepaymentRate(address _user)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getAggregateActualRepaymentRate(address _user)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0xe2f108067bebe79426ae636585fd801a5e0c0efcb97e2116ba5ec57d167be796\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IVToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IVToken {\\n    function mint(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external returns (bool);\\n\\n    function burn(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external;\\n\\n    function scaledBalanceOf(address _user) external view returns (uint256);\\n\\n    function transferUnderlyingTo(address _target, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x55267283dce2062ce5f98eb02bb65c9cbecbaa02badab1e5691ad7968ac86586\",\"license\":\"MIT\"},\"contracts/interfaces/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../component/vault/SecurityDepositEscrow.sol';\\n\\ninterface IVault {\\n    function initialize(\\n        address _voyager,\\n        SecurityDepositEscrow _securityDepositEscrow\\n    ) external;\\n\\n    function depositSecurity(\\n        address _sponsor,\\n        address _reserve,\\n        uint256 _amount\\n    ) external payable;\\n\\n    function redeemSecurity(\\n        address payable _sponsor,\\n        address _reserve,\\n        uint256 _amount\\n    ) external payable;\\n\\n    function increaseTotalDebt(uint256 _amount) external;\\n\\n    function slash(\\n        address _reserve,\\n        address payable _to,\\n        uint256 _amount\\n    ) external;\\n\\n    function initStakingContract(address _reserve) external;\\n\\n    function getSecurityDepositTokenAddress() external view returns (address);\\n\\n    function initSecurityDepositToken(address _reserve) external;\\n\\n    function underlyingBalance(address _sponsor, address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTotalDebt() external view returns (uint256);\\n\\n    function getGav() external view returns (uint256);\\n\\n    function getCurrentSecurityDeposit(address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getWithdrawableDeposit(address _sponsor, address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0x6656960684f55f3f02e9fb4710a00e95ac16e05282db9f779acd68106063dfd4\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IVaultFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\ninterface IVaultFactory {\\n    function createVault(bytes32 _salt) external returns (address);\\n}\\n\",\"keccak256\":\"0xcb900bf7e72d660f7aa1f1300fdd2dd0836a01566cd2b5ac887350b09418bc87\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IVaultManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../libraries/types/DataTypes.sol';\\n\\ninterface IVaultManager {\\n    function getVaultConfig(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.VaultConfig memory);\\n\\n    function getCreditLimit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getWithdrawableDeposit(\\n        address _vaultUser,\\n        address _reserve,\\n        address _sponsor\\n    ) external view returns (uint256);\\n\\n    function createVault(\\n        address _user,\\n        address _reserve,\\n        bytes32 _vault\\n    ) external returns (address);\\n\\n    function initVault(address _vault, address _reserve) external;\\n\\n    function getVault(address _user) external view returns (address);\\n\\n    function getAllVaults() external view returns (address[] memory);\\n\\n    function getGav(address _user) external view returns (uint256);\\n\\n    function getSecurityDeposit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getAvailableCredit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function setSecurityDepositRequirement(\\n        address _reserve,\\n        uint256 _requirement\\n    ) external;\\n\\n    function setMaxSecurityDeposit(address _reserve, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0xceeaef8c7d47823869e3ff35769c85ac400e011dae099fcf711a39e5fc706f29\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IVaultManagerProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../libraries/types/DataTypes.sol';\\n\\ninterface IVaultManagerProxy {\\n    function getVaultConfig(address _reserve)\\n        external\\n        view\\n        returns (DataTypes.VaultConfig memory);\\n\\n    function getCreditLimit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getAvailableCredit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getSecurityDeposit(address _user, address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getWithdrawableDeposit(\\n        address _vaultUser,\\n        address _reserve,\\n        address _sponsor\\n    ) external view returns (uint256);\\n\\n    function getVault(address _user) external view returns (address);\\n\\n    function getAllVaults() external view returns (address[] memory);\\n\\n    function getGav(address _user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x76939a639994bc5c5be2257878e54dec979224b19ef456d2a28ee72af65927ad\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IVoyagerComponent.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../component/Voyager.sol';\\nimport '../component/infra/AddressResolver.sol';\\nimport '../component/shared/storage/LiquidityManagerStorage.sol';\\nimport '../libraries/types/DataTypes.sol';\\n\\nabstract contract IVoyagerComponent {\\n    Voyager public voyager;\\n\\n    modifier requireNotPaused() {\\n        _whenNotPaused();\\n        _;\\n    }\\n\\n    function liquidityManagerStorageAddress() internal view returns (address) {\\n        return\\n            AddressResolver(voyager.getAddressResolverAddress())\\n                .getLiquidityManagerStorage();\\n    }\\n\\n    function _whenNotPaused() internal view {\\n        require(!paused(), Errors.LP_IS_PAUSED);\\n    }\\n\\n    function paused() internal view returns (bool) {\\n        address storageAddress = liquidityManagerStorageAddress();\\n        return LiquidityManagerStorage(storageAddress).paused();\\n    }\\n\\n    function getDepositAndDebt(address _reserve)\\n        public\\n        view\\n        returns (DataTypes.DepositAndDebt memory)\\n    {\\n        address storageAddress = liquidityManagerStorageAddress();\\n        return\\n            LiquidityManagerStorage(storageAddress).getDepositAndDebt(_reserve);\\n    }\\n}\\n\",\"keccak256\":\"0x5cef6eacffaa539d436fc2e47047bc77063a4f336089ba646c5d9585361e941c\",\"license\":\"GPL-3.0\"},\"contracts/libraries/EthAddressLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nlibrary EthAddressLib {\\n    /**\\n     * @dev returns the address used within the protocol to identify ETH\\n     * @return the address assigned to ETH\\n     */\\n    function ethAddress() internal pure returns (address) {\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    }\\n}\\n\",\"keccak256\":\"0xd804184a4493b89dbe84b06927f119535944d46889c5ffcd5d8ca6f4172a541f\",\"license\":\"GPL-3.0\"},\"contracts/libraries/acl/ExtCallACL.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../proxy/Proxyable.sol';\\nimport './IExtCallACL.sol';\\n\\ncontract ExtCallACL is Proxyable, IExtCallACL {\\n    mapping(address => bool) public whitelistedAddress;\\n    mapping(bytes32 => bool) public whitelistedFunctions;\\n\\n    constructor(address payable _proxy) public Proxyable(_proxy) {}\\n\\n    function whitelistAddress(address[] calldata _address) external onlyProxy {\\n        uint256 arrayLength = _address.length;\\n        for (uint256 i = 0; i < arrayLength; i++) {\\n            whitelistedAddress[_address[i]] = true;\\n        }\\n    }\\n\\n    function blockAddress(address[] calldata _address) external onlyProxy {\\n        uint256 arrayLength = _address.length;\\n        for (uint256 i = 0; i < arrayLength; i++) {\\n            delete whitelistedAddress[_address[i]];\\n        }\\n    }\\n\\n    function isWhitelistedAddress(address _address)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return whitelistedAddress[_address];\\n    }\\n\\n    function whitelistFunction(bytes32[] calldata _func) external onlyProxy {\\n        uint256 arrayLength = _func.length;\\n        for (uint256 i = 0; i < arrayLength; i++) {\\n            whitelistedFunctions[_func[i]] = true;\\n        }\\n    }\\n\\n    function blockFunction(bytes32[] calldata _func) external onlyProxy {\\n        uint256 arrayLength = _func.length;\\n        for (uint256 i = 0; i < arrayLength; i++) {\\n            delete whitelistedFunctions[_func[i]];\\n        }\\n    }\\n\\n    function isWhitelistedFunction(bytes32 _func) external view returns (bool) {\\n        return whitelistedFunctions[_func];\\n    }\\n}\\n\",\"keccak256\":\"0x8c57abec824593830eea470bdcf85bec411e797e8e979b6b7075e8d09db12057\",\"license\":\"GPL-3.0\"},\"contracts/libraries/acl/ExtCallACLProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../proxy/Proxy.sol';\\nimport './IExtCallACL.sol';\\n\\ncontract ExtCallACLProxy is Proxy {\\n    function isWhitelistedAddress(address _address) public view returns (bool) {\\n        return IExtCallACL(address(target)).isWhitelistedAddress(_address);\\n    }\\n\\n    function isWhitelistedFunction(bytes32 _func) public view returns (bool) {\\n        return IExtCallACL(address(target)).isWhitelistedFunction(_func);\\n    }\\n}\\n\",\"keccak256\":\"0x3ec9525d0851c9ac3b990c8d2a0fb8c8a4de54d653acdee841a916145fa12dea\",\"license\":\"GPL-3.0\"},\"contracts/libraries/acl/IExtCallACL.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\ninterface IExtCallACL {\\n    function whitelistAddress(address[] calldata _address) external;\\n\\n    function blockAddress(address[] calldata _address) external;\\n\\n    function isWhitelistedAddress(address _address)\\n        external\\n        view\\n        returns (bool);\\n\\n    function whitelistFunction(bytes32[] calldata _func) external;\\n\\n    function blockFunction(bytes32[] calldata _func) external;\\n\\n    function isWhitelistedFunction(bytes32 _func) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8243da9760ba180c6c523f75b57ae2a819667a8aeed8bdd4068a36c585413e81\",\"license\":\"GPL-3.0\"},\"contracts/libraries/configuration/ReserveConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../types/DataTypes.sol';\\n\\n/**\\n * @title ReserveConfiguration library\\n * @author Voyage\\n * @notice Implements the bitmap logic to handle the reserve configuration, inspired by Aave\\n **/\\nlibrary ReserveConfiguration {\\n    uint256 constant LIQUIDATE_BONUS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n    uint256 constant DECIMAL_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80FFFF; // prettier-ignore\\n    uint256 constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFF; // prettier-ignore\\n    uint256 constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFF; // prettier-ignore\\n    uint256 constant BORROWING_ENABLE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFF; // prettier-ignore\\n    uint256 constant RESERVED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF87FFFFFF; // prettier-ignore\\n    uint256 constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA0007FFFFFFF; // prettier-ignore\\n    uint256 constant LOCKUP_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80007FFFFFFFFFFF; // prettier-ignore\\n\\n    uint256 constant DECIMAL_MASK_BIT_POSITION = 16;\\n    uint256 constant ACTIVE_MASK_BIT_POSITION = 24;\\n    uint256 constant FROZEN_MASK_BIT_POSITION = 25;\\n    uint256 constant BORROWING_ENABLE_MASK_POSITION = 26;\\n    uint256 constant RESERVED_MASK_BIT_POSITION = 27;\\n    uint256 constant RESERVE_FACTOR_MASK_BIT_POSITION = 31;\\n    uint256 constant LOCKUP_PERIOD_MASK_BIT_POSITION = 47;\\n\\n    /**\\n     * Gets the configuration flags of the reserve\\n     * @param self The reserve configuration\\n     * @return The state flags representing active, frozen, borrowing enabled\\n     **/\\n    function getFlags(DataTypes.ReserveConfigurationMap memory self)\\n        internal\\n        view\\n        returns (\\n            bool,\\n            bool,\\n            bool\\n        )\\n    {\\n        uint256 dataLocal = self.data;\\n\\n        return (\\n            (dataLocal & ~ACTIVE_MASK) != 0,\\n            (dataLocal & ~FROZEN_MASK) != 0,\\n            (dataLocal & ~BORROWING_ENABLE_MASK) != 0\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets the active state of the reserve\\n     * @param self The reserve configuration\\n     * @param active The active state\\n     **/\\n    function setActive(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        bool active\\n    ) internal pure {\\n        self.data =\\n            (self.data & ACTIVE_MASK) |\\n            (uint256(active ? 1 : 0) << ACTIVE_MASK_BIT_POSITION);\\n    }\\n\\n    function getActive(DataTypes.ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return (self.data & ~ACTIVE_MASK) != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x23a62f92e3d54e0ea396ca9f3bdce06e7c38ef191b2c27ff582140207e5a28c2\",\"license\":\"GPL-3.0\"},\"contracts/libraries/helpers/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Errors library\\n * @author Voyager\\n * @notice Defines the error messages emitted by the different contracts of the Voyager protocol\\n * @dev Error messages prefix glossary:\\n *  - VL = ValidationLogic\\n *  - LM = LiquidityManager\\n *  - LOM = LoanManager\\n *  - CT = Common errors between tokens\\n *  - RL = ReserveLogic\\n */\\nlibrary Errors {\\n    string public constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0'\\n    string public constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve'\\n    string public constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve is frozen'\\n    string public constant CT_CALLER_MUST_BE_LIQUIDITY_MANAGER_POOL = '20';\\n    string public constant CT_CALLER_MUST_BE_LOAN_MANAGER = '21';\\n    string public constant CT_INVALID_MINT_AMOUNT = '21';\\n    string public constant CT_INVALID_BURN_AMOUNT = '22';\\n    string public constant LM_NOT_CONTRACT = '60';\\n    string public constant LP_IS_PAUSED = '61'; // 'Pool is paused'\\n    string public constant LOM_RESERVE_NOT_SUFFICIENT = '70';\\n    string public constant LOM_CREDIT_NOT_SUFFICIENT = '71';\\n    string public constant LOM_HEALTH_RISK_BELOW_ONE = '72';\\n    string public constant LOM_NOT_VAULT_OWNER = '73';\\n    string public constant LOM_INVALID_AMOUNT = '74';\\n    string public constant RL_LIQUIDITY_RATE_OVERFLOW = '80'; //  Liquidity rate overflows uint128\\n    string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '81'; //  Stable borrow rate overflows uint128\\n}\\n\",\"keccak256\":\"0xf14db11310eab23989ad47fb18577e601eea007dd4d10523f9eee71a87845a56\",\"license\":\"agpl-3.0\"},\"contracts/libraries/helpers/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../ownership/Ownable.sol';\\n\\nabstract contract Pausable is Ownable {\\n    uint256 public lastPauseTime;\\n    bool public paused;\\n\\n    constructor() {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), 'Owner must be set');\\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\\n    }\\n\\n    /**\\n     * @notice Change the paused state of the contract\\n     * @dev Only the contract owner may call this.\\n     */\\n    function setPaused(bool _paused) external onlyOwner {\\n        // Ensure we're actually changing the state before we do anything\\n        if (_paused == paused) {\\n            return;\\n        }\\n\\n        // Set our paused state.\\n        paused = _paused;\\n\\n        // If applicable, set the last pause time.\\n        if (paused) {\\n            lastPauseTime = block.timestamp;\\n        }\\n\\n        // Let everyone know that our pause state has changed.\\n        emit PauseChanged(paused);\\n    }\\n\\n    event PauseChanged(bool isPaused);\\n\\n    modifier notPaused() {\\n        require(\\n            !paused,\\n            'This action cannot be performed while the contract is paused'\\n        );\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xeb00aba958ad4f51f456bca0b5feba360518817b6f62b894fa16a923f425454a\",\"license\":\"agpl-3.0\"},\"contracts/libraries/logic/ReserveLogic.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\nimport '../math/WadRayMath.sol';\\nimport '../math/MathUtils.sol';\\nimport '../types/DataTypes.sol';\\nimport '../helpers/Errors.sol';\\nimport '../../interfaces/IStableDebtToken.sol';\\nimport '../../component/liquidity/DefaultReserveInterestRateStrategy.sol';\\nimport 'hardhat/console.sol';\\n\\n/**\\n * @title ReserveLogic library\\n * @author Voyager\\n * @notice Implements the logic to update the reserves state\\n **/\\nlibrary ReserveLogic {\\n    using SafeMath for uint256;\\n    using WadRayMath for uint256;\\n\\n    uint256 internal constant RAY = 1e27;\\n\\n    using ReserveLogic for DataTypes.ReserveData;\\n\\n    enum Tranche {\\n        JUNIOR,\\n        SENIOR\\n    }\\n\\n    /**\\n     * @dev Emitted when the state of a reserve is updated\\n     * @param asset The address of the underlying asset of the reserve\\n     * @param liquidityRate The new liquidity rate\\n     * @param stableBorrowRate The new stable borrow rate\\n     * @param liquidityIndex The new liquidity index\\n     **/\\n    event ReserveDataUpdated(\\n        address indexed asset,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate,\\n        uint256 liquidityIndex\\n    );\\n\\n    function init(\\n        DataTypes.ReserveData storage reserve,\\n        address _juniorDepositTokenAddress,\\n        address _seniorDepositTokenAddress,\\n        address _debtTokenAddress,\\n        address _interestRateStrategyAddress,\\n        address _healthStrategyAddress,\\n        uint256 _optimalIncomeRatio\\n    ) external {\\n        reserve.juniorLiquidityIndex = WadRayMath.ray();\\n        reserve.seniorLiquidityIndex = WadRayMath.ray();\\n        reserve.juniorDepositTokenAddress = _juniorDepositTokenAddress;\\n        reserve.seniorDepositTokenAddress = _seniorDepositTokenAddress;\\n        reserve.debtTokenAddress = _debtTokenAddress;\\n        reserve.interestRateStrategyAddress = _interestRateStrategyAddress;\\n        reserve.healthStrategyAddress = _healthStrategyAddress;\\n        reserve.optimalIncomeRatio = _optimalIncomeRatio;\\n    }\\n\\n    function updateState(\\n        DataTypes.ReserveData storage reserve,\\n        Tranche _tranche\\n    ) public {\\n        _updateIndexes(reserve, _tranche);\\n    }\\n\\n    function getLiquidityRate(\\n        DataTypes.ReserveData storage reserve,\\n        Tranche _tranche\\n    ) public view returns (uint256) {\\n        return reserve._getLiquidityRate(_tranche);\\n    }\\n\\n    struct UpdateInterestRatesLocalVars {\\n        address debtTokenAddress;\\n        uint256 availableLiquidity;\\n        uint256 juniorLiquidity;\\n        uint256 seniorLiquidity;\\n        uint256 liquidityRatio;\\n        uint256 totalDebt;\\n        // total liquidity rate\\n        uint256 newLiquidityRate;\\n        uint256 effectiveJuniorLiquidityRate;\\n        uint256 effectSeniorLiquidityRate;\\n        uint256 newBorrowRate;\\n        uint256 avgBorrowRate;\\n    }\\n\\n    // for the purposes of updating interest rates, we only care about senior tranche liquidity.\\n    function updateInterestRates(\\n        DataTypes.ReserveData storage _reserve,\\n        address _reserveAddress,\\n        address _juniorDepositTokenAddress,\\n        address _seniorDepositTokenAddress,\\n        uint256 _seniorLiquidityAdded,\\n        uint256 _seniorLiquidityTaken\\n    ) public {\\n        UpdateInterestRatesLocalVars memory vars;\\n\\n        vars.debtTokenAddress = _reserve.debtTokenAddress;\\n        (vars.totalDebt, vars.avgBorrowRate) = IStableDebtToken(\\n            _reserve.debtTokenAddress\\n        ).getTotalSupplyAndAvgRate();\\n\\n        (\\n            vars.newLiquidityRate,\\n            vars.newBorrowRate\\n        ) = IReserveInterestRateStrategy(_reserve.interestRateStrategyAddress)\\n            .calculateInterestRates(\\n                _reserveAddress,\\n                _seniorDepositTokenAddress,\\n                _seniorLiquidityAdded,\\n                _seniorLiquidityTaken,\\n                vars.totalDebt,\\n                vars.avgBorrowRate\\n            );\\n        require(\\n            vars.newLiquidityRate <= type(uint128).max,\\n            Errors.RL_LIQUIDITY_RATE_OVERFLOW\\n        );\\n        require(\\n            vars.newBorrowRate <= type(uint128).max,\\n            Errors.RL_STABLE_BORROW_RATE_OVERFLOW\\n        );\\n\\n        vars.seniorLiquidity = IERC20(_seniorDepositTokenAddress).totalSupply();\\n        vars.juniorLiquidity = IERC20(_juniorDepositTokenAddress).totalSupply();\\n\\n        if (vars.juniorLiquidity == 0) {\\n            vars.effectiveJuniorLiquidityRate = 0;\\n            vars.effectSeniorLiquidityRate = vars.newLiquidityRate;\\n        } else {\\n            vars.liquidityRatio = vars.seniorLiquidity.rayDiv(\\n                vars.juniorLiquidity\\n            );\\n\\n            vars.effectiveJuniorLiquidityRate = vars\\n                .newLiquidityRate\\n                .rayMul(RAY - _reserve.optimalIncomeRatio)\\n                .rayMul(vars.liquidityRatio);\\n\\n            vars.effectSeniorLiquidityRate = vars.newLiquidityRate.rayMul(\\n                _reserve.optimalIncomeRatio\\n            );\\n        }\\n\\n        _reserve.currentOverallLiquidityRate = vars.newLiquidityRate;\\n        _reserve.currentBorrowRate = vars.newBorrowRate;\\n        _reserve.currentJuniorLiquidityRate = vars.effectiveJuniorLiquidityRate;\\n        _reserve.currentSeniorLiquidityRate = vars.effectSeniorLiquidityRate;\\n\\n        emit ReserveDataUpdated(\\n            _reserveAddress,\\n            vars.newLiquidityRate,\\n            vars.newBorrowRate,\\n            vars.newLiquidityRate\\n        );\\n    }\\n\\n    function getNormalizedIncome(\\n        DataTypes.ReserveData storage reserve,\\n        Tranche _tranche\\n    ) internal view returns (uint256) {\\n        uint40 timestamp;\\n        uint256 liquidityIndex;\\n        if (_tranche == Tranche.JUNIOR) {\\n            timestamp = reserve.juniorLastUpdateTimestamp;\\n            liquidityIndex = reserve.juniorLiquidityIndex;\\n        } else {\\n            timestamp = reserve.seniorLastUpdateTimestamp;\\n            liquidityIndex = reserve.seniorLiquidityIndex;\\n        }\\n\\n        //solium-disable-next-line\\n        if (timestamp == uint40(block.timestamp)) {\\n            return liquidityIndex;\\n        }\\n\\n        uint256 cumulated = MathUtils\\n            .calculateLinearInterest(\\n                reserve._getLiquidityRate(_tranche),\\n                timestamp\\n            )\\n            .rayMul(liquidityIndex);\\n        return cumulated;\\n    }\\n\\n    function _getLiquidityRate(\\n        DataTypes.ReserveData storage reserve,\\n        Tranche _tranche\\n    ) internal view returns (uint256) {\\n        if (_tranche == Tranche.JUNIOR) {\\n            return reserve.currentJuniorLiquidityRate;\\n        } else {\\n            return reserve.currentSeniorLiquidityRate;\\n        }\\n    }\\n\\n    function _updateIndexes(\\n        DataTypes.ReserveData storage reserve,\\n        Tranche _tranche\\n    ) internal {\\n        if (_tranche == Tranche.JUNIOR) {\\n            uint256 previousJuniorLiquidityIndex = reserve.juniorLiquidityIndex;\\n            uint256 lastJuniorUpdatedTimestamp = reserve\\n                .juniorLastUpdateTimestamp;\\n            reserve._updateJuniorLiquidityIndex(\\n                previousJuniorLiquidityIndex,\\n                uint40(lastJuniorUpdatedTimestamp)\\n            );\\n        } else {\\n            uint256 previousSeniorLiquidityIndex = reserve.seniorLiquidityIndex;\\n            uint256 lastSeniorUpdatedTimestamp = reserve\\n                .seniorLastUpdateTimestamp;\\n            reserve._updateSeniorLiquidityIndex(\\n                previousSeniorLiquidityIndex,\\n                uint40(lastSeniorUpdatedTimestamp)\\n            );\\n        }\\n    }\\n\\n    function _updateJuniorLiquidityIndex(\\n        DataTypes.ReserveData storage reserve,\\n        uint256 juniorLiquidityIndex,\\n        uint40 timestamp\\n    ) internal returns (uint256) {\\n        uint256 juniorLiquidityRate = reserve._getLiquidityRate(Tranche.JUNIOR);\\n        uint256 newJuniorLiquidityIndex = juniorLiquidityIndex;\\n\\n        // only cumulating if there is any income being produced\\n        if (juniorLiquidityRate > 0) {\\n            uint256 cumulatedLiquidityInterest = MathUtils\\n                .calculateLinearInterest(juniorLiquidityRate, timestamp);\\n            newJuniorLiquidityIndex = cumulatedLiquidityInterest.rayMul(\\n                juniorLiquidityIndex\\n            );\\n            reserve.juniorLiquidityIndex = newJuniorLiquidityIndex;\\n        }\\n\\n        reserve.juniorLastUpdateTimestamp = uint40(block.timestamp);\\n        return newJuniorLiquidityIndex;\\n    }\\n\\n    function _updateSeniorLiquidityIndex(\\n        DataTypes.ReserveData storage reserve,\\n        uint256 seniorLiquidityIndex,\\n        uint40 timestamp\\n    ) internal returns (uint256) {\\n        uint256 seniorLiquidityRate = reserve._getLiquidityRate(Tranche.SENIOR);\\n        uint256 newSeniorLiquidityIndex = seniorLiquidityIndex;\\n\\n        if (seniorLiquidityRate > 0) {\\n            uint256 cumulatedLiquidityInterest = MathUtils\\n                .calculateLinearInterest(seniorLiquidityRate, timestamp);\\n            newSeniorLiquidityIndex = cumulatedLiquidityInterest.rayMul(\\n                seniorLiquidityIndex\\n            );\\n            reserve.seniorLiquidityIndex = newSeniorLiquidityIndex;\\n        }\\n        reserve.seniorLastUpdateTimestamp = uint40(block.timestamp);\\n        return newSeniorLiquidityIndex;\\n    }\\n\\n    function trancheToBytes32(Tranche tranche) public view returns (bytes32) {\\n        return bytes32(uint256(tranche));\\n    }\\n}\\n\",\"keccak256\":\"0xc4d136d2ae55bd21e6813b9cf8eb2426fac26fd8ed1411a15eb6a14c118ce88d\",\"license\":\"GPL-3.0\"},\"contracts/libraries/logic/ValidationLogic.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../types/DataTypes.sol';\\nimport '../configuration/ReserveConfiguration.sol';\\nimport '../helpers/Errors.sol';\\n\\nlibrary ValidationLogic {\\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n\\n    /**\\n     * @dev Validates a deposit token\\n     * @param reserve The reserve object on which the user is depositing\\n     * @param amount The amount to be deposited\\n     **/\\n    function validateDeposit(\\n        DataTypes.ReserveData storage reserve,\\n        uint256 amount\\n    ) external view {\\n        (bool isActive, bool isFrozen, ) = reserve.configuration.getFlags();\\n        require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n        require(!isFrozen, Errors.VL_RESERVE_FROZEN);\\n    }\\n}\\n\",\"keccak256\":\"0xdd470946bea9515caf3bfdc20ae4e78f2138dc785ae3650a0ac8951dedf3581e\",\"license\":\"GPL-3.0\"},\"contracts/libraries/math/MathUtils.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\nimport {WadRayMath} from './WadRayMath.sol';\\n\\nlibrary MathUtils {\\n    using SafeMath for uint256;\\n    using WadRayMath for uint256;\\n\\n    /// @dev Ignoring leap years\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n\\n    /**\\n     * @dev Function to calculate the interest accumulated using a linear interest rate formula\\n     * @param rate The interest rate, in ray\\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n     * @return The interest rate linearly accumulated during the timeDelta, in ray\\n     **/\\n\\n    function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        //solium-disable-next-line\\n        uint256 timeDifference = block.timestamp.sub(\\n            uint256(lastUpdateTimestamp)\\n        );\\n\\n        return\\n            (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());\\n    }\\n\\n    /**\\n     * @dev Function to calculate the interest using a compounded interest rate formula\\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n     *\\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n     *\\n     * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n     * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\n     *\\n     * @param rate The interest rate, in ray\\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n     * @return The interest rate compounded during the timeDelta, in ray\\n     **/\\n    function calculateCompoundedInterest(\\n        uint256 rate,\\n        uint40 lastUpdateTimestamp,\\n        uint256 currentTimestamp\\n    ) internal pure returns (uint256) {\\n        //solium-disable-next-line\\n        uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));\\n\\n        if (exp == 0) {\\n            return WadRayMath.ray();\\n        }\\n\\n        uint256 expMinusOne = exp - 1;\\n\\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n        uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\\n\\n        uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n        uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n        uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;\\n        uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(\\n            basePowerThree\\n        ) / 6;\\n\\n        return\\n            WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(\\n                thirdTerm\\n            );\\n    }\\n\\n    /**\\n     * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\\n     * @param rate The interest rate (in ray)\\n     * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\\n     **/\\n    function calculateCompoundedInterest(\\n        uint256 rate,\\n        uint40 lastUpdateTimestamp\\n    ) internal view returns (uint256) {\\n        return\\n            calculateCompoundedInterest(\\n                rate,\\n                lastUpdateTimestamp,\\n                block.timestamp\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xeb644d3d04ac6c043657b2b835fbf71d1f2795f1f713b900cc43582158f31eac\",\"license\":\"agpl-3.0\"},\"contracts/libraries/math/WadRayMath.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\n\\n/******************\\n@title WadRayMath library\\n@author Aave\\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n */\\n\\nlibrary WadRayMath {\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant halfWAD = WAD / 2;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant halfRAY = RAY / 2;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    function Ray() public pure returns (uint256) {\\n        return RAY;\\n    }\\n\\n    function ray() internal pure returns (uint256) {\\n        return RAY;\\n    }\\n\\n    function wad() internal pure returns (uint256) {\\n        return WAD;\\n    }\\n\\n    function halfRay() internal pure returns (uint256) {\\n        return halfRAY;\\n    }\\n\\n    function halfWad() internal pure returns (uint256) {\\n        return halfWAD;\\n    }\\n\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return halfWAD.add(a.mul(b)).div(WAD);\\n    }\\n\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 halfB = b / 2;\\n\\n        return halfB.add(a.mul(WAD)).div(b);\\n    }\\n\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return halfRAY.add(a.mul(b)).div(RAY);\\n    }\\n\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 halfB = b / 2;\\n\\n        return halfB.add(a.mul(RAY)).div(b);\\n    }\\n\\n    function rayToWad(uint256 a) internal pure returns (uint256) {\\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\\n\\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\\n    }\\n\\n    function wadToRay(uint256 a) internal pure returns (uint256) {\\n        return a.mul(WAD_RAY_RATIO);\\n    }\\n\\n    // @dev calculates base^exp. The code uses the ModExp precompile\\n    // @return base^exp, in ray\\n    //solium-disable-next-line\\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rayMul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rayMul(z, x);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x87bc93b45f82b290b2b6a9f00ce09f8c5c2b758931a85b37fb5d117a79031d3f\"},\"contracts/libraries/ownership/Ownable.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address public owner;\\n    address public pendingOwner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Modifier throws if called by any account other than the pendingOwner.\\n     */\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == pendingOwner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), 'Ownable: caller is not the owner');\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to set the pendingOwner address.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        pendingOwner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingOwner address to finalize the transfer.\\n     */\\n    function claimOwnership() public onlyPendingOwner {\\n        emit OwnershipTransferred(owner, pendingOwner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n}\\n\",\"keccak256\":\"0x5dca7c2446290ea3519aa0f9295e1edfbff47a1474edbe126f08dca92843e2c8\"},\"contracts/libraries/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../ownership/Ownable.sol';\\nimport './Proxyable.sol';\\n\\ncontract Proxy is Ownable {\\n    Proxyable public target;\\n\\n    event TargetUpdated(Proxyable newTarget);\\n\\n    modifier onlyTarget() {\\n        require(Proxyable(msg.sender) == target, 'Must be proxy target');\\n        _;\\n    }\\n\\n    function setTarget(Proxyable _target) external onlyOwner {\\n        target = _target;\\n        emit TargetUpdated(_target);\\n    }\\n\\n    function _emit(\\n        bytes calldata callData,\\n        uint256 numTopics,\\n        bytes32 topic1,\\n        bytes32 topic2,\\n        bytes32 topic3,\\n        bytes32 topic4\\n    ) external onlyTarget {\\n        uint256 size = callData.length;\\n        bytes memory _callData = callData;\\n\\n        assembly {\\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\\n             * This means moving call_data across 32 bytes guarantees we correctly access\\n             * the data itself. */\\n            switch numTopics\\n            case 0 {\\n                log0(add(_callData, 32), size)\\n            }\\n            case 1 {\\n                log1(add(_callData, 32), size, topic1)\\n            }\\n            case 2 {\\n                log2(add(_callData, 32), size, topic1, topic2)\\n            }\\n            case 3 {\\n                log3(add(_callData, 32), size, topic1, topic2, topic3)\\n            }\\n            case 4 {\\n                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\\n            }\\n        }\\n    }\\n\\n    // solhint-disable no-complex-fallback\\n    fallback() external payable {\\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\\n        target.setMessageSender(msg.sender);\\n\\n        assembly {\\n            let free_ptr := mload(0x40)\\n            calldatacopy(free_ptr, 0, calldatasize())\\n\\n            /* We must explicitly forward ether to the underlying contract as well. */\\n            let result := call(\\n                gas(),\\n                sload(target.slot),\\n                callvalue(),\\n                free_ptr,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            returndatacopy(free_ptr, 0, returndatasize())\\n\\n            if iszero(result) {\\n                revert(free_ptr, returndatasize())\\n            }\\n            return(free_ptr, returndatasize())\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x54fc918a0dbcb1ab42b9bea06b8dc10f26d2fcfa7c1cb1d813e1b017df4c9b9e\",\"license\":\"GPL-3.0\"},\"contracts/libraries/proxy/Proxyable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport './Proxy.sol';\\nimport '../ownership/Ownable.sol';\\nimport 'hardhat/console.sol';\\n\\nabstract contract Proxyable is Ownable {\\n    /* The proxy this contract exists behind. */\\n    Proxy public proxy;\\n\\n    /* The caller of the proxy, passed through to this contract.\\n     * Note that every function using this member must apply the onlyProxy or\\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\\n    address public messageSender;\\n\\n    modifier onlyProxy() {\\n        _onlyProxy();\\n        _;\\n    }\\n\\n    modifier optionalProxy_onlyOwner() {\\n        _optionalProxy_onlyOwner();\\n        _;\\n    }\\n\\n    event ProxyUpdated(address proxyAddress);\\n\\n    constructor(address payable _proxy) internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), 'Owner must be set');\\n\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function _onlyProxy() private view {\\n        require(msg.sender == address(proxy), 'Only the proxy can call');\\n    }\\n\\n    function setProxy(address payable _proxy) external onlyOwner {\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function setMessageSender(address sender) external onlyProxy {\\n        messageSender = sender;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _optionalProxy_onlyOwner() private {\\n        if (msg.sender != address(proxy) && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n        require(messageSender == owner, 'Owner only function');\\n    }\\n}\\n\",\"keccak256\":\"0xf556e7a5e4b7a7c961a92cbc27c9664bd3c095014eddedfde811453d0ea4af85\",\"license\":\"GPL-3.0\"},\"contracts/libraries/state/State.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../ownership/Ownable.sol';\\n\\nabstract contract State is Ownable {\\n    mapping(address => bool) public associatedContracts;\\n\\n    constructor(address _associatedContract) {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), 'Owner must be set');\\n\\n        associatedContracts[_associatedContract] = true;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    event AssociatedContractUpdated(address associatedContract);\\n\\n    modifier onlyAssociatedContract() {\\n        require(\\n            associatedContracts[msg.sender],\\n            'Only the associated contract can perform this action'\\n        );\\n        _;\\n    }\\n\\n    // Change the associated contract to a new address\\n    function setAssociatedContract(address _associatedContract)\\n        external\\n        onlyOwner\\n    {\\n        associatedContracts[_associatedContract] = true;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n}\\n\",\"keccak256\":\"0x835e4507f1c45e5cb1ac2ab722b38969af0c5e2bd4e4fb8fc34046d56d555b9f\",\"license\":\"GPL-3.0\"},\"contracts/libraries/types/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nlibrary DataTypes {\\n    enum Tranche {\\n        JUNIOR,\\n        SENIOR\\n    }\\n\\n    struct ReserveData {\\n        //stores the reserve configuration\\n        ReserveConfigurationMap configuration;\\n        // for calculating overall interested accumulated\\n        // then split it into two indexs base on two allocations\\n        uint256 currentOverallLiquidityRate;\\n        uint256 currentJuniorLiquidityRate;\\n        uint256 currentSeniorLiquidityRate;\\n        uint256 juniorLiquidityIndex;\\n        uint256 seniorLiquidityIndex;\\n        uint256 currentBorrowRate;\\n        // Expressed in ray\\n        uint256 securityRequirement;\\n        //the decimals of the reserve asset\\n        uint256 decimals;\\n        address interestRateStrategyAddress;\\n        address healthStrategyAddress;\\n        address juniorDepositTokenAddress;\\n        address seniorDepositTokenAddress;\\n        address debtTokenAddress;\\n        uint40 juniorLastUpdateTimestamp;\\n        uint40 seniorLastUpdateTimestamp;\\n        uint256 optimalTrancheRatio;\\n        uint256 currentIncomeRatio;\\n        uint256 optimalIncomeRatio;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        //bit 0-15: Liquidate bonus\\n        //bit 16-23: Decimals\\n        //bit 24: Reserve is active\\n        //bit 25: reserve is frozen\\n        //bit 26: borrowing is enabled\\n        //bit 27-30: reserved\\n        //bit 31-46: reserve factor\\n        //bit 47-62: lock up period in seconds\\n        uint256 data;\\n    }\\n\\n    struct VaultConfig {\\n        uint256 minSecurityDeposit;\\n        uint256 maxSecurityDeposit;\\n        uint256 securityDepositRequirement;\\n    }\\n\\n    struct FungibleTokenData {\\n        string symbol;\\n        address tokenAddress;\\n    }\\n\\n    struct BorrowData {\\n        uint256 drawDownNumber;\\n        uint256 totalDebt;\\n        mapping(uint256 => DrawDown) drawDowns;\\n        mapping(uint256 => Repayment) repayments;\\n    }\\n\\n    struct DrawDown {\\n        uint256 amount;\\n        uint256 tenure;\\n        uint40 timestamp;\\n        uint256 borrowRate;\\n        Repayment repayment;\\n    }\\n\\n    struct Repayment {\\n        uint256 totalPaid;\\n        // tenure => amount\\n        // todo wrapper this in the future\\n        mapping(uint256 => uint256) repayment;\\n    }\\n\\n    // tmp struct to avoid stack too long\\n\\n    struct DepositAndDebt {\\n        uint256 juniorDepositAmount;\\n        uint256 seniorDepositAmount;\\n        uint256 totalDebt;\\n        uint256 avgStableRate;\\n    }\\n\\n    struct HealthRiskParameter {\\n        uint256 securityDeposit;\\n        uint256 currentBorrowRate;\\n        uint256 compoundedDebt;\\n        uint256 grossAssetValue;\\n        uint256 aggregateOptimalRepaymentRate;\\n        uint256 aggregateActualRepaymentRate;\\n    }\\n\\n    struct PoolConfiguration {\\n        uint256 securityRequirement;\\n        uint256 minSecurity;\\n        uint256 maxSecurity;\\n        uint256 loanTenure;\\n        uint256 optimalTrancheRatio;\\n        uint256 optimalIncomeRatio;\\n        bool isActive;\\n    }\\n\\n    struct PoolData {\\n        uint256 totalLiquidity;\\n        uint256 juniorLiquidity;\\n        uint256 seniorLiquidity;\\n        uint256 juniorLiquidityRate;\\n        uint256 seniorLiquidityRate;\\n        uint256 totalDebt;\\n        uint256 borrowRate;\\n        uint256 trancheRatio;\\n        uint256 decimals;\\n    }\\n\\n    struct VaultData {\\n        uint256 borrowRate;\\n        uint256 totalDebt;\\n        uint256 totalSecurityDeposit;\\n        uint256 withdrawableSecurityDeposit;\\n        uint256 creditLimit;\\n        uint256 spendableBalance;\\n        uint256 gav;\\n        uint256 ltv;\\n        uint256 optimalAggregateRepaymentRate;\\n        uint256 actualAggregateRepaymentRate;\\n        uint256 healthFactor;\\n    }\\n\\n    struct UserPoolData {\\n        uint256 juniorTrancheBalance;\\n        uint256 withdrawableJuniorTrancheBalance;\\n        uint256 seniorTrancheBalance;\\n        uint256 withdrawableSeniorTrancheBalance;\\n        uint256 decimals;\\n    }\\n}\\n\",\"keccak256\":\"0xcec2078b66d3b8700a51b1c19338d41d13b46a118ccd45f2bb94072086ca01d1\",\"license\":\"GPL-3.0\"},\"contracts/tokenization/BaseERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\\nimport 'openzeppelin-solidity/contracts/utils/Context.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract BaseERC20 is Context, IERC20, IERC20Metadata {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    uint256 internal _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 _decimals\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = _decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @return The balance of the token\\n     **/\\n    function balanceOf(address account)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(\\n            currentAllowance >= amount,\\n            'ERC20: transfer amount exceeds allowance'\\n        );\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(\\n            currentAllowance >= subtractedValue,\\n            'ERC20: decreased allowance below zero'\\n        );\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), 'ERC20: transfer from the zero address');\\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(\\n            senderBalance >= amount,\\n            'ERC20: transfer amount exceeds balance'\\n        );\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), 'ERC20: mint to the zero address');\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        uint256 oldTotalSupply = _totalSupply;\\n        _totalSupply = oldTotalSupply.add(amount);\\n\\n        uint256 oldAccountBalance = _balances[account];\\n        _balances[account] = oldAccountBalance.add(amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), 'ERC20: burn from the zero address');\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 oldTotalSupply = _totalSupply;\\n        _totalSupply = oldTotalSupply.sub(amount);\\n\\n        uint256 oldAccountBalance = _balances[account];\\n        _balances[account] = oldAccountBalance.sub(\\n            amount,\\n            'ERC20: burn amount exceeds balance'\\n        );\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), 'ERC20: approve from the zero address');\\n        require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _setName(string memory newName) internal {\\n        _name = newName;\\n    }\\n\\n    function _setSymbol(string memory newSymbol) internal {\\n        _symbol = newSymbol;\\n    }\\n\\n    function _setDecimals(uint8 newDecimals) internal {\\n        _decimals = newDecimals;\\n    }\\n}\\n\",\"keccak256\":\"0x2e6345cb5f601dcd27e5792f9363032f8b789f372edfa3caa4a4fdd83916f960\",\"license\":\"MIT\"},\"contracts/tokenization/DebtTokenBase.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport './BaseERC20.sol';\\n\\nabstract contract DebtTokenBase is\\n    BaseERC20('DEBTTOKEN_IMPL', 'DEBTTOKEN_IMPL', 0)\\n{\\n    mapping(address => mapping(address => uint256)) internal _borrowAllowances;\\n\\n    /**\\n     * @dev Being non transferrable, the debt token does not implement any of the\\n     * standard ERC20 functions for transfer and allowance.\\n     **/\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        recipient;\\n        amount;\\n        revert('TRANSFER_NOT_SUPPORTED');\\n    }\\n\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        owner;\\n        spender;\\n        revert('ALLOWANCE_NOT_SUPPORTED');\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        spender;\\n        amount;\\n        revert('APPROVAL_NOT_SUPPORTED');\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        sender;\\n        recipient;\\n        amount;\\n        revert('TRANSFER_NOT_SUPPORTED');\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        spender;\\n        addedValue;\\n        revert('ALLOWANCE_NOT_SUPPORTED');\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        spender;\\n        subtractedValue;\\n        revert('ALLOWANCE_NOT_SUPPORTED');\\n    }\\n\\n    function _getUnderlyingAssetAddress()\\n        internal\\n        view\\n        virtual\\n        returns (address);\\n}\\n\",\"keccak256\":\"0x33907655bfd1387f4637553f76e0d7ce773c4d59cd5e6e6ab560ba55da3d1207\",\"license\":\"GPL-3.0\"},\"contracts/tokenization/IInitializableDepositToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title IDepositToken\\n * @notice Interface for the initialize function on JuniorDepositToken and SeniorDepositToken\\n **/\\nabstract contract IInitializableDepositToken {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    uint256 private lastInitializedRevision = 0;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private initializing;\\n\\n    // user address => timestamp => amount\\n    mapping(address => mapping(uint256 => uint256)) private withdrawals;\\n\\n    // user address => timestamp array\\n    mapping(address => uint256[]) private pendingTimestamp;\\n\\n    uint256 private totalPending;\\n\\n    uint256 private lockupTime = 7 days;\\n\\n    /**\\n     * @dev Modifier to use in the initializer function of a contract.\\n     */\\n    modifier initializer() {\\n        uint256 revision = getRevision();\\n        require(\\n            initializing ||\\n                isConstructor() ||\\n                revision > lastInitializedRevision,\\n            'Contract instance has already been initialized'\\n        );\\n\\n        bool isTopLevelCall = !initializing;\\n        if (isTopLevelCall) {\\n            initializing = true;\\n            lastInitializedRevision = revision;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev returns the revision number of the contract\\n     * Needs to be defined in the inherited class as a constant.\\n     **/\\n    function getRevision() internal pure virtual returns (uint256);\\n\\n    /**\\n     * @dev Emitted when an depositToken is initialized\\n     * @param underlyingAsset The address of the underlying asset\\n     * @param liquidityManagerProxy The address of the associated liquidity manager proxy\\n     * @param tokenDecimals the decimals of the underlying\\n     * @param tokenName the name of the depositToken\\n     * @param tokenSymbol the symbol of the depositToken\\n     * @param params A set of encoded parameters for additional initialization\\n     **/\\n    event Initialized(\\n        address indexed underlyingAsset,\\n        address indexed liquidityManagerProxy,\\n        uint8 tokenDecimals,\\n        string tokenName,\\n        string tokenSymbol,\\n        bytes params\\n    );\\n\\n    /**\\n     * @dev Emitted after the mint action\\n     * @param from The address performing the mint\\n     * @param value The amount being\\n     * @param index The new liquidity index of the reserve\\n     **/\\n    event Mint(address indexed from, uint256 value, uint256 index);\\n\\n    /**\\n     * @dev Emitted after aTokens are burned\\n     * @param from The owner of the aTokens, getting them burned\\n     * @param value The amount being burned\\n     * @param index The new liquidity index of the reserve\\n     **/\\n    event Burn(address indexed from, uint256 value, uint256 index);\\n\\n    /**\\n     * @dev Returns true if the contract has been initialized\\n     **/\\n    function isInitialized() public view returns (bool) {\\n        return !initializing && getRevision() <= lastInitializedRevision;\\n    }\\n\\n    /**\\n     * @dev Returns true if and only if the function is running in the constructor\\n     **/\\n    function isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        uint256 cs;\\n        //solium-disable-next-line\\n        assembly {\\n            cs := extcodesize(address())\\n        }\\n        return cs == 0;\\n    }\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n\\n    function pushWithdraw(address _user, uint256 _amount) internal {\\n        require(withdrawals[_user][block.timestamp] == 0, 'invalid withdraw');\\n        withdrawals[_user][block.timestamp] = _amount;\\n        pendingTimestamp[_user].push(block.timestamp);\\n        totalPending += _amount;\\n    }\\n\\n    function popWithdraw(address _user, uint256 _index)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256[] storage times = pendingTimestamp[_user];\\n        require(_index < times.length, 'invalid index');\\n        uint256 ts = times[_index];\\n        require(block.timestamp - ts > lockupTime, 'cool down error');\\n\\n        uint256 last = times[times.length - 1];\\n        times[_index] = last;\\n        times.pop();\\n\\n        uint256 withdrawable = withdrawals[_user][ts];\\n        delete withdrawals[_user][ts];\\n        totalPending -= withdrawable;\\n        return withdrawable;\\n    }\\n\\n    function pendingWithdrawal(address _user)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return pendingTimestamp[_user];\\n    }\\n\\n    function totalPendingWithdrawal() public view returns (uint256) {\\n        return totalPending;\\n    }\\n\\n    function withdrawalAble(address _user) public view returns (uint256) {\\n        uint256[] storage ts = pendingTimestamp[_user];\\n        uint256 withdrawable = 0;\\n\\n        for (uint256 i = 0; i < ts.length; i++) {\\n            withdrawable += withdrawals[_user][ts[i]];\\n        }\\n        return withdrawable;\\n    }\\n\\n    function lockTime() public view returns (uint256) {\\n        return lockupTime;\\n    }\\n}\\n\",\"keccak256\":\"0xe58a48b8e76ac946dc084695a6a262521eff57693d95370374d8e6a73364f719\",\"license\":\"GPL-3.0\"},\"contracts/tokenization/JuniorDepositToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../contracts/component/liquidity/LiquidityManagerProxy.sol';\\nimport '../libraries/helpers/Errors.sol';\\nimport './IInitializableDepositToken.sol';\\nimport '../interfaces/ILiquidityManagerProxy.sol';\\nimport './BaseERC20.sol';\\nimport 'openzeppelin-solidity/contracts/utils/Context.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '../libraries/math/WadRayMath.sol';\\nimport '../libraries/logic/ReserveLogic.sol';\\nimport '../component/infra/AddressResolver.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\\nimport '../interfaces/IVToken.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract JuniorDepositToken is\\n    Context,\\n    IInitializableDepositToken,\\n    BaseERC20('JuniorDepositToken_IMPL', 'JuniorDepositToken_IMPL', 0),\\n    IVToken\\n{\\n    using WadRayMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    AddressResolver internal addressResolver;\\n    address internal underlyingAsset;\\n\\n    uint256 public constant JUNIOR_DEPOSIT_TOKEN_REVISION = 0x1;\\n\\n    modifier onlyLiquidityManagerProxy() {\\n        require(\\n            _msgSender() == addressResolver.getAddress('liquidityManager'),\\n            Errors.CT_CALLER_MUST_BE_LIQUIDITY_MANAGER_POOL\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the JuniorDepositToken\\n     * @param _addressResolver The address of the AddressResolver\\n     * @param _underlyingAsset The address of the underlying asset of this JuniorDepositToken\\n     * @param _juniorDepositTokenDecimals The decimals of the JuniorDepositToken, same as the underlying asset's\\n     * @param _juniorDepositTokenName The name of the JuniorDepositToken\\n     * @param _juniorDepositTokenSymbol The symbol of the JuniorDepositToken\\n     **/\\n    function initialize(\\n        AddressResolver _addressResolver,\\n        address _underlyingAsset,\\n        uint8 _juniorDepositTokenDecimals,\\n        string calldata _juniorDepositTokenName,\\n        string calldata _juniorDepositTokenSymbol,\\n        bytes calldata _params\\n    ) external initializer {\\n        _setName(_juniorDepositTokenName);\\n        _setSymbol(_juniorDepositTokenSymbol);\\n        _setDecimals(_juniorDepositTokenDecimals);\\n\\n        addressResolver = _addressResolver;\\n        underlyingAsset = _underlyingAsset;\\n\\n        emit Initialized(\\n            _underlyingAsset,\\n            addressResolver.getAddress('liquidityManager'),\\n            _juniorDepositTokenDecimals,\\n            _juniorDepositTokenName,\\n            _juniorDepositTokenSymbol,\\n            _params\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `_amount` junior deposit token to `_user`\\n     * @param _user The address receiving the minted tokens\\n     * @param _amount The amount of tokens getting minted\\n     * @param _index The new liquidity index of the reserve\\n     * @return `true` if the previous balance of the user was 0\\n     **/\\n    function mint(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external onlyLiquidityManagerProxy returns (bool) {\\n        uint256 previousBalance = super.balanceOf(_user);\\n        uint256 amountScaled = _amount.rayDiv(_index);\\n        require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\\n        _mint(_user, amountScaled);\\n        emit Transfer(address(0), _user, _amount);\\n        emit Mint(_user, _amount, _index);\\n\\n        return previousBalance == 0;\\n    }\\n\\n    /**\\n     * @dev Burns JuniorDepositToken from `_user` and sends the equivalent amount of underlying to `_receiverOfUnderlying`\\n     * - Only callable by the LiquidityManagerProxy, as extra state updates there need to the managed\\n     * @param _user The owner of the JuniorDepositToken, getting them burned\\n     * @param _amount The amount being burned\\n     * @param _index The new liquidity index of the reserve\\n     **/\\n    function burn(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external onlyLiquidityManagerProxy {\\n        uint256 amountScaled = _amount.rayDiv(_index);\\n        require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\\n        _burn(_user, amountScaled);\\n\\n        pushWithdraw(_user, _amount);\\n        emit Transfer(_user, address(0), _amount);\\n        emit Burn(_user, _amount, _index);\\n    }\\n\\n    function claim(uint256 _index) external {\\n        uint256 amount = popWithdraw(msg.sender, _index);\\n        require(\\n            IERC20(underlyingAsset).balanceOf(address(this)) >= amount,\\n            'Insufficient liquidity available'\\n        );\\n        IERC20(underlyingAsset).safeTransfer(msg.sender, amount);\\n    }\\n\\n    function transferUnderlyingTo(address _target, uint256 _amount)\\n        external\\n        onlyLiquidityManagerProxy\\n    {\\n        IERC20(underlyingAsset).safeTransfer(_target, _amount);\\n    }\\n\\n    /**\\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the updated\\n     * stored balance divided by the reserve's liquidity index at the moment of the update\\n     * @param _user The user whose balance is calculated\\n     * @return THe scaled balance of the user\\n     **/\\n    function scaledBalanceOf(address _user) external view returns (uint256) {\\n        return super.balanceOf(_user);\\n    }\\n\\n    /**\\n     * @dev Calculates the balance of the user: principal balance + interest generated by the principal\\n     * @param _user The user whose balance is calculated\\n     * @return The balance of the user\\n     **/\\n    function balanceOf(address _user)\\n        public\\n        view\\n        override(BaseERC20)\\n        returns (uint256)\\n    {\\n        ILiquidityManagerProxy liquidityManagerProxy = getLiquidityManagerProxy();\\n        return\\n            super.balanceOf(_user).rayMul(\\n                liquidityManagerProxy.getReserveNormalizedIncome(\\n                    underlyingAsset,\\n                    ReserveLogic.Tranche.JUNIOR\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev calculates the total supply of the specific junior deposit token\\n     * since the balance of every single user increases over time, the totally supply does that too.\\n     * @return the current total supply\\n     **/\\n    function totalSupply() public view override(BaseERC20) returns (uint256) {\\n        uint256 currentSupplyScaled = super.totalSupply();\\n        console.log('currentSupplyScaled:', currentSupplyScaled);\\n        if (currentSupplyScaled == 0) {\\n            return 0;\\n        }\\n        ILiquidityManagerProxy liquidityManagerProxy = getLiquidityManagerProxy();\\n\\n        return\\n            currentSupplyScaled.rayMul(\\n                liquidityManagerProxy.getReserveNormalizedIncome(\\n                    underlyingAsset,\\n                    ReserveLogic.Tranche.JUNIOR\\n                )\\n            );\\n    }\\n\\n    function scaledTotalSupply() public view returns (uint256) {\\n        return super.totalSupply();\\n    }\\n\\n    /**\\n     * @dev Return instance of ILiquidityManagerProxy\\n     **/\\n    function getLiquidityManagerProxy()\\n        internal\\n        view\\n        returns (ILiquidityManagerProxy)\\n    {\\n        address liquidityManagerProxyAddress = addressResolver.getAddress(\\n            'liquidityManagerProxy'\\n        );\\n        return ILiquidityManagerProxy(liquidityManagerProxyAddress);\\n    }\\n\\n    function getRevision() internal pure virtual override returns (uint256) {\\n        return JUNIOR_DEPOSIT_TOKEN_REVISION;\\n    }\\n}\\n\",\"keccak256\":\"0x3ac41ebed94175c719171321a8d5db28d62a9c13d14ee54431af01a75a0feae5\",\"license\":\"GPL-3.0\"},\"contracts/tokenization/SecurityDepositToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\\nimport 'openzeppelin-solidity/contracts/access/AccessControl.sol';\\nimport '../libraries/math/WadRayMath.sol';\\nimport '../component/vault/Vault.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract SecurityDepositToken is ERC20, AccessControl {\\n    using WadRayMath for uint256;\\n    using SafeMath for uint256;\\n\\n    bytes32 public constant VAULT = keccak256('VAULT');\\n\\n    address public underlyingAsset;\\n    uint8 public underlyingAssetDecimals;\\n    Vault public vault;\\n\\n    event MintOnDeposit(address indexed account, uint256 amount);\\n\\n    event BurnOnRedeem(address indexed account, uint256 amount);\\n\\n    constructor(\\n        address _underlyingAsset,\\n        uint8 _underlyingAssetDecimals,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol) {\\n        _setupRole(VAULT, msg.sender);\\n        vault = Vault(msg.sender);\\n        underlyingAsset = _underlyingAsset;\\n        underlyingAssetDecimals = _underlyingAssetDecimals;\\n    }\\n\\n    function mintOnDeposit(address account, uint256 amount)\\n        external\\n        onlyRole(VAULT)\\n    {\\n        _mint(account, amount);\\n        emit MintOnDeposit(account, amount);\\n    }\\n\\n    function burnOnRedeem(address account, uint256 amount)\\n        external\\n        onlyRole(VAULT)\\n    {\\n        _burn(account, amount);\\n        emit BurnOnRedeem(account, amount);\\n    }\\n\\n    function underlyingBalanceOf(address _sponsor)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return vault.underlyingBalance(_sponsor, underlyingAsset);\\n    }\\n}\\n\",\"keccak256\":\"0x7f19982eaa9ebf8bcaddff25ea2c362a518bef4df45af0aaefc23e6e7aa05376\",\"license\":\"GPL-3.0\"},\"contracts/tokenization/SeniorDepositToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../../contracts/component/liquidity/LiquidityManagerProxy.sol';\\nimport '../libraries/helpers/Errors.sol';\\nimport './IInitializableDepositToken.sol';\\nimport '../interfaces/ILiquidityManagerProxy.sol';\\nimport './BaseERC20.sol';\\nimport 'openzeppelin-solidity/contracts/utils/Context.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '../libraries/math/WadRayMath.sol';\\nimport '../libraries/logic/ReserveLogic.sol';\\nimport '../component/infra/AddressResolver.sol';\\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\\nimport '../interfaces/IVToken.sol';\\n\\ncontract SeniorDepositToken is\\n    Context,\\n    IInitializableDepositToken,\\n    BaseERC20('SeniorDepositToken_IMPL', 'SeniorDepositToken_IMPL', 0),\\n    IVToken\\n{\\n    using WadRayMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    AddressResolver internal addressResolver;\\n    address internal underlyingAsset;\\n\\n    uint256 public constant SENIOR_DEPOSIT_TOKEN_REVISION = 0x1;\\n\\n    modifier onlyAdmin() {\\n        require(\\n            _msgSender() == addressResolver.getAddress('liquidityManager') ||\\n                _msgSender() == addressResolver.getAddress('loanManager'),\\n            Errors.CT_CALLER_MUST_BE_LIQUIDITY_MANAGER_POOL\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the JuniorDepositToken\\n     * @param _addressResolver The address of the AddressResolver\\n     * @param _underlyingAsset The address of the underlying asset of this SeniorDepositToken\\n     * @param _seniorDepositTokenDecimals The decimals of the SeniorDepositToken, same as the underlying asset's\\n     * @param _seniorDepositTokenName The name of the SeniorDepositToken\\n     * @param _seniorDepositTokenSymbol The symbol of the SeniorDepositToken\\n     **/\\n    function initialize(\\n        AddressResolver _addressResolver,\\n        address _underlyingAsset,\\n        uint8 _seniorDepositTokenDecimals,\\n        string calldata _seniorDepositTokenName,\\n        string calldata _seniorDepositTokenSymbol,\\n        bytes calldata _params\\n    ) external initializer {\\n        _setName(_seniorDepositTokenName);\\n        _setSymbol(_seniorDepositTokenSymbol);\\n        _setDecimals(_seniorDepositTokenDecimals);\\n\\n        addressResolver = _addressResolver;\\n        underlyingAsset = _underlyingAsset;\\n\\n        emit Initialized(\\n            _underlyingAsset,\\n            addressResolver.getAddress('liquidityManager'),\\n            _seniorDepositTokenDecimals,\\n            _seniorDepositTokenName,\\n            _seniorDepositTokenSymbol,\\n            _params\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `_amount` junior deposit token to `_user`\\n     * @param _user The address receiving the minted tokens\\n     * @param _amount The amount of tokens getting minted\\n     * @param _index The new liquidity index of the reserve\\n     * @return `true` if the previous balance of the user was 0\\n     **/\\n    function mint(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external onlyAdmin returns (bool) {\\n        uint256 previousBalance = super.balanceOf(_user);\\n        uint256 amountScaled = _amount.rayDiv(_index);\\n        require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\\n        _mint(_user, amountScaled);\\n        emit Transfer(address(0), _user, _amount);\\n        emit Mint(_user, _amount, _index);\\n\\n        return previousBalance == 0;\\n    }\\n\\n    /**\\n     * @dev Burns JuniorDepositToken from `_user` and sends the equivalent amount of underlying to `_receiverOfUnderlying`\\n     * - Only callable by the LiquidityManagerProxy, as extra state updates there need to the managed\\n     * @param _user The owner of the JuniorDepositToken, getting them burned\\n     * @param _amount The amount being burned\\n     * @param _index The new liquidity index of the reserve\\n     **/\\n    function burn(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external onlyAdmin {\\n        uint256 amountScaled = _amount.rayDiv(_index);\\n        require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\\n        _burn(_user, amountScaled);\\n        pushWithdraw(_user, _amount);\\n        emit Transfer(_user, address(0), _amount);\\n        emit Burn(_user, _amount, _index);\\n    }\\n\\n    function claim(uint256 _index) external {\\n        uint256 amount = popWithdraw(msg.sender, _index);\\n        require(\\n            IERC20(underlyingAsset).balanceOf(address(this)) >= amount,\\n            'Insufficient liquidity available'\\n        );\\n        IERC20(underlyingAsset).safeTransfer(msg.sender, amount);\\n    }\\n\\n    function transferUnderlyingTo(address _target, uint256 _amount)\\n        external\\n        onlyAdmin\\n    {\\n        IERC20(underlyingAsset).safeTransfer(_target, _amount);\\n    }\\n\\n    /**\\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the updated\\n     * stored balance divided by the reserve's liquidity index at the moment of the update\\n     * @param _user The user whose balance is calculated\\n     * @return THe scaled balance of the user\\n     **/\\n    function scaledBalanceOf(address _user) external view returns (uint256) {\\n        return super.balanceOf(_user);\\n    }\\n\\n    /**\\n     * @dev Calculates the balance of the user: principal balance + interest generated by the principal\\n     * @param _user The user whose balance is calculated\\n     * @return The balance of the user\\n     **/\\n    function balanceOf(address _user)\\n        public\\n        view\\n        override(BaseERC20)\\n        returns (uint256)\\n    {\\n        ILiquidityManagerProxy liquidityManagerProxy = getLiquidityManagerProxy();\\n        return\\n            super.balanceOf(_user).rayMul(\\n                liquidityManagerProxy.getReserveNormalizedIncome(\\n                    underlyingAsset,\\n                    ReserveLogic.Tranche.SENIOR\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev calculates the total supply of the specific junior deposit token\\n     * since the balance of every single user increases over time, the totally supply does that too.\\n     * @return the current total supply\\n     **/\\n    function totalSupply() public view override(BaseERC20) returns (uint256) {\\n        uint256 currentSupplyScaled = super.totalSupply();\\n        if (currentSupplyScaled == 0) {\\n            return 0;\\n        }\\n        ILiquidityManagerProxy liquidityManagerProxy = getLiquidityManagerProxy();\\n\\n        return\\n            currentSupplyScaled.rayMul(\\n                liquidityManagerProxy.getReserveNormalizedIncome(\\n                    underlyingAsset,\\n                    ReserveLogic.Tranche.SENIOR\\n                )\\n            );\\n    }\\n\\n    function scaledTotalSupply() public view returns (uint256) {\\n        return super.totalSupply();\\n    }\\n\\n    /**\\n     * @dev Return instance of ILiquidityManagerProxy\\n     **/\\n    function getLiquidityManagerProxy()\\n        internal\\n        view\\n        returns (ILiquidityManagerProxy)\\n    {\\n        address liquidityManagerProxyAddress = addressResolver.getAddress(\\n            'liquidityManagerProxy'\\n        );\\n        return ILiquidityManagerProxy(liquidityManagerProxyAddress);\\n    }\\n\\n    function getRevision() internal pure virtual override returns (uint256) {\\n        return SENIOR_DEPOSIT_TOKEN_REVISION;\\n    }\\n}\\n\",\"keccak256\":\"0x865264545cd0a5b50da4fa18869c9f31c91d085b4395b64ff8fee9203886c42b\",\"license\":\"GPL-3.0\"},\"contracts/tokenization/StableDebtToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport '../libraries/math/WadRayMath.sol';\\nimport '../libraries/math/MathUtils.sol';\\nimport '../component/infra/AddressResolver.sol';\\nimport './DebtTokenBase.sol';\\nimport '../interfaces/IStableDebtToken.sol';\\nimport '../libraries/types/DataTypes.sol';\\nimport 'openzeppelin-solidity/contracts/utils/math/SafeCast.sol';\\nimport 'openzeppelin-solidity/contracts/utils/Context.sol';\\nimport '../libraries/helpers/Errors.sol';\\nimport '../interfaces/IInitializableDebtToken.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract StableDebtToken is\\n    Context,\\n    IInitializableDebtToken,\\n    IStableDebtToken,\\n    DebtTokenBase\\n{\\n    using WadRayMath for uint256;\\n    using SafeCast for uint256;\\n\\n    modifier onlyLoanManager() {\\n        require(\\n            _msgSender() == addressResolver.getLoanManager(),\\n            Errors.CT_CALLER_MUST_BE_LOAN_MANAGER\\n        );\\n        _;\\n    }\\n\\n    uint256 public constant DEBT_TOKEN_REVISION = 0x1;\\n    uint256 public constant SECONDS_PER_DAY = 1 days;\\n\\n    uint256 internal _avgStableRate;\\n    mapping(address => uint256) internal _usersStableRate;\\n    uint40 internal _totalSupplyTimestamp;\\n    mapping(address => DataTypes.BorrowData) internal _borrowData;\\n\\n    AddressResolver internal addressResolver;\\n    address internal underlyingAsset;\\n\\n    function initialize(\\n        address _underlyingAsset,\\n        uint8 _debtTokenDecimals,\\n        string memory _debtTokenName,\\n        string memory _debtTokenSymbol,\\n        address _addressResolver,\\n        bytes calldata _params\\n    ) external initializer {\\n        _setName(_debtTokenName);\\n        _setSymbol(_debtTokenSymbol);\\n        _setDecimals(_debtTokenDecimals);\\n\\n        underlyingAsset = _underlyingAsset;\\n        addressResolver = AddressResolver(_addressResolver);\\n\\n        emit Initialized(\\n            underlyingAsset,\\n            _debtTokenDecimals,\\n            _debtTokenName,\\n            _debtTokenSymbol,\\n            _params\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns the average stable rate\\n     **/\\n    function getAverageStableRate() external view override returns (uint256) {\\n        return _avgStableRate;\\n    }\\n\\n    /**\\n     * @dev Calculate the current user debt principal\\n     **/\\n    function principalOf(address _account) public view returns (uint256) {\\n        DataTypes.BorrowData storage borrowData = _borrowData[_account];\\n        uint256 principal;\\n        for (uint256 i = 0; i < borrowData.drawDownNumber; i++) {\\n            principal += borrowData.drawDowns[i].amount;\\n        }\\n\\n        return principal;\\n    }\\n\\n    /**\\n     * @dev Calculates the current user debt balance\\n     * @return The accumulated debt of the user\\n     **/\\n    function balanceOf(address _account)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        DataTypes.BorrowData storage borrowData = _borrowData[_account];\\n        uint256 cumulatedBalance;\\n        for (uint256 i = 0; i < borrowData.drawDownNumber; i++) {\\n            uint256 stableRate = borrowData.drawDowns[i].borrowRate;\\n            uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\\n                stableRate,\\n                borrowData.drawDowns[i].timestamp\\n            );\\n            cumulatedBalance += borrowData.drawDowns[i].amount.rayMul(\\n                cumulatedInterest\\n            );\\n        }\\n        return cumulatedBalance;\\n    }\\n\\n    function _mint(address _account) internal {\\n        DataTypes.BorrowData storage borrowData = _borrowData[_account];\\n        for (uint256 i = 0; i < borrowData.drawDownNumber; i++) {\\n            DataTypes.DrawDown storage drawDown = borrowData.drawDowns[i];\\n            uint256 stableRate = drawDown.borrowRate;\\n            uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\\n                stableRate,\\n                drawDown.timestamp\\n            );\\n            drawDown.amount = drawDown.amount.rayMul(cumulatedInterest);\\n            drawDown.timestamp = uint40(block.timestamp);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the the total supply and the average stable rate\\n     **/\\n    function getTotalSupplyAndAvgRate()\\n        public\\n        view\\n        override\\n        returns (uint256, uint256)\\n    {\\n        uint256 avgRate = _avgStableRate;\\n        return (_calcTotalSupply(avgRate), avgRate);\\n    }\\n\\n    /**\\n     * @dev Calculates the total supply\\n     * @param avgRate The average rate at which the total supply increases\\n     * @return The debt balance of the user since the last burn/mint action\\n     **/\\n    function _calcTotalSupply(uint256 avgRate)\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        uint256 principalSupply = super.totalSupply();\\n\\n        if (principalSupply == 0) {\\n            return 0;\\n        }\\n\\n        uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\\n            avgRate,\\n            _totalSupplyTimestamp\\n        );\\n\\n        return principalSupply.rayMul(cumulatedInterest);\\n    }\\n\\n    function _getUnderlyingAssetAddress()\\n        internal\\n        view\\n        override\\n        returns (address)\\n    {\\n        return underlyingAsset;\\n    }\\n\\n    function getRevision() internal pure virtual override returns (uint256) {\\n        return DEBT_TOKEN_REVISION;\\n    }\\n\\n    function getAggregateOptimalRepaymentRate(address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        DataTypes.BorrowData storage bd = _borrowData[_user];\\n        uint256 stableRate = _usersStableRate[_user];\\n        uint256 aggregateOptimalRepaymentRate;\\n        for (uint256 i = 0; i < bd.drawDownNumber; i++) {\\n            DataTypes.DrawDown storage drawDone = bd.drawDowns[i];\\n            uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\\n                stableRate,\\n                drawDone.timestamp\\n            );\\n            uint256 remainingBalance = drawDone.amount -\\n                drawDone.repayment.totalPaid;\\n            uint256 cumulatedBalance = remainingBalance.rayMul(\\n                cumulatedInterest\\n            );\\n            aggregateOptimalRepaymentRate += cumulatedBalance.rayDiv(\\n                drawDone.tenure.rayMul(SECONDS_PER_DAY * WadRayMath.ray())\\n            );\\n        }\\n        return aggregateOptimalRepaymentRate;\\n    }\\n\\n    function getAggregateActualRepaymentRate(address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        DataTypes.BorrowData storage bd = _borrowData[_user];\\n        uint256 aggregateActualRepayment;\\n        for (uint256 i = 0; i < bd.drawDownNumber; i++) {\\n            DataTypes.DrawDown storage drawDone = bd.drawDowns[i];\\n            DataTypes.Repayment storage repayment = drawDone.repayment;\\n            if (\\n                repayment.totalPaid != 0 && block.timestamp > drawDone.timestamp\\n            ) {\\n                aggregateActualRepayment += repayment.totalPaid.rayDiv(\\n                    (block.timestamp - drawDone.timestamp) * WadRayMath.ray()\\n                );\\n            }\\n        }\\n        return aggregateActualRepayment;\\n    }\\n\\n    struct MintLocalVars {\\n        uint256 previousSupply;\\n        uint256 nextSupply;\\n        uint256 amountInRay;\\n        uint256 currentStableRate;\\n        uint256 nextStableRate;\\n        uint256 currentAvgStableRate;\\n    }\\n\\n    function mint(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _tenure,\\n        uint256 _rate\\n    ) external override onlyLoanManager {\\n        MintLocalVars memory vars;\\n\\n        (\\n            ,\\n            uint256 currentBalance,\\n            uint256 balanceIncrease\\n        ) = _calculateBalanceIncrease(_user);\\n\\n        vars.previousSupply = totalSupply();\\n        vars.currentAvgStableRate = _avgStableRate;\\n        vars.nextSupply = _totalSupply = vars.previousSupply + _amount;\\n\\n        vars.amountInRay = _amount.wadToRay();\\n        vars.currentStableRate = _usersStableRate[_user];\\n\\n        DataTypes.BorrowData storage bd = _borrowData[_user];\\n        uint256 currentDrawDownNumber = bd.drawDownNumber;\\n        bd.drawDowns[currentDrawDownNumber].amount = _amount;\\n        bd.drawDowns[currentDrawDownNumber].tenure = _tenure;\\n        bd.drawDowns[currentDrawDownNumber].borrowRate = _rate;\\n        bd.drawDowns[currentDrawDownNumber].timestamp = uint40(block.timestamp);\\n        bd.drawDownNumber++;\\n\\n        vars.nextStableRate = (vars.currentStableRate.rayMul(\\n            currentBalance.wadToRay()\\n        ) + vars.amountInRay.rayMul(_rate)).rayDiv(\\n                (currentBalance + _amount).wadToRay()\\n            );\\n\\n        _usersStableRate[_user] = vars.nextStableRate.toUint128();\\n\\n        _totalSupplyTimestamp = uint40(block.timestamp);\\n\\n        // Calculates the updated average stable rate\\n        vars.currentAvgStableRate = _avgStableRate = (\\n            (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +\\n                _rate.rayMul(vars.amountInRay)).rayDiv(\\n                    vars.nextSupply.wadToRay()\\n                )\\n        ).toUint128();\\n        _mint(_user);\\n        emit Mint(\\n            _user,\\n            _amount,\\n            currentBalance,\\n            balanceIncrease,\\n            vars.nextStableRate,\\n            vars.currentAvgStableRate,\\n            vars.nextSupply\\n        );\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _calcTotalSupply(_avgStableRate);\\n    }\\n\\n    function getTotalSupplyLastUpdated() external view returns (uint40) {\\n        return _totalSupplyTimestamp;\\n    }\\n\\n    function underlyingAssetAddress() external view returns (address) {\\n        return underlyingAsset;\\n    }\\n\\n    /**\\n     * @dev Calculates the increase in balance since the last user interaction\\n     * @param _user The address of the user for which the\\n     * @return The previous principal balance\\n     * @return The new principal balance\\n     * @return The balance increase\\n     **/\\n    function _calculateBalanceIncrease(address _user)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 principal = principalOf(_user);\\n        if (principal == 0) {\\n            return (0, 0, 0);\\n        }\\n\\n        uint256 newPrincipalBalance = balanceOf(_user);\\n        return (\\n            principal,\\n            newPrincipalBalance,\\n            newPrincipalBalance - principal\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xbab7c3e1772a60107732102efac5cd20f638fa02801c65461a3644e4d547f61a\",\"license\":\"GPL-3.0\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/access/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4a1a0ba12bf1a33f10d9fe226278cf59675c0b929d29e4da99658a079b27fb84\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x0e9621f60b2faabe65549f7ed0f24e8853a45c1b7990d47e8160e523683f3935\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xdadd41acb749920eccf40aeaa8d291adf9751399a7343561bad13e7a8d99be0b\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbbc8ac883ac3c0078ce5ad3e288fbb3ffcc8a30c3a98c0fda0114d64fc44fca2\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address) {\\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\\n        return address(uint160(uint256(_data)));\\n    }\\n}\\n\",\"keccak256\":\"0xebe3f8a59f0f1c96344a05edb984ef666ee4207e993cca99af3808f1de8771b5\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x5c6caab697d302ad7eb59c234a4d2dbc965c1bae87709bd2850060b7695b28c7\",\"license\":\"MIT\"},\"openzeppelin-solidity/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa2f576be637946f767aa56601c26d717f48a0aff44f82e46f13807eea1009a21\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040526000805562093a806005553480156200001c57600080fd5b5060408051808201825260178082527f53656e696f724465706f736974546f6b656e5f494d504c0000000000000000006020808401828152855180870190965292855284015281519192916000916200007991603b919062000099565b5081516200008f90603c90602085019062000099565b505050506200017c565b828054620000a7906200013f565b90600052602060002090601f016020900481019282620000cb576000855562000116565b82601f10620000e657805160ff191683800117855562000116565b8280016001018555821562000116579182015b8281111562000116578251825591602001919060010190620000f9565b506200012492915062000128565b5090565b5b8082111562000124576000815560010162000129565b600181811c908216806200015457607f821691505b602082108114156200017657634e487b7160e01b600052602260045260246000fd5b50919050565b612551806200018c6000396000f3fe608060405234801561001057600080fd5b50600436106101985760003560e01c806339509351116100e3578063a457c2d71161008c578063d41e972011610066578063d41e972014610320578063dd62ed3e14610328578063f5298aca1461036157600080fd5b8063a457c2d7146102f2578063a9059cbb14610305578063b1bf962d1461031857600080fd5b806370a08231116100bd57806370a08231146102c45780637fdd585f146102d757806395d89b41146102ea57600080fd5b8063395093511461028b5780634efecaa51461029e57806352801efd146102b157600080fd5b80631da24f3e11610145578063313ce5671161011f578063313ce56714610259578063379607f51461026e578063392e53cd1461028357600080fd5b80631da24f3e1461022b57806323b872dd1461023e5780632545d68a1461025157600080fd5b80630d668087116101765780630d668087146101fe578063156e29f61461021057806318160ddd1461022357600080fd5b806306fdde031461019d578063095ea7b3146101bb5780630964c95b146101de575b600080fd5b6101a5610374565b6040516101b29190612001565b60405180910390f35b6101ce6101c936600461204c565b610406565b60405190151581526020016101b2565b6101f16101ec366004612078565b61041c565b6040516101b29190612095565b6005545b6040519081526020016101b2565b6101ce61021e3660046120d9565b610488565b61020261074f565b610202610239366004612078565b610827565b6101ce61024c36600461210e565b610847565b610202600181565b603d5460405160ff90911681526020016101b2565b61028161027c36600461214f565b610906565b005b6101ce610a14565b6101ce61029936600461204c565b610a32565b6102816102ac36600461204c565b610a6e565b6102026102bf366004612078565b610c2c565b6102026102d2366004612078565b610cc0565b6102816102e53660046121b1565b610d8f565b6101a5611038565b6101ce61030036600461204c565b611047565b6101ce61031336600461204c565b6110f8565b610202611105565b600454610202565b61020261033636600461228b565b6001600160a01b03918216600090815260396020908152604080832093909416825291909152205490565b61028161036f3660046120d9565b611110565b6060603b8054610383906122c4565b80601f01602080910402602001604051908101604052809291908181526020018280546103af906122c4565b80156103fc5780601f106103d1576101008083540402835291602001916103fc565b820191906000526020600020905b8154815290600101906020018083116103df57829003601f168201915b5050505050905090565b60006104133384846113b8565b50600192915050565b6001600160a01b03811660009081526003602090815260409182902080548351818402810184019094528084526060939283018282801561047c57602002820191906000526020600020905b815481526020019060010190808311610468575b50505050509050919050565b603d546040516321f8a72160e01b81527f6c69717569646974794d616e6167657200000000000000000000000000000000600482015260009161010090046001600160a01b0316906321f8a7219060240160206040518083038186803b1580156104f157600080fd5b505afa158015610505573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061052991906122ff565b6001600160a01b0316336001600160a01b031614806105f75750603d546040516321f8a72160e01b81527f6c6f616e4d616e6167657200000000000000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b1580156105aa57600080fd5b505afa1580156105be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105e291906122ff565b6001600160a01b0316336001600160a01b0316145b60405180604001604052806002815260200161032360f41b815250906106395760405162461bcd60e51b81526004016106309190612001565b60405180910390fd5b506001600160a01b0384166000908152603860205260408120549061065e8585611510565b60408051808201909152600281527f32310000000000000000000000000000000000000000000000000000000000006020820152909150816106b35760405162461bcd60e51b81526004016106309190612001565b506106be8682611552565b6040518581526001600160a01b038716906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060200160405180910390a360408051868152602081018690526001600160a01b038816917f4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f910160405180910390a2501590505b9392505050565b60008061075b603a5490565b90508061076a57600091505090565b60006107746115fd565b603e546040517f776f6891000000000000000000000000000000000000000000000000000000008152919250610820916001600160a01b038085169263776f6891926107c9929091169060019060040161231c565b60206040518083038186803b1580156107e157600080fd5b505afa1580156107f5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108199190612357565b83906116a1565b9250505090565b6001600160a01b0381166000908152603860205260408120545b92915050565b60006108548484846116dd565b6001600160a01b0384166000908152603960209081526040808320338452909152902054828110156108ee5760405162461bcd60e51b815260206004820152602860248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206160448201527f6c6c6f77616e63650000000000000000000000000000000000000000000000006064820152608401610630565b6108fb85338584036113b8565b506001949350505050565b600061091233836118f6565b603e546040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015291925082916001600160a01b03909116906370a082319060240160206040518083038186803b15801561097357600080fd5b505afa158015610987573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109ab9190612357565b10156109f95760405162461bcd60e51b815260206004820181905260248201527f496e73756666696369656e74206c697175696469747920617661696c61626c656044820152606401610630565b603e54610a10906001600160a01b03163383611a9d565b5050565b60015460009060ff16158015610a2d5750600054600111155b905090565b3360008181526039602090815260408083206001600160a01b03871684529091528120549091610413918590610a69908690612386565b6113b8565b603d546040516321f8a72160e01b81527f6c69717569646974794d616e616765720000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b158015610ad557600080fd5b505afa158015610ae9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0d91906122ff565b6001600160a01b0316336001600160a01b03161480610bdb5750603d546040516321f8a72160e01b81527f6c6f616e4d616e6167657200000000000000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b158015610b8e57600080fd5b505afa158015610ba2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bc691906122ff565b6001600160a01b0316336001600160a01b0316145b60405180604001604052806002815260200161032360f41b81525090610c145760405162461bcd60e51b81526004016106309190612001565b50603e54610a10906001600160a01b03168383611a9d565b6001600160a01b038116600090815260036020526040812081805b8254811015610cb8576001600160a01b03851660009081526002602052604081208454909190859084908110610c7f57610c7f61239e565b906000526020600020015481526020019081526020016000205482610ca49190612386565b915080610cb0816123b4565b915050610c47565b509392505050565b600080610ccb6115fd565b603e546040517f776f6891000000000000000000000000000000000000000000000000000000008152919250610748916001600160a01b038085169263776f689192610d20929091169060019060040161231c565b60206040518083038186803b158015610d3857600080fd5b505afa158015610d4c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d709190612357565b6001600160a01b038516600090815260386020526040902054906116a1565b6001805460ff1680610da05750303b155b80610dac575060005481115b610e1e5760405162461bcd60e51b815260206004820152602e60248201527f436f6e747261637420696e7374616e63652068617320616c726561647920626560448201527f656e20696e697469616c697a65640000000000000000000000000000000000006064820152608401610630565b60015460ff16158015610e3d576001805460ff19168117905560008290555b610e7c88888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611b2292505050565b610ebb86868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611b3592505050565b603d805460ff191660ff8b16179055603d80547fffffffffffffffffffffff0000000000000000000000000000000000000000ff166101006001600160a01b038e811682029290921792839055603e80547fffffffffffffffffffffffff0000000000000000000000000000000000000000168e84161790556040516321f8a72160e01b81527f6c69717569646974794d616e61676572000000000000000000000000000000006004820152920416906321f8a7219060240160206040518083038186803b158015610f8c57600080fd5b505afa158015610fa0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc491906122ff565b6001600160a01b03168a6001600160a01b03167f5d8ce3e947367e84e7fa4f4ba36ebe75e6b6c6b93c25673faa4df0202b59c1388b8b8b8b8b8b8b60405161101297969594939291906123fa565b60405180910390a3801561102b576001805460ff191690555b5050505050505050505050565b6060603c8054610383906122c4565b3360009081526039602090815260408083206001600160a01b0386168452909152812054828110156110e15760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760448201527f207a65726f0000000000000000000000000000000000000000000000000000006064820152608401610630565b6110ee33858584036113b8565b5060019392505050565b60006104133384846116dd565b6000610a2d603a5490565b603d546040516321f8a72160e01b81527f6c69717569646974794d616e616765720000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b15801561117757600080fd5b505afa15801561118b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111af91906122ff565b6001600160a01b0316336001600160a01b0316148061127d5750603d546040516321f8a72160e01b81527f6c6f616e4d616e6167657200000000000000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b15801561123057600080fd5b505afa158015611244573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061126891906122ff565b6001600160a01b0316336001600160a01b0316145b60405180604001604052806002815260200161032360f41b815250906112b65760405162461bcd60e51b81526004016106309190612001565b5060006112c38383611510565b60408051808201909152600281527f32320000000000000000000000000000000000000000000000000000000000006020820152909150816113185760405162461bcd60e51b81526004016106309190612001565b506113238482611b48565b61132d8484611c17565b6040518381526000906001600160a01b038616907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060200160405180910390a360408051848152602081018490526001600160a01b038616917f49995e5dd6158cf69ad3e9777c46755a1a826a446c6416992167462dad033b2a910160405180910390a250505050565b6001600160a01b0383166114335760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460448201527f72657373000000000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b0382166114af5760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f20616464726560448201527f73730000000000000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b0383811660008181526039602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b60008061151e60028461244d565b905061154a8361154461153d876b033b2e3c9fd0803ce8000000611ce7565b8490611cf3565b90611cff565b949350505050565b6001600160a01b0382166115a85760405162461bcd60e51b815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f2061646472657373006044820152606401610630565b603a546115b58183611cf3565b603a556001600160a01b0383166000908152603860205260409020546115db8184611cf3565b6001600160a01b03909416600090815260386020526040902093909355505050565b603d546040516321f8a72160e01b81527f6c69717569646974794d616e6167657250726f78790000000000000000000000600482015260009182916101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b15801561166957600080fd5b505afa15801561167d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061084191906122ff565b60006107486b033b2e3c9fd0803ce80000006115446116c08686611ce7565b6116d760026b033b2e3c9fd0803ce800000061244d565b90611cf3565b6001600160a01b0383166117595760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b0382166117d55760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201527f65737300000000000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b038316600090815260386020526040902054818110156118645760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206260448201527f616c616e636500000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b0380851660009081526038602052604080822085850390559185168152908120805484929061189b908490612386565b92505081905550826001600160a01b0316846001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516118e791815260200190565b60405180910390a35b50505050565b6001600160a01b03821660009081526003602052604081208054831061195e5760405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420696e646578000000000000000000000000000000000000006044820152606401610630565b60008184815481106119725761197261239e565b90600052602060002001549050600554814261198e919061246f565b116119db5760405162461bcd60e51b815260206004820152600f60248201527f636f6f6c20646f776e206572726f7200000000000000000000000000000000006044820152606401610630565b815460009083906119ee9060019061246f565b815481106119fe576119fe61239e565b9060005260206000200154905080838681548110611a1e57611a1e61239e565b906000526020600020018190555082805480611a3c57611a3c612486565b6000828152602080822060001990840181018390559092019092556001600160a01b038816825260028152604080832085845290915281208054908290556004805491928392611a8d90849061246f565b9091555090979650505050505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb00000000000000000000000000000000000000000000000000000000179052611b1d908490611d0b565b505050565b8051610a1090603b906020840190611f3c565b8051610a1090603c906020840190611f3c565b6001600160a01b038216611bc45760405162461bcd60e51b815260206004820152602160248201527f45524332303a206275726e2066726f6d20746865207a65726f2061646472657360448201527f73000000000000000000000000000000000000000000000000000000000000006064820152608401610630565b603a54611bd18183611df0565b603a556001600160a01b03831660009081526038602090815260409182902054825160608101909352602280845290926115db928692906124fa90830139839190611dfc565b6001600160a01b038216600090815260026020908152604080832042845290915290205415611c885760405162461bcd60e51b815260206004820152601060248201527f696e76616c6964207769746864726177000000000000000000000000000000006044820152606401610630565b6001600160a01b0382166000818152600260209081526040808320428085529083528184208690559383526003825282208054600181018255908352908220019190915560048054839290611cde908490612386565b90915550505050565b6000610748828461249c565b60006107488284612386565b6000610748828461244d565b6000611d60826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611e289092919063ffffffff16565b805190915015611b1d5780806020019051810190611d7e91906124bb565b611b1d5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401610630565b6000610748828461246f565b60008184841115611e205760405162461bcd60e51b81526004016106309190612001565b505050900390565b606061154a8484600085856001600160a01b0385163b611e8a5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610630565b600080866001600160a01b03168587604051611ea691906124dd565b60006040518083038185875af1925050503d8060008114611ee3576040519150601f19603f3d011682016040523d82523d6000602084013e611ee8565b606091505b5091509150611ef8828286611f03565b979650505050505050565b60608315611f12575081610748565b825115611f225782518084602001fd5b8160405162461bcd60e51b81526004016106309190612001565b828054611f48906122c4565b90600052602060002090601f016020900481019282611f6a5760008555611fb0565b82601f10611f8357805160ff1916838001178555611fb0565b82800160010185558215611fb0579182015b82811115611fb0578251825591602001919060010190611f95565b50611fbc929150611fc0565b5090565b5b80821115611fbc5760008155600101611fc1565b60005b83811015611ff0578181015183820152602001611fd8565b838111156118f05750506000910152565b6020815260008251806020840152612020816040850160208701611fd5565b601f01601f19169190910160400192915050565b6001600160a01b038116811461204957600080fd5b50565b6000806040838503121561205f57600080fd5b823561206a81612034565b946020939093013593505050565b60006020828403121561208a57600080fd5b813561074881612034565b6020808252825182820181905260009190848201906040850190845b818110156120cd578351835292840192918401916001016120b1565b50909695505050505050565b6000806000606084860312156120ee57600080fd5b83356120f981612034565b95602085013595506040909401359392505050565b60008060006060848603121561212357600080fd5b833561212e81612034565b9250602084013561213e81612034565b929592945050506040919091013590565b60006020828403121561216157600080fd5b5035919050565b60008083601f84011261217a57600080fd5b50813567ffffffffffffffff81111561219257600080fd5b6020830191508360208285010111156121aa57600080fd5b9250929050565b600080600080600080600080600060c08a8c0312156121cf57600080fd5b89356121da81612034565b985060208a01356121ea81612034565b975060408a013560ff8116811461220057600080fd5b965060608a013567ffffffffffffffff8082111561221d57600080fd5b6122298d838e01612168565b909850965060808c013591508082111561224257600080fd5b61224e8d838e01612168565b909650945060a08c013591508082111561226757600080fd5b506122748c828d01612168565b915080935050809150509295985092959850929598565b6000806040838503121561229e57600080fd5b82356122a981612034565b915060208301356122b981612034565b809150509250929050565b600181811c908216806122d857607f821691505b602082108114156122f957634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561231157600080fd5b815161074881612034565b6001600160a01b0383168152604081016002831061234a57634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b60006020828403121561236957600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b6000821982111561239957612399612370565b500190565b634e487b7160e01b600052603260045260246000fd5b60006000198214156123c8576123c8612370565b5060010190565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b60ff8816815260806020820152600061241760808301888a6123cf565b828103604084015261242a8187896123cf565b9050828103606084015261243f8185876123cf565b9a9950505050505050505050565b60008261246a57634e487b7160e01b600052601260045260246000fd5b500490565b60008282101561248157612481612370565b500390565b634e487b7160e01b600052603160045260246000fd5b60008160001904831182151516156124b6576124b6612370565b500290565b6000602082840312156124cd57600080fd5b8151801515811461074857600080fd5b600082516124ef818460208701611fd5565b919091019291505056fe45524332303a206275726e20616d6f756e7420657863656564732062616c616e6365a26469706673582212208e05fde19fc0eccefc6644863603469b170c7f2847c290317cf180f02eb2db7864736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101985760003560e01c806339509351116100e3578063a457c2d71161008c578063d41e972011610066578063d41e972014610320578063dd62ed3e14610328578063f5298aca1461036157600080fd5b8063a457c2d7146102f2578063a9059cbb14610305578063b1bf962d1461031857600080fd5b806370a08231116100bd57806370a08231146102c45780637fdd585f146102d757806395d89b41146102ea57600080fd5b8063395093511461028b5780634efecaa51461029e57806352801efd146102b157600080fd5b80631da24f3e11610145578063313ce5671161011f578063313ce56714610259578063379607f51461026e578063392e53cd1461028357600080fd5b80631da24f3e1461022b57806323b872dd1461023e5780632545d68a1461025157600080fd5b80630d668087116101765780630d668087146101fe578063156e29f61461021057806318160ddd1461022357600080fd5b806306fdde031461019d578063095ea7b3146101bb5780630964c95b146101de575b600080fd5b6101a5610374565b6040516101b29190612001565b60405180910390f35b6101ce6101c936600461204c565b610406565b60405190151581526020016101b2565b6101f16101ec366004612078565b61041c565b6040516101b29190612095565b6005545b6040519081526020016101b2565b6101ce61021e3660046120d9565b610488565b61020261074f565b610202610239366004612078565b610827565b6101ce61024c36600461210e565b610847565b610202600181565b603d5460405160ff90911681526020016101b2565b61028161027c36600461214f565b610906565b005b6101ce610a14565b6101ce61029936600461204c565b610a32565b6102816102ac36600461204c565b610a6e565b6102026102bf366004612078565b610c2c565b6102026102d2366004612078565b610cc0565b6102816102e53660046121b1565b610d8f565b6101a5611038565b6101ce61030036600461204c565b611047565b6101ce61031336600461204c565b6110f8565b610202611105565b600454610202565b61020261033636600461228b565b6001600160a01b03918216600090815260396020908152604080832093909416825291909152205490565b61028161036f3660046120d9565b611110565b6060603b8054610383906122c4565b80601f01602080910402602001604051908101604052809291908181526020018280546103af906122c4565b80156103fc5780601f106103d1576101008083540402835291602001916103fc565b820191906000526020600020905b8154815290600101906020018083116103df57829003601f168201915b5050505050905090565b60006104133384846113b8565b50600192915050565b6001600160a01b03811660009081526003602090815260409182902080548351818402810184019094528084526060939283018282801561047c57602002820191906000526020600020905b815481526020019060010190808311610468575b50505050509050919050565b603d546040516321f8a72160e01b81527f6c69717569646974794d616e6167657200000000000000000000000000000000600482015260009161010090046001600160a01b0316906321f8a7219060240160206040518083038186803b1580156104f157600080fd5b505afa158015610505573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061052991906122ff565b6001600160a01b0316336001600160a01b031614806105f75750603d546040516321f8a72160e01b81527f6c6f616e4d616e6167657200000000000000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b1580156105aa57600080fd5b505afa1580156105be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105e291906122ff565b6001600160a01b0316336001600160a01b0316145b60405180604001604052806002815260200161032360f41b815250906106395760405162461bcd60e51b81526004016106309190612001565b60405180910390fd5b506001600160a01b0384166000908152603860205260408120549061065e8585611510565b60408051808201909152600281527f32310000000000000000000000000000000000000000000000000000000000006020820152909150816106b35760405162461bcd60e51b81526004016106309190612001565b506106be8682611552565b6040518581526001600160a01b038716906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060200160405180910390a360408051868152602081018690526001600160a01b038816917f4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f910160405180910390a2501590505b9392505050565b60008061075b603a5490565b90508061076a57600091505090565b60006107746115fd565b603e546040517f776f6891000000000000000000000000000000000000000000000000000000008152919250610820916001600160a01b038085169263776f6891926107c9929091169060019060040161231c565b60206040518083038186803b1580156107e157600080fd5b505afa1580156107f5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108199190612357565b83906116a1565b9250505090565b6001600160a01b0381166000908152603860205260408120545b92915050565b60006108548484846116dd565b6001600160a01b0384166000908152603960209081526040808320338452909152902054828110156108ee5760405162461bcd60e51b815260206004820152602860248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206160448201527f6c6c6f77616e63650000000000000000000000000000000000000000000000006064820152608401610630565b6108fb85338584036113b8565b506001949350505050565b600061091233836118f6565b603e546040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015291925082916001600160a01b03909116906370a082319060240160206040518083038186803b15801561097357600080fd5b505afa158015610987573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109ab9190612357565b10156109f95760405162461bcd60e51b815260206004820181905260248201527f496e73756666696369656e74206c697175696469747920617661696c61626c656044820152606401610630565b603e54610a10906001600160a01b03163383611a9d565b5050565b60015460009060ff16158015610a2d5750600054600111155b905090565b3360008181526039602090815260408083206001600160a01b03871684529091528120549091610413918590610a69908690612386565b6113b8565b603d546040516321f8a72160e01b81527f6c69717569646974794d616e616765720000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b158015610ad557600080fd5b505afa158015610ae9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0d91906122ff565b6001600160a01b0316336001600160a01b03161480610bdb5750603d546040516321f8a72160e01b81527f6c6f616e4d616e6167657200000000000000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b158015610b8e57600080fd5b505afa158015610ba2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bc691906122ff565b6001600160a01b0316336001600160a01b0316145b60405180604001604052806002815260200161032360f41b81525090610c145760405162461bcd60e51b81526004016106309190612001565b50603e54610a10906001600160a01b03168383611a9d565b6001600160a01b038116600090815260036020526040812081805b8254811015610cb8576001600160a01b03851660009081526002602052604081208454909190859084908110610c7f57610c7f61239e565b906000526020600020015481526020019081526020016000205482610ca49190612386565b915080610cb0816123b4565b915050610c47565b509392505050565b600080610ccb6115fd565b603e546040517f776f6891000000000000000000000000000000000000000000000000000000008152919250610748916001600160a01b038085169263776f689192610d20929091169060019060040161231c565b60206040518083038186803b158015610d3857600080fd5b505afa158015610d4c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d709190612357565b6001600160a01b038516600090815260386020526040902054906116a1565b6001805460ff1680610da05750303b155b80610dac575060005481115b610e1e5760405162461bcd60e51b815260206004820152602e60248201527f436f6e747261637420696e7374616e63652068617320616c726561647920626560448201527f656e20696e697469616c697a65640000000000000000000000000000000000006064820152608401610630565b60015460ff16158015610e3d576001805460ff19168117905560008290555b610e7c88888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611b2292505050565b610ebb86868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611b3592505050565b603d805460ff191660ff8b16179055603d80547fffffffffffffffffffffff0000000000000000000000000000000000000000ff166101006001600160a01b038e811682029290921792839055603e80547fffffffffffffffffffffffff0000000000000000000000000000000000000000168e84161790556040516321f8a72160e01b81527f6c69717569646974794d616e61676572000000000000000000000000000000006004820152920416906321f8a7219060240160206040518083038186803b158015610f8c57600080fd5b505afa158015610fa0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc491906122ff565b6001600160a01b03168a6001600160a01b03167f5d8ce3e947367e84e7fa4f4ba36ebe75e6b6c6b93c25673faa4df0202b59c1388b8b8b8b8b8b8b60405161101297969594939291906123fa565b60405180910390a3801561102b576001805460ff191690555b5050505050505050505050565b6060603c8054610383906122c4565b3360009081526039602090815260408083206001600160a01b0386168452909152812054828110156110e15760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760448201527f207a65726f0000000000000000000000000000000000000000000000000000006064820152608401610630565b6110ee33858584036113b8565b5060019392505050565b60006104133384846116dd565b6000610a2d603a5490565b603d546040516321f8a72160e01b81527f6c69717569646974794d616e616765720000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b15801561117757600080fd5b505afa15801561118b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111af91906122ff565b6001600160a01b0316336001600160a01b0316148061127d5750603d546040516321f8a72160e01b81527f6c6f616e4d616e6167657200000000000000000000000000000000000000000060048201526101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b15801561123057600080fd5b505afa158015611244573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061126891906122ff565b6001600160a01b0316336001600160a01b0316145b60405180604001604052806002815260200161032360f41b815250906112b65760405162461bcd60e51b81526004016106309190612001565b5060006112c38383611510565b60408051808201909152600281527f32320000000000000000000000000000000000000000000000000000000000006020820152909150816113185760405162461bcd60e51b81526004016106309190612001565b506113238482611b48565b61132d8484611c17565b6040518381526000906001600160a01b038616907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060200160405180910390a360408051848152602081018490526001600160a01b038616917f49995e5dd6158cf69ad3e9777c46755a1a826a446c6416992167462dad033b2a910160405180910390a250505050565b6001600160a01b0383166114335760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460448201527f72657373000000000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b0382166114af5760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f20616464726560448201527f73730000000000000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b0383811660008181526039602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b60008061151e60028461244d565b905061154a8361154461153d876b033b2e3c9fd0803ce8000000611ce7565b8490611cf3565b90611cff565b949350505050565b6001600160a01b0382166115a85760405162461bcd60e51b815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f2061646472657373006044820152606401610630565b603a546115b58183611cf3565b603a556001600160a01b0383166000908152603860205260409020546115db8184611cf3565b6001600160a01b03909416600090815260386020526040902093909355505050565b603d546040516321f8a72160e01b81527f6c69717569646974794d616e6167657250726f78790000000000000000000000600482015260009182916101009091046001600160a01b0316906321f8a7219060240160206040518083038186803b15801561166957600080fd5b505afa15801561167d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061084191906122ff565b60006107486b033b2e3c9fd0803ce80000006115446116c08686611ce7565b6116d760026b033b2e3c9fd0803ce800000061244d565b90611cf3565b6001600160a01b0383166117595760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b0382166117d55760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201527f65737300000000000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b038316600090815260386020526040902054818110156118645760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206260448201527f616c616e636500000000000000000000000000000000000000000000000000006064820152608401610630565b6001600160a01b0380851660009081526038602052604080822085850390559185168152908120805484929061189b908490612386565b92505081905550826001600160a01b0316846001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516118e791815260200190565b60405180910390a35b50505050565b6001600160a01b03821660009081526003602052604081208054831061195e5760405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420696e646578000000000000000000000000000000000000006044820152606401610630565b60008184815481106119725761197261239e565b90600052602060002001549050600554814261198e919061246f565b116119db5760405162461bcd60e51b815260206004820152600f60248201527f636f6f6c20646f776e206572726f7200000000000000000000000000000000006044820152606401610630565b815460009083906119ee9060019061246f565b815481106119fe576119fe61239e565b9060005260206000200154905080838681548110611a1e57611a1e61239e565b906000526020600020018190555082805480611a3c57611a3c612486565b6000828152602080822060001990840181018390559092019092556001600160a01b038816825260028152604080832085845290915281208054908290556004805491928392611a8d90849061246f565b9091555090979650505050505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb00000000000000000000000000000000000000000000000000000000179052611b1d908490611d0b565b505050565b8051610a1090603b906020840190611f3c565b8051610a1090603c906020840190611f3c565b6001600160a01b038216611bc45760405162461bcd60e51b815260206004820152602160248201527f45524332303a206275726e2066726f6d20746865207a65726f2061646472657360448201527f73000000000000000000000000000000000000000000000000000000000000006064820152608401610630565b603a54611bd18183611df0565b603a556001600160a01b03831660009081526038602090815260409182902054825160608101909352602280845290926115db928692906124fa90830139839190611dfc565b6001600160a01b038216600090815260026020908152604080832042845290915290205415611c885760405162461bcd60e51b815260206004820152601060248201527f696e76616c6964207769746864726177000000000000000000000000000000006044820152606401610630565b6001600160a01b0382166000818152600260209081526040808320428085529083528184208690559383526003825282208054600181018255908352908220019190915560048054839290611cde908490612386565b90915550505050565b6000610748828461249c565b60006107488284612386565b6000610748828461244d565b6000611d60826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611e289092919063ffffffff16565b805190915015611b1d5780806020019051810190611d7e91906124bb565b611b1d5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401610630565b6000610748828461246f565b60008184841115611e205760405162461bcd60e51b81526004016106309190612001565b505050900390565b606061154a8484600085856001600160a01b0385163b611e8a5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610630565b600080866001600160a01b03168587604051611ea691906124dd565b60006040518083038185875af1925050503d8060008114611ee3576040519150601f19603f3d011682016040523d82523d6000602084013e611ee8565b606091505b5091509150611ef8828286611f03565b979650505050505050565b60608315611f12575081610748565b825115611f225782518084602001fd5b8160405162461bcd60e51b81526004016106309190612001565b828054611f48906122c4565b90600052602060002090601f016020900481019282611f6a5760008555611fb0565b82601f10611f8357805160ff1916838001178555611fb0565b82800160010185558215611fb0579182015b82811115611fb0578251825591602001919060010190611f95565b50611fbc929150611fc0565b5090565b5b80821115611fbc5760008155600101611fc1565b60005b83811015611ff0578181015183820152602001611fd8565b838111156118f05750506000910152565b6020815260008251806020840152612020816040850160208701611fd5565b601f01601f19169190910160400192915050565b6001600160a01b038116811461204957600080fd5b50565b6000806040838503121561205f57600080fd5b823561206a81612034565b946020939093013593505050565b60006020828403121561208a57600080fd5b813561074881612034565b6020808252825182820181905260009190848201906040850190845b818110156120cd578351835292840192918401916001016120b1565b50909695505050505050565b6000806000606084860312156120ee57600080fd5b83356120f981612034565b95602085013595506040909401359392505050565b60008060006060848603121561212357600080fd5b833561212e81612034565b9250602084013561213e81612034565b929592945050506040919091013590565b60006020828403121561216157600080fd5b5035919050565b60008083601f84011261217a57600080fd5b50813567ffffffffffffffff81111561219257600080fd5b6020830191508360208285010111156121aa57600080fd5b9250929050565b600080600080600080600080600060c08a8c0312156121cf57600080fd5b89356121da81612034565b985060208a01356121ea81612034565b975060408a013560ff8116811461220057600080fd5b965060608a013567ffffffffffffffff8082111561221d57600080fd5b6122298d838e01612168565b909850965060808c013591508082111561224257600080fd5b61224e8d838e01612168565b909650945060a08c013591508082111561226757600080fd5b506122748c828d01612168565b915080935050809150509295985092959850929598565b6000806040838503121561229e57600080fd5b82356122a981612034565b915060208301356122b981612034565b809150509250929050565b600181811c908216806122d857607f821691505b602082108114156122f957634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561231157600080fd5b815161074881612034565b6001600160a01b0383168152604081016002831061234a57634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b60006020828403121561236957600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b6000821982111561239957612399612370565b500190565b634e487b7160e01b600052603260045260246000fd5b60006000198214156123c8576123c8612370565b5060010190565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b60ff8816815260806020820152600061241760808301888a6123cf565b828103604084015261242a8187896123cf565b9050828103606084015261243f8185876123cf565b9a9950505050505050505050565b60008261246a57634e487b7160e01b600052601260045260246000fd5b500490565b60008282101561248157612481612370565b500390565b634e487b7160e01b600052603160045260246000fd5b60008160001904831182151516156124b6576124b6612370565b500290565b6000602082840312156124cd57600080fd5b8151801515811461074857600080fd5b600082516124ef818460208701611fd5565b919091019291505056fe45524332303a206275726e20616d6f756e7420657863656564732062616c616e6365a26469706673582212208e05fde19fc0eccefc6644863603469b170c7f2847c290317cf180f02eb2db7864736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "allowance(address,address)": {
        "details": "See {IERC20-allowance}."
      },
      "approve(address,uint256)": {
        "details": "See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."
      },
      "balanceOf(address)": {
        "details": "Calculates the balance of the user: principal balance + interest generated by the principal",
        "params": {
          "_user": "The user whose balance is calculated"
        },
        "returns": {
          "_0": "The balance of the user*"
        }
      },
      "burn(address,uint256,uint256)": {
        "details": "Burns JuniorDepositToken from `_user` and sends the equivalent amount of underlying to `_receiverOfUnderlying` - Only callable by the LiquidityManagerProxy, as extra state updates there need to the managed",
        "params": {
          "_amount": "The amount being burned",
          "_index": "The new liquidity index of the reserve*",
          "_user": "The owner of the JuniorDepositToken, getting them burned"
        }
      },
      "decimals()": {
        "details": "Returns the decimals places of the token."
      },
      "decreaseAllowance(address,uint256)": {
        "details": "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."
      },
      "increaseAllowance(address,uint256)": {
        "details": "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."
      },
      "initialize(address,address,uint8,string,string,bytes)": {
        "details": "Initializes the JuniorDepositToken",
        "params": {
          "_addressResolver": "The address of the AddressResolver",
          "_seniorDepositTokenDecimals": "The decimals of the SeniorDepositToken, same as the underlying asset's",
          "_seniorDepositTokenName": "The name of the SeniorDepositToken",
          "_seniorDepositTokenSymbol": "The symbol of the SeniorDepositToken*",
          "_underlyingAsset": "The address of the underlying asset of this SeniorDepositToken"
        }
      },
      "isInitialized()": {
        "details": "Returns true if the contract has been initialized*"
      },
      "mint(address,uint256,uint256)": {
        "details": "Mints `_amount` junior deposit token to `_user`",
        "params": {
          "_amount": "The amount of tokens getting minted",
          "_index": "The new liquidity index of the reserve",
          "_user": "The address receiving the minted tokens"
        },
        "returns": {
          "_0": "`true` if the previous balance of the user was 0*"
        }
      },
      "name()": {
        "details": "Returns the name of the token."
      },
      "scaledBalanceOf(address)": {
        "details": "Returns the scaled balance of the user. The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index at the moment of the update",
        "params": {
          "_user": "The user whose balance is calculated"
        },
        "returns": {
          "_0": "THe scaled balance of the user*"
        }
      },
      "symbol()": {
        "details": "Returns the symbol of the token, usually a shorter version of the name."
      },
      "totalSupply()": {
        "details": "calculates the total supply of the specific junior deposit token since the balance of every single user increases over time, the totally supply does that too.",
        "returns": {
          "_0": "the current total supply*"
        }
      },
      "transfer(address,uint256)": {
        "details": "See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."
      },
      "transferFrom(address,address,uint256)": {
        "details": "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11965,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "lastInitializedRevision",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 11968,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "initializing",
        "offset": 0,
        "slot": "1",
        "type": "t_bool"
      },
      {
        "astId": 11974,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "withdrawals",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 11979,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "pendingTimestamp",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_array(t_uint256)dyn_storage)"
      },
      {
        "astId": 11981,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "totalPending",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 11984,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "lockupTime",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 12102,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "______gap",
        "offset": 0,
        "slot": "6",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 11273,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "_balances",
        "offset": 0,
        "slot": "56",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11279,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "_allowances",
        "offset": 0,
        "slot": "57",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 11281,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "_totalSupply",
        "offset": 0,
        "slot": "58",
        "type": "t_uint256"
      },
      {
        "astId": 11283,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "_name",
        "offset": 0,
        "slot": "59",
        "type": "t_string_storage"
      },
      {
        "astId": 11285,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "_symbol",
        "offset": 0,
        "slot": "60",
        "type": "t_string_storage"
      },
      {
        "astId": 11287,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "_decimals",
        "offset": 0,
        "slot": "61",
        "type": "t_uint8"
      },
      {
        "astId": 12889,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "addressResolver",
        "offset": 1,
        "slot": "61",
        "type": "t_contract(AddressResolver)1087"
      },
      {
        "astId": 12891,
        "contract": "contracts/tokenization/SeniorDepositToken.sol:SeniorDepositToken",
        "label": "underlyingAsset",
        "offset": 0,
        "slot": "62",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(AddressResolver)1087": {
        "encoding": "inplace",
        "label": "contract AddressResolver",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_array(t_uint256)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint256)dyn_storage"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}