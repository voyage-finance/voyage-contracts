{
  "language": "Solidity",
  "sources": {
    "contracts/component/infra/ACLManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/access/AccessControl.sol';\nimport '../../interfaces/IACLManager.sol';\n\ncontract ACLManager is AccessControl, IACLManager {\n    bytes32 public constant VOYAGER_ADMIN_ROLE = keccak256('VOYAGER_ADMIN');\n\n    bytes32 public constant LIQUIDITY_MANAGER_CONTRACT_ROLE =\n        keccak256('LIQUIDITY_MANAGER_CONTRACT');\n\n    bytes32 public constant LIQUIDITY_MANAGER_ADMIN_ROLE =\n        keccak256('LIQUIDITY_MANAGER_ADMIN');\n\n    bytes32 public constant VAULT_MANAGER_ADMIN_ROLE =\n        keccak256('VAULT_MANAGER_ADMIN');\n\n    bytes32 public constant LOAN_MANAGER_ADMIN_ROLE =\n        keccak256('LOAN_MANAGER_ADMIN');\n\n    bytes32 public constant LOAN_MANAGER_CONTRACT_ROLE =\n        keccak256('LOAN_MANAGER_CONTRACT');\n\n    constructor(address _aclAdmin) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _aclAdmin);\n    }\n\n    function grantLiquidityManagerContract(address _admin) external {\n        grantRole(LIQUIDITY_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function isLiquidityManagerContract(address _admin)\n        external\n        view\n        returns (bool)\n    {\n        return hasRole(LIQUIDITY_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function grantLiquidityManager(address _admin) external {\n        grantRole(LIQUIDITY_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function isLiquidityManager(address _admin) external view returns (bool) {\n        return hasRole(LIQUIDITY_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function grantLoanManagerContract(address _admin) external {\n        grantRole(LOAN_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function isLoanManagerContract(address _admin)\n        external\n        view\n        returns (bool)\n    {\n        return hasRole(LOAN_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function grantLoanManager(address _admin) external {\n        grantRole(LOAN_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function isLoanManager(address _admin) external view returns (bool) {\n        return hasRole(LOAN_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function grantVaultManager(address _admin) external {\n        grantRole(VAULT_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function isVaultManager(address _admin) external view returns (bool) {\n        return hasRole(VAULT_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function grantPoolManager(address _admin) external {\n        grantRole(VOYAGER_ADMIN_ROLE, _admin);\n    }\n\n    function isProtocolManager(address _admin) external view returns (bool) {\n        return hasRole(VOYAGER_ADMIN_ROLE, _admin);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IACLManager {\n    function grantLiquidityManager(address _admin) external;\n\n    function isLiquidityManager(address _admin) external view returns (bool);\n\n    function grantVaultManager(address _admin) external;\n\n    function isVaultManager(address _admin) external view returns (bool);\n\n    function grantPoolManager(address _admin) external;\n\n    function grantLoanManager(address _admin) external;\n\n    function isLoanManager(address _admin) external view returns (bool);\n\n    function isProtocolManager(address _admin) external view returns (bool);\n\n    function grantLiquidityManagerContract(address _admin) external;\n\n    function isLiquidityManagerContract(address _admin)\n        external\n        view\n        returns (bool);\n\n    function grantLoanManagerContract(address _admin) external;\n\n    function isLoanManagerContract(address _admin) external view returns (bool);\n}\n"
    },
    "openzeppelin-solidity/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/component/shared/escrow/LiquidityDepositEscrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../../libraries/Escrow.sol';\nimport 'openzeppelin-solidity/contracts/access/AccessControl.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\nimport '../../Voyager.sol';\nimport '../../../interfaces/IACLManager.sol';\nimport '../../infra/AddressResolver.sol';\n\ncontract LiquidityDepositEscrow is Escrow {\n    Voyager private voyager;\n    bool private initialized;\n\n    modifier onlyLiquidityManager() {\n        _requireCallerLiquidityManagerContract();\n        _;\n    }\n\n    modifier onlyLoanManager() {\n        _requireCallerLoanManagerContract();\n        _;\n    }\n\n    function deposit(\n        address _reserve,\n        address _user,\n        uint256 _amount\n    ) public payable nonReentrant onlyLiquidityManager {\n        _deposit(_reserve, _user, _amount);\n    }\n\n    function init(address _voyager) external {\n        if (!initialized) {\n            voyager = Voyager(_voyager);\n            initialized = true;\n        }\n    }\n\n    function withdraw(\n        address _reserve,\n        address payable _user,\n        uint256 _amount\n    ) public onlyLiquidityManager {\n        _withdraw(_reserve, _user, _amount);\n    }\n\n    function transfer(\n        address _reserve,\n        address payable _user,\n        uint256 _amount\n    ) public onlyLoanManager {\n        IERC20(_reserve).transfer(_user, _amount);\n    }\n\n    function balanceOf(address _reserve) public view returns (uint256) {\n        return IERC20(_reserve).balanceOf(address(this));\n    }\n\n    /************************************** Private Functions **************************************/\n\n    function _requireCallerLiquidityManagerContract() internal {\n        //        Voyager v = Voyager(voyager);\n        AddressResolver addressResolver = voyager.addressResolver();\n        //        IACLManager aclManager = IACLManager(\n        //            v.addressResolver().getAddress(v.getACLManagerName())\n        //        );\n        //        require(\n        //            aclManager.isLiquidityManagerContract(msg.sender),\n        //            'Not liquidity manager contract'\n        //        );\n    }\n\n    function _requireCallerLoanManagerContract() internal {\n        //        Voyager v = Voyager(voyager);\n        //        IACLManager aclManager = IACLManager(\n        //            v.addressResolver().getAddress(v.getACLManagerName())\n        //        );\n        //        require(aclManager.isLoanManagerContract(msg.sender), 'Not liquidity manager contract');\n    }\n}\n"
    },
    "contracts/libraries/Escrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/utils/Address.sol';\nimport 'openzeppelin-solidity/contracts/security/ReentrancyGuard.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport './EthAddressLib.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\n\ncontract Escrow is ReentrancyGuard {\n    using Address for address payable;\n    using SafeERC20 for ERC20;\n\n    struct Deposit {\n        uint256 amount;\n        uint40 depositTime;\n    }\n\n    event Deposited(address indexed payee, address token, uint256 amount);\n    event Withdrawn(address indexed payee, address token, uint256 amount);\n\n    // reserve address => amount\n    mapping(address => uint256) private _deposits;\n    // reserve address => user address => deposit record\n    mapping(address => mapping(address => Deposit[])) private _depositRecords;\n\n    uint40 private _lockupTimeInSeconds = 7 days;\n\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     * @param _reserve the asset address\n     * @param _user user address who deposit to this escrow\n     * @param _amount token amount\n     */\n    function _deposit(\n        address _reserve,\n        address _user,\n        uint256 _amount\n    ) internal {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                'User is sending ETH along with the ERC20 transfer.'\n            );\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n        } else {\n            require(\n                msg.value == _amount,\n                'The amount and the value sent to deposit do not match'\n            );\n        }\n        _deposits[_reserve] += _amount;\n        Deposit memory deposit = Deposit(_amount, uint40(block.timestamp));\n        _depositRecords[_reserve][_user].push(deposit);\n        emit Deposited(_user, _reserve, _amount);\n    }\n\n    function eligibleAmount(address _reserve, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        Deposit[] storage deposits = _depositRecords[_reserve][_user];\n        uint256 eligibleAmount = 0;\n        for (uint256 i = 0; i < deposits.length; i++) {\n            if (\n                uint40(block.timestamp) - deposits[i].depositTime >\n                _lockupTimeInSeconds\n            ) {\n                eligibleAmount += deposits[i].amount;\n            }\n        }\n        return eligibleAmount;\n    }\n\n    /**\n     * @dev Withdraw accumulated balance for a payee, only beyond _lockupTimeInSeconds\n     * @param _reserve the asset address\n     * @param _user user address who deposit to this escrow\n     */\n    function _withdraw(\n        address _reserve,\n        address payable _user,\n        uint256 _amount\n    ) internal {\n        Deposit[] storage deposits = _depositRecords[_reserve][_user];\n        uint256 eligibleAmount = 0;\n        uint40 lastUpdateTime;\n        for (uint256 i = 0; i < deposits.length; i++) {\n            if (\n                uint40(block.timestamp) - deposits[i].depositTime >\n                _lockupTimeInSeconds\n            ) {\n                eligibleAmount += deposits[i].amount;\n                lastUpdateTime = deposits[i].depositTime;\n                delete deposits[i];\n            }\n        }\n\n        require(\n            eligibleAmount >= _amount,\n            'Do not have enough amount to withdraw'\n        );\n\n        // if there is any amount left from eligible amount, push it back\n        if (eligibleAmount > _amount) {\n            uint256 leftAmount = eligibleAmount - _amount;\n            Deposit memory leftDeposit = Deposit(leftAmount, lastUpdateTime);\n            _depositRecords[_reserve][_user].push(leftDeposit);\n        }\n\n        _deposits[_reserve] -= _amount;\n        transferToUser(_reserve, _user, _amount);\n        emit Withdrawn(_user, _reserve, _amount);\n    }\n\n    /**\n     * @dev get accumulated amount of deposit.\n     * @param _reserve the address of the reserve where the transfer is happening\n     * @return accumulated deposit amount\n     **/\n    function getDepositAmount(address _reserve) public view returns (uint256) {\n        return _deposits[_reserve];\n    }\n\n    /**\n     * @dev get all records of deposit.\n     * @param _reserve the address of the reserve where the transfer is happening\n     * @param _user the address of the user receiving the transfer\n     * @return deposit records\n     **/\n    function getDepositRecords(address _reserve, address _user)\n        public\n        view\n        returns (Deposit[] memory)\n    {\n        Deposit[] storage deposits = _depositRecords[_reserve][_user];\n        return deposits;\n    }\n\n    /**\n     * @dev transfers to the user a specific amount from the reserve.\n     * @param _reserve the address of the reserve where the transfer is happening\n     * @param _user the address of the user receiving the transfer\n     * @param _amount the amount being transferred\n     **/\n    function transferToUser(\n        address _reserve,\n        address payable _user,\n        uint256 _amount\n    ) internal {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call{value: _amount}('');\n            require(result, 'Transfer of ETH failed');\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/component/Voyager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/access/AccessControl.sol';\nimport '../libraries/acl/ExtCallACL.sol';\nimport '../libraries/acl/ExtCallACLProxy.sol';\nimport '../libraries/ownership/Ownable.sol';\nimport '../libraries/types/DataTypes.sol';\nimport '../libraries/logic/ReserveLogic.sol';\nimport '../component/infra/AddressResolver.sol';\nimport '../component/vault/VaultManager.sol';\nimport '../component/vault/VaultManagerProxy.sol';\nimport '../component/liquiditymanager/LiquidityManager.sol';\nimport '../interfaces/IACLManager.sol';\nimport './infra/MessageBus.sol';\n\ncontract Voyager is MessageBus {\n    modifier onlyWhitelisted(bytes32 func) {\n        require(\n            ExtCallACL(getExtCallACLProxyAddress()).isWhitelistedAddress(\n                msg.sender\n            ),\n            'Voyager: not whitelisted address'\n        );\n        require(\n            ExtCallACL(getExtCallACLProxyAddress()).isWhitelistedFunction(func),\n            'Voyager: not whitelisted functions'\n        );\n        _;\n    }\n\n    modifier onlyProtocolManager() {\n        _requireCallerAdmin();\n        _;\n    }\n\n    event CallResult(bool, bytes);\n\n    /************************************** HouseKeeping Interfaces **************************************/\n    /**\n     * @dev Update addressResolver contract address\n     * @param _addressResolver address of the resolver contract\n     **/\n    function setAddressResolverAddress(address _addressResolver)\n        external\n        onlyOwner\n    {\n        addressResolver = AddressResolver(_addressResolver);\n    }\n\n    function whitelistAddress(address[] calldata _address)\n        external\n        onlyProtocolManager\n    {\n        ExtCallACL extCallACL = ExtCallACL(getExtCallACLProxyAddress());\n        extCallACL.whitelistAddress(_address);\n    }\n\n    function whitelistFunction(bytes32[] calldata _function)\n        external\n        onlyProtocolManager\n    {\n        ExtCallACL extCallACL = ExtCallACL(getExtCallACLProxyAddress());\n        extCallACL.whitelistFunction(_function);\n    }\n\n    /************************************** Liquidity Manager Interfaces **************************************/\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying tokens: Either\n     * Junior Deposit Token or Senior Deposit token\n     * @param _asset The address of the underlying asset to deposit\n     * @param _tranche The tranche of the liquidity pool the user wants to deposit to\n     * @param _amount The amount to be deposited\n     * @param _onBehalfOf The address that will receive the deposit tokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of deposit token\n     *   is a different wallet\n     **/\n    function deposit(\n        address _asset,\n        ReserveLogic.Tranche _tranche,\n        uint256 _amount,\n        address _onBehalfOf\n    ) external {\n        LiquidityManager(getLiquidityManagerProxyAddress()).deposit(\n            _asset,\n            _tranche,\n            _amount,\n            msg.sender,\n            _onBehalfOf\n        );\n    }\n\n    /**\n     * @dev Returns the normalized income per unit of asset\n     * @param _asset The address of the underlying asset of the reserve\n     * @param _tranche The tranche of the reserve, either Junior or Senior\n     * @return The reserve's normalized income\n     **/\n    function getReserveNormalizedIncome(\n        address _asset,\n        ReserveLogic.Tranche _tranche\n    ) external view returns (uint256) {\n        return\n            LiquidityManager(getLiquidityManagerProxyAddress())\n                .getReserveNormalizedIncome(_asset, _tranche);\n    }\n\n    /**\n     * @dev Returns the reserve flags\n     * @param _asset The address of asset\n     * @return The state flags representing active, frozen, borrowing enabled\n     **/\n    function getReserveFlags(address _asset)\n        external\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        return\n            LiquidityManager(getLiquidityManagerProxyAddress()).getFlags(\n                _asset\n            );\n    }\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param _asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getConfiguration(address _asset)\n        external\n        view\n        returns (DataTypes.ReserveConfigurationMap memory)\n    {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        return\n            LiquidityManager(getLiquidityManagerProxyAddress())\n                .getConfiguration(_asset);\n    }\n\n    /**\n     * @dev Get current liquidity rate for a specific reserve for it junior tranche or senior tranche\n     * @param _asset The address of the underlying asset of the reserve\n     * @param _tranche Either junior tranche or senior tranche\n     **/\n    function liquidityRate(address _asset, ReserveLogic.Tranche _tranche)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            LiquidityManager(getLiquidityManagerProxyAddress())\n                .getLiquidityRate(_asset, _tranche);\n    }\n\n    /**\n     * @dev Get EscrowContract owned by LiquidityManager\n     **/\n    function getLiquidityManagerEscrowContractAddress()\n        external\n        view\n        returns (address)\n    {\n        return\n            LiquidityManager(getLiquidityManagerProxyAddress())\n                .getEscrowAddress();\n    }\n\n    /************************************** Vault Manager Interfaces **************************************/\n\n    /**\n     * @dev Create an empty Vault for msg.sender, in addition to this, a vault also deploy\n     * a SecurityDepositEscrow contract which the fund will be held in\n     × @return address of Vault\n     **/\n    function createVault()\n        external\n        onlyWhitelisted('createVault')\n        returns (address)\n    {\n        address vaultManagerProxy = getVaultManagerProxyAddress();\n        VaultManager vaultManager = VaultManager(vaultManagerProxy);\n        return vaultManager.createVault(msg.sender);\n    }\n\n    /**\n     * @dev Deposit specific amount of security deposit to user owned Vault\n     * @param _vaultUser the user address that will be sponsored\n     * @param _reserve address of reserve\n     * @param _amount deposit amount\n     **/\n    function depositSecurity(\n        address _vaultUser,\n        address _reserve,\n        uint256 _amount\n    ) external onlyWhitelisted('depositSecurity') {\n        VaultManager(getVaultManagerProxyAddress()).depositSecurity(\n            msg.sender,\n            _vaultUser,\n            _reserve,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Get underlying balance of security deposit token\n     * @param _vaultUser _vaultUser the user address that has be sponsored\n     * @param _reserve address of reserve\n     * @param _sponsor sponsor address\n     **/\n    function underlyingBalance(\n        address _vaultUser,\n        address _reserve,\n        address _sponsor\n    ) external view returns (uint256) {\n        return\n            VaultManager(getVaultManagerProxyAddress()).underlyingBalance(\n                _vaultUser,\n                _reserve,\n                _sponsor\n            );\n    }\n\n    /**\n     * @dev Redeem specific amount of security deposit to user owned Vault\n     * @param _vaultUser the user address that has be sponsored\n     * @param _reserve address of reserve\n     * @param _amount deposit amount\n     **/\n    function redeemSecurity(\n        address _vaultUser,\n        address _reserve,\n        uint256 _amount\n    ) external onlyWhitelisted('redeemSecurity') {\n        VaultManager(getVaultManagerProxyAddress()).redeemSecurity(\n            payable(msg.sender),\n            _vaultUser,\n            _reserve,\n            _amount\n        );\n    }\n\n    // todo placeholder functions, more detail should be impl in the future\n    function slash(\n        address _vaultUser,\n        address _reserve,\n        address payable _to,\n        uint256 _amount\n    ) external {\n        VaultManager(getVaultManagerProxyAddress()).slash(\n            _vaultUser,\n            _reserve,\n            _to,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Get maximum reserve amount the use can borrow\n     * @param _user user address\n     * @param _reserve reserve contract address\n     **/\n    function getCreditLimit(address _user, address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            VaultManager(getVaultManagerProxyAddress()).getCreditLimit(\n                _user,\n                _reserve\n            );\n    }\n\n    /**\n     * @dev Get available credit\n     * @param _user user address\n     * @param _reserve address of reserve\n     **/\n    function getAvailableCredit(address _user, address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            VaultManager(getVaultManagerProxyAddress()).getAvailableCredit(\n                _user,\n                _reserve\n            );\n    }\n\n    /**\n     * @dev Eligible amount that can be withdraw, calculated by deposit records without considering slash\n     * @param _vaultUser user address\n     * @param _reserve reserve address\n     * @param _sponsor sponsor address\n     **/\n    function eligibleAmount(\n        address _vaultUser,\n        address _reserve,\n        address _sponsor\n    ) external view returns (uint256) {\n        return\n            VaultManager(getVaultManagerProxyAddress()).eligibleAmount(\n                _vaultUser,\n                _reserve,\n                _sponsor\n            );\n    }\n\n    /************************************** View Interfaces **************************************/\n\n    /**\n     * @dev Get ExtCallACLProxy contract address\n     **/\n    function getExtCallACLProxyAddress() public view returns (address payable) {\n        address extCallACLProxyAddress = AddressResolver(addressResolver)\n            .getAddress(extCallACLProxyName);\n        return payable(extCallACLProxyAddress);\n    }\n\n    /************************************** Internal Interfaces **************************************/\n\n    function _requireCallerAdmin() internal {\n        IACLManager aclManager = IACLManager(\n            addressResolver.getAddress(aclManagerName)\n        );\n        require(aclManager.isProtocolManager(tx.origin), 'Not vault admin');\n    }\n}\n"
    },
    "contracts/component/infra/AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../interfaces/IAddressResolver.sol';\nimport '../../libraries/ownership/Ownable.sol';\n\ncontract AddressResolver is IAddressResolver, Ownable {\n    mapping(bytes32 => address) public repository;\n\n    function importAddresses(\n        bytes32[] calldata names,\n        address[] calldata destinations\n    ) external onlyOwner {\n        require(\n            names.length == destinations.length,\n            'Input lengths must match'\n        );\n\n        for (uint256 i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason)\n        external\n        view\n        returns (address)\n    {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/libraries/EthAddressLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nlibrary EthAddressLib {\n    /**\n     * @dev returns the address used within the protocol to identify ETH\n     * @return the address assigned to ETH\n     */\n    function ethAddress() internal pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/libraries/acl/ExtCallACL.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../proxy/Proxyable.sol';\nimport './IExtCallACL.sol';\n\ncontract ExtCallACL is Proxyable, IExtCallACL {\n    mapping(address => bool) public whitelistedAddress;\n    mapping(bytes32 => bool) public whitelistedFunctions;\n\n    constructor(address payable _proxy) public Proxyable(_proxy) {}\n\n    function whitelistAddress(address[] calldata _address) external onlyProxy {\n        uint256 arrayLength = _address.length;\n        for (uint256 i = 0; i < arrayLength; i++) {\n            whitelistedAddress[_address[i]] = true;\n        }\n    }\n\n    function blockAddress(address[] calldata _address) external onlyProxy {\n        uint256 arrayLength = _address.length;\n        for (uint256 i = 0; i < arrayLength; i++) {\n            delete whitelistedAddress[_address[i]];\n        }\n    }\n\n    function isWhitelistedAddress(address _address)\n        external\n        view\n        returns (bool)\n    {\n        return whitelistedAddress[_address];\n    }\n\n    function whitelistFunction(bytes32[] calldata _func) external onlyProxy {\n        uint256 arrayLength = _func.length;\n        for (uint256 i = 0; i < arrayLength; i++) {\n            whitelistedFunctions[_func[i]] = true;\n        }\n    }\n\n    function blockFunction(bytes32[] calldata _func) external onlyProxy {\n        uint256 arrayLength = _func.length;\n        for (uint256 i = 0; i < arrayLength; i++) {\n            delete whitelistedFunctions[_func[i]];\n        }\n    }\n\n    function isWhitelistedFunction(bytes32 _func) external view returns (bool) {\n        return whitelistedFunctions[_func];\n    }\n}\n"
    },
    "contracts/libraries/acl/ExtCallACLProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../proxy/Proxy.sol';\nimport './IExtCallACL.sol';\n\ncontract ExtCallACLProxy is Proxy {\n    function isWhitelistedAddress(address _address) public view returns (bool) {\n        return IExtCallACL(address(target)).isWhitelistedAddress(_address);\n    }\n\n    function isWhitelistedFunction(bytes32 _func) public view returns (bool) {\n        return IExtCallACL(address(target)).isWhitelistedFunction(_func);\n    }\n}\n"
    },
    "contracts/libraries/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.8.9;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingOwner.\n     */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), 'Ownable: caller is not the owner');\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == owner;\n    }\n\n    /**\n     * @dev Allows the current owner to set the pendingOwner address.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        pendingOwner = newOwner;\n    }\n\n    /**\n     * @dev Allows the pendingOwner address to finalize the transfer.\n     */\n    function claimOwnership() public onlyPendingOwner {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n"
    },
    "contracts/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nlibrary DataTypes {\n    enum Tranche {\n        JUNIOR,\n        SENIOR\n    }\n\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        // for calculating overall interested accumulated\n        // then split it into two indexs base on two allocations\n        uint256 currentOverallLiquidityRate;\n        // Expressed in ray\n        uint256 currentSeniorIncomeAllocation;\n        // Expressed in ray\n        uint256 currentJuniorIncomeAllocation;\n        uint256 juniorLiquidityIndex;\n        uint256 seniorLiquidityIndex;\n        uint256 totalBorrows;\n        uint256 currentBorrowRate;\n        // Expressed in ray\n        uint256 securityRequirement;\n        //the decimals of the reserve asset\n        uint256 decimals;\n        address interestRateStrategyAddress;\n        address healthStrategyAddress;\n        address juniorDepositTokenAddress;\n        address seniorDepositTokenAddress;\n        address stableDebtAddress;\n        uint40 juniorLastUpdateTimestamp;\n        uint40 seniorLastUpdateTimestamp;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: Liquidate bonus\n        //bit 16-23: Decimals\n        //bit 24: Reserve is active\n        //bit 25: reserve is frozen\n        //bit 26: borrowing is enabled\n        //bit 27-30: reserved\n        //bit 31-46: reserve factor\n        //bit 47-62: lock up period in seconds\n        uint256 data;\n    }\n\n    struct FungibleTokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    struct BorrowData {\n        uint256 drawDownNumber;\n        uint256 totalDebt;\n        mapping(uint256 => DrawDown) drawDowns;\n        mapping(uint256 => Repayment) repayments;\n    }\n\n    struct DrawDown {\n        uint256 amount;\n        uint256 tenure;\n        uint40 timestamp;\n        uint256 borrowRate;\n        Repayment repayment;\n    }\n\n    struct Repayment {\n        uint256 totalPaid;\n        // tenure => amount\n        // todo wrapper this in the future\n        mapping(uint256 => uint256) repayment;\n    }\n\n    // tmp struct to avoid stack too long\n\n    struct DepositAndDebt {\n        uint256 juniorDepositAmount;\n        uint256 seniorDepositAmount;\n        uint256 totalDebt;\n    }\n\n    struct HealthRiskParameter {\n        uint256 securityDeposit;\n        uint256 currentBorrowRate;\n        uint256 compoundedDebt;\n        uint256 grossAssetValue;\n        uint256 aggregateOptimalRepaymentRate;\n        uint256 aggregateActualRepaymentRate;\n    }\n}\n"
    },
    "contracts/libraries/logic/ReserveLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\nimport '../math/WadRayMath.sol';\nimport '../math/MathUtils.sol';\nimport '../types/DataTypes.sol';\nimport '../helpers/Errors.sol';\nimport '../../interfaces/IDebtToken.sol';\nimport '../../component/liquiditymanager/DefaultReserveInterestRateStrategy.sol';\n\n/**\n * @title ReserveLogic library\n * @author Voyager\n * @notice Implements the logic to update the reserves state\n **/\nlibrary ReserveLogic {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    using ReserveLogic for DataTypes.ReserveData;\n\n    enum Tranche {\n        JUNIOR,\n        SENIOR\n    }\n\n    /**\n     * @dev Emitted when the state of a reserve is updated\n     * @param asset The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param liquidityIndex The new liquidity index\n     **/\n    event ReserveDataUpdated(\n        address indexed asset,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 liquidityIndex\n    );\n\n    function init(\n        DataTypes.ReserveData storage reserve,\n        address _juniorDepositTokenAddress,\n        address _seniorDepositTokenAddress,\n        uint256 _juniorIncomeAllocation,\n        uint256 _seniorIncomeAllocation,\n        address _stableDebtAddress,\n        address _interestRateStrategyAddress,\n        address _healthStrategyAddress\n    ) external {\n        reserve.juniorLiquidityIndex = WadRayMath.ray();\n        reserve.seniorLiquidityIndex = WadRayMath.ray();\n        reserve.juniorDepositTokenAddress = _juniorDepositTokenAddress;\n        reserve.seniorDepositTokenAddress = _seniorDepositTokenAddress;\n        //reserve.currentOverallLiquidityRate = WadRayMath.ray();\n        reserve.currentJuniorIncomeAllocation = _juniorIncomeAllocation;\n        reserve.currentSeniorIncomeAllocation = _seniorIncomeAllocation;\n        reserve.stableDebtAddress = _stableDebtAddress;\n        reserve.interestRateStrategyAddress = _interestRateStrategyAddress;\n        reserve.healthStrategyAddress = _healthStrategyAddress;\n    }\n\n    function updateState(\n        DataTypes.ReserveData storage reserve,\n        Tranche _tranche\n    ) public {\n        _updateIndexes(reserve, _tranche);\n    }\n\n    function getLiquidityRate(\n        DataTypes.ReserveData storage reserve,\n        Tranche _tranche\n    ) public view returns (uint256) {\n        return reserve._getLiquidityRate(_tranche);\n    }\n\n    struct UpdateInterestRatesLocalVars {\n        address stableDebtTokenAddress;\n        uint256 availableLiquidity;\n        uint256 totalStableDebt;\n        uint256 newLiquidityRate;\n        uint256 newStableRate;\n        uint256 avgStableRate;\n    }\n\n    function updateInterestRates(\n        DataTypes.ReserveData storage _reserve,\n        address _reserveAddress,\n        uint256 _juniorLiquidityAdded,\n        uint256 _juniorLiquidityTaken,\n        uint256 _seniorLiquidityAdded,\n        uint256 _seniorLiquidityTaken\n    ) public {\n        UpdateInterestRatesLocalVars memory vars;\n\n        vars.stableDebtTokenAddress = _reserve.stableDebtAddress;\n        uint256 liquidityAdded = _juniorLiquidityAdded.add(\n            _seniorLiquidityAdded\n        );\n        uint256 liquidityTaken = _juniorLiquidityTaken.add(\n            _seniorLiquidityTaken\n        );\n\n        (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(\n            _reserve.stableDebtAddress\n        ).getTotalSupplyAndAvgRate();\n\n        (\n            vars.newLiquidityRate,\n            vars.newStableRate\n        ) = IReserveInterestRateStrategy(_reserve.interestRateStrategyAddress)\n            .calculateInterestRates(\n                _reserveAddress,\n                _reserve.juniorDepositTokenAddress,\n                _reserve.seniorDepositTokenAddress,\n                liquidityAdded,\n                liquidityTaken,\n                _reserve.totalBorrows,\n                vars.avgStableRate\n            );\n        require(\n            vars.newLiquidityRate <= type(uint128).max,\n            Errors.RL_LIQUIDITY_RATE_OVERFLOW\n        );\n        require(\n            vars.newStableRate <= type(uint128).max,\n            Errors.RL_STABLE_BORROW_RATE_OVERFLOW\n        );\n        _reserve.currentOverallLiquidityRate = vars.newLiquidityRate;\n        _reserve.currentBorrowRate = vars.newStableRate;\n\n        emit ReserveDataUpdated(\n            _reserveAddress,\n            vars.newLiquidityRate,\n            vars.newStableRate,\n            vars.newLiquidityRate\n        );\n    }\n\n    function getNormalizedIncome(\n        DataTypes.ReserveData storage reserve,\n        Tranche _tranche\n    ) internal view returns (uint256) {\n        uint40 timestamp;\n        uint256 liquidityIndex;\n        if (_tranche == Tranche.JUNIOR) {\n            timestamp = reserve.juniorLastUpdateTimestamp;\n            liquidityIndex = reserve.juniorLiquidityIndex;\n        } else {\n            timestamp = reserve.seniorLastUpdateTimestamp;\n            liquidityIndex = reserve.seniorLiquidityIndex;\n        }\n\n        //solium-disable-next-line\n        if (timestamp == uint40(block.timestamp)) {\n            return liquidityIndex;\n        }\n\n        uint256 cumulated = MathUtils\n            .calculateLinearInterest(\n                reserve._getLiquidityRate(_tranche),\n                timestamp\n            )\n            .rayMul(liquidityIndex);\n        return cumulated;\n    }\n\n    function _getLiquidityRate(\n        DataTypes.ReserveData storage reserve,\n        Tranche _tranche\n    ) internal view returns (uint256) {\n        uint256 totalAllocationInRay = reserve\n            .currentJuniorIncomeAllocation\n            .add(reserve.currentSeniorIncomeAllocation);\n        if (_tranche == Tranche.JUNIOR) {\n            return\n                reserve.currentOverallLiquidityRate.rayMul(\n                    reserve.currentJuniorIncomeAllocation.rayDiv(\n                        totalAllocationInRay\n                    )\n                );\n        } else {\n            return\n                reserve.currentOverallLiquidityRate.rayMul(\n                    reserve.currentSeniorIncomeAllocation.rayDiv(\n                        totalAllocationInRay\n                    )\n                );\n        }\n    }\n\n    function _updateIndexes(\n        DataTypes.ReserveData storage reserve,\n        Tranche _tranche\n    ) internal {\n        if (_tranche == Tranche.JUNIOR) {\n            uint256 previousJuniorLiquidityIndex = reserve.juniorLiquidityIndex;\n            uint256 lastJuniorUpdatedTimestamp = reserve\n                .juniorLastUpdateTimestamp;\n            reserve._updateJuniorLiquidityIndex(\n                previousJuniorLiquidityIndex,\n                uint40(lastJuniorUpdatedTimestamp)\n            );\n        } else {\n            uint256 previousSeniorLiquidityIndex = reserve.seniorLiquidityIndex;\n            uint256 lastSeniorUpdatedTimestamp = reserve\n                .seniorLastUpdateTimestamp;\n            reserve._updateSeniorLiquidityIndex(\n                previousSeniorLiquidityIndex,\n                uint40(lastSeniorUpdatedTimestamp)\n            );\n        }\n    }\n\n    function _updateJuniorLiquidityIndex(\n        DataTypes.ReserveData storage reserve,\n        uint256 juniorLiquidityIndex,\n        uint40 timestamp\n    ) internal returns (uint256) {\n        uint256 juniorLiquidityRate = reserve._getLiquidityRate(Tranche.JUNIOR);\n        uint256 newJuniorLiquidityIndex = juniorLiquidityIndex;\n\n        // only cumulating if there is any income being produced\n        if (juniorLiquidityRate > 0) {\n            uint256 cumulatedLiquidityInterest = MathUtils\n                .calculateLinearInterest(juniorLiquidityRate, timestamp);\n            newJuniorLiquidityIndex = cumulatedLiquidityInterest.rayMul(\n                juniorLiquidityIndex\n            );\n            reserve.juniorLiquidityIndex = newJuniorLiquidityIndex;\n        }\n\n        reserve.juniorLastUpdateTimestamp = uint40(block.timestamp);\n        return newJuniorLiquidityIndex;\n    }\n\n    function _updateSeniorLiquidityIndex(\n        DataTypes.ReserveData storage reserve,\n        uint256 seniorLiquidityIndex,\n        uint40 timestamp\n    ) internal returns (uint256) {\n        uint256 seniorLiquidityRate = reserve._getLiquidityRate(Tranche.SENIOR);\n        uint256 newSeniorLiquidityIndex = seniorLiquidityIndex;\n\n        if (seniorLiquidityRate > 0) {\n            uint256 cumulatedLiquidityInterest = MathUtils\n                .calculateLinearInterest(seniorLiquidityRate, timestamp);\n            newSeniorLiquidityIndex = cumulatedLiquidityInterest.rayMul(\n                seniorLiquidityIndex\n            );\n            reserve.seniorLiquidityIndex = newSeniorLiquidityIndex;\n        }\n        reserve.seniorLastUpdateTimestamp = uint40(block.timestamp);\n        return newSeniorLiquidityIndex;\n    }\n}\n"
    },
    "contracts/component/vault/VaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/access/AccessControl.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/security/ReentrancyGuard.sol';\nimport '../../libraries/proxy/Proxyable.sol';\nimport '../../tokenization/SecurityDepositToken.sol';\nimport '../../mock/Tus.sol';\nimport '../../libraries/math/WadRayMath.sol';\nimport './Vault.sol';\nimport '../../interfaces/IVaultManager.sol';\nimport '../../interfaces/IACLManager.sol';\nimport '../Voyager.sol';\nimport '../infra/AddressResolver.sol';\nimport './VaultStorage.sol';\n\ncontract VaultManager is ReentrancyGuard, Proxyable, IVaultManager {\n    using SafeERC20 for ERC20;\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n\n    address public voyager;\n    mapping(address => uint256) public maxSecurityDeposit;\n    // reserve address => requirement expressed in ray\n    mapping(address => uint256) public securityDepositRequirement;\n\n    constructor(address payable _proxy, address _voyager)\n        public\n        Proxyable(_proxy)\n    {\n        voyager = _voyager;\n    }\n\n    modifier onlyAdmin() {\n        _requireCallerAdmin();\n        _;\n    }\n\n    /************************************** User Functions **************************************/\n\n    /**\n     * @dev Create a Vault for user\n     * @param _user the address of the player\n     **/\n    function createVault(address _user)\n        external\n        onlyProxy\n        returns (address vault)\n    {\n        bytes memory bytecode = type(Vault).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(_user));\n        assembly {\n            vault := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        Vault(vault).initialize(voyager, _user);\n        uint256 len = VaultStorage(getVaultStorageAddress()).pushNewVault(\n            _user,\n            vault\n        );\n        proxy._emit(\n            abi.encode(vault, len),\n            2,\n            keccak256('VaultCreated(address, address, uint256)'),\n            bytes32(abi.encodePacked(_user)),\n            0,\n            0\n        );\n    }\n\n    /**\n     * @dev Delegate call to Vault's depositSecurity\n     * @param _sponsor who actual deposits the reserve into the amount\n     * @param _vaultUser user address\n     * @param _reserve reserve address\n     * @param _amount amount user is willing to deposit\n     */\n    function depositSecurity(\n        address _sponsor,\n        address _vaultUser,\n        address _reserve,\n        uint256 _amount\n    ) external onlyProxy {\n        address vaultAddress = _getVault(_vaultUser);\n        Vault(vaultAddress).depositSecurity(_sponsor, _reserve, _amount);\n        proxy._emit(\n            abi.encode(_vaultUser, _reserve, _amount),\n            2,\n            keccak256('SecurityDeposited(address, address, address, uint256)'),\n            bytes32(abi.encodePacked(_sponsor)),\n            0,\n            0\n        );\n    }\n\n    /**\n     * @dev  Delegate call to Vault's redeemSecurity\n     * @param _sponsor sponsor address\n     * @param _vaultUser user address\n     * @param _reserve reserve address\n     * @param _amount redeem amount\n     **/\n    function redeemSecurity(\n        address payable _sponsor,\n        address _vaultUser,\n        address _reserve,\n        uint256 _amount\n    ) external onlyProxy {\n        address vaultAddress = _getVault(_vaultUser);\n        Vault(vaultAddress).redeemSecurity(_sponsor, _reserve, _amount);\n        proxy._emit(\n            abi.encode(_vaultUser, _reserve, _amount),\n            2,\n            keccak256('SecurityRedeemed(address, address, address, uint256)'),\n            bytes32(abi.encodePacked(_sponsor)),\n            0,\n            0\n        );\n    }\n\n    // placeholder function\n    function slash(\n        address _vaultUser,\n        address _reserve,\n        address payable _to,\n        uint256 _amount\n    ) public nonReentrant onlyProxy {\n        address vaultAddress = _getVault(_vaultUser);\n        return Vault(vaultAddress).slash(_reserve, _to, _amount);\n    }\n\n    /************************ HouseKeeping Function ******************************/\n\n    /**\n     * Init a deployed Vault, ensure it has overlying security deposit token and corresponding staking contract\n     * _vaultUser the user/owner of this vault\n     * _reserve the underlying asset address e.g. TUS\n     **/\n    function initVault(address _user, address _reserve) external {\n        initSecurityDepositToken(_user, _reserve);\n        initStakingContract(_user, _reserve);\n    }\n\n    function initSecurityDepositToken(address _vaultUser, address _reserve)\n        public\n        onlyProxy\n        onlyAdmin\n    {\n        address vaultAddress = _getVault(_vaultUser);\n        Vault(vaultAddress).initSecurityDepositToken(_reserve);\n        proxy._emit(\n            abi.encode(_reserve),\n            2,\n            keccak256('SecurityDepositTokenInited(address, address)'),\n            bytes32(abi.encodePacked(_vaultUser)),\n            0,\n            0\n        );\n    }\n\n    /**\n     * Init a deployed Vault, ensure it has overlying security deposit token and corresponding staking contract\n     * _vaultUser the user/owner of this vault\n     * _reserve the underlying asset address e.g. TUS\n     **/\n    function initStakingContract(address _vaultUser, address _reserve)\n        public\n        onlyProxy\n        onlyAdmin\n    {\n        address vaultAddress = _getVault(_vaultUser);\n        Vault(vaultAddress).initStakingContract(_reserve);\n        proxy._emit(\n            abi.encode(_reserve),\n            2,\n            keccak256('StakingContractInited(address, address)'),\n            bytes32(abi.encodePacked(_vaultUser)),\n            0,\n            0\n        );\n    }\n\n    /**\n     * @dev Set max security deposit for _reserve\n     * @param _reserve reserve address\n     * @param _amount max amount sponsor can deposit\n     */\n    function setMaxSecurityDeposit(address _reserve, uint256 _amount)\n        external\n        onlyProxy\n        onlyAdmin\n    {\n        maxSecurityDeposit[_reserve] = _amount;\n        proxy._emit(\n            abi.encode(_amount),\n            2,\n            keccak256('MaxSecurityDepositUpdated(address, uint256)'),\n            bytes32(abi.encodePacked(_reserve)),\n            0,\n            0\n        );\n    }\n\n    /**\n     * @dev Remove max security deposit for _reserve\n     * @param _reserve reserve address\n     */\n    function removeMaxSecurityDeposit(address _reserve)\n        external\n        onlyProxy\n        onlyAdmin\n    {\n        delete maxSecurityDeposit[_reserve];\n        proxy._emit(\n            abi.encode(_reserve),\n            2,\n            keccak256('MaxSecurityDepositDeleted(address)'),\n            bytes32(abi.encodePacked(_reserve)),\n            0,\n            0\n        );\n    }\n\n    /**\n     * @dev Update the security deposit requirement\n     * @param _reserve reserve address\n     * @param _requirement expressed in Ray\n     */\n    function updateSecurityDepositRequirement(\n        address _reserve,\n        uint256 _requirement\n    ) external onlyProxy onlyAdmin {\n        securityDepositRequirement[_reserve] = _requirement;\n        proxy._emit(\n            abi.encode(_requirement),\n            2,\n            keccak256('SecurityDepositRequirementSet(address, uint256)'),\n            bytes32(abi.encodePacked(_reserve)),\n            0,\n            0\n        );\n    }\n\n    /**\n     * @dev Remove security deposit\n     * @param _reserve reserve address\n     */\n    function removeSecurityDepositRequirement(address _reserve)\n        external\n        onlyProxy\n        onlyAdmin\n    {\n        delete securityDepositRequirement[_reserve];\n        proxy._emit(\n            abi.encode(_reserve),\n            2,\n            keccak256('SecurityDepositRequirementDeleted(address)'),\n            bytes32(abi.encodePacked(_reserve)),\n            0,\n            0\n        );\n    }\n\n    /************************************** View Functions **************************************/\n\n    function getSecurityDepositRequirement(address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return securityDepositRequirement[_reserve];\n    }\n\n    function getMaxSecurityDeposit(address _reserve)\n        external\n        view\n        onlyProxy\n        returns (uint256)\n    {\n        return maxSecurityDeposit[_reserve];\n    }\n\n    function underlyingBalance(\n        address _vaultUser,\n        address _reserve,\n        address _sponsor\n    ) public view returns (uint256) {\n        address vaultAddress = _getVault(_vaultUser);\n        return Vault(vaultAddress).underlyingBalance(_sponsor, _reserve);\n    }\n\n    /**\n     * @dev Get available credit\n     * @param _user user address\n     * @param _reserve reserve address\n     **/\n    function getAvailableCredit(address _user, address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 creditLimit = getCreditLimit(_user, _reserve);\n        uint256 accumulatedDebt = Vault(_getVault(_user)).getTotalDebt();\n        return creditLimit - accumulatedDebt;\n    }\n\n    /**\n     * @dev Get credit limit for a specific reserve\n     * @param _user user address\n     * @return _reserve reserve address\n     **/\n    function getCreditLimit(address _user, address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 currentSecurityDeposit = _getSecurityDeposit(_user, _reserve);\n        uint256 securityDepositRequirement = securityDepositRequirement[\n            _reserve\n        ];\n        require(\n            securityDepositRequirement != 0,\n            'security deposit requirement cannot be 0'\n        );\n        uint256 creditLimitInRay = currentSecurityDeposit.wadToRay().rayDiv(\n            securityDepositRequirement\n        );\n        return creditLimitInRay.rayToWad();\n    }\n\n    function getSecurityDeposit(address _user, address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return _getSecurityDeposit(_user, _reserve);\n    }\n\n    function getVaultStorageAddress() private view returns (address) {\n        Voyager v = Voyager(voyager);\n        address resolver = v.getAddressResolverAddress();\n        return AddressResolver(resolver).getAddress(v.getVaultStorageName());\n    }\n\n    function getSecurityDepositTokenAddress(address vault)\n        private\n        view\n        returns (address)\n    {\n        return Vault(vault).getSecurityDepositTokenAddress();\n    }\n\n    /**\n     * @dev Get existing Vault contract address for user\n     * @param _user the address of the player\n     * @return Vault address\n     **/\n    function getVault(address _user) external view returns (address) {\n        return _getVault(_user);\n    }\n\n    function eligibleAmount(\n        address _vaultUser,\n        address _reserve,\n        address _sponsor\n    ) public view returns (uint256) {\n        address vaultAddress = _getVault(_vaultUser);\n        return Vault(vaultAddress).eligibleAmount(_reserve, _sponsor);\n    }\n\n    /************************************** Private Functions **************************************/\n\n    function _getSecurityDeposit(address _user, address _reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        address vaultAddress = _getVault(_user);\n        uint256 currentSecurityDeposit = Vault(vaultAddress)\n            .getCurrentSecurityDeposit(_reserve);\n        return currentSecurityDeposit;\n    }\n\n    function _getVault(address _user) internal view returns (address) {\n        return VaultStorage(getVaultStorageAddress()).getVaultAddress(_user);\n    }\n\n    function _requireCallerAdmin() internal {\n        Voyager v = Voyager(voyager);\n        IACLManager aclManager = IACLManager(\n            v.addressResolver().getAddress(v.getACLManagerName())\n        );\n        require(aclManager.isVaultManager(messageSender), 'Not vault admin');\n    }\n}\n"
    },
    "contracts/component/vault/VaultManagerProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../libraries/proxy/Proxy.sol';\nimport '../../interfaces/IVaultManager.sol';\n\ncontract VaultManagerProxy is Proxy {\n    /************************** Immutable static call for target contract **************************/\n\n    function getMaxSecurityDeposit(address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        return IVaultManager(address(target)).getMaxSecurityDeposit(_reserve);\n    }\n\n    function getSecurityDepositRequirement(address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            IVaultManager(address(target)).getSecurityDepositRequirement(\n                _reserve\n            );\n    }\n\n    function getCreditLimit(address _user, address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        return IVaultManager(address(target)).getCreditLimit(_user, _reserve);\n    }\n\n    function eligibleAmount(\n        address _vaultUser,\n        address _reserve,\n        address _sponsor\n    ) external view returns (uint256) {\n        return\n            IVaultManager(address(target)).eligibleAmount(\n                _vaultUser,\n                _reserve,\n                _sponsor\n            );\n    }\n\n    function underlyingBalance(\n        address _vaultUser,\n        address _reserve,\n        address _sponsor\n    ) external view returns (uint256) {\n        return\n            IVaultManager(address(target)).underlyingBalance(\n                _vaultUser,\n                _reserve,\n                _sponsor\n            );\n    }\n}\n"
    },
    "contracts/component/liquiditymanager/LiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport './ReserveManager.sol';\nimport '../../libraries/helpers/Errors.sol';\nimport '../../libraries/logic/ReserveLogic.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '../shared/escrow/LiquidityDepositEscrow.sol';\nimport '../../interfaces/IReserveManager.sol';\nimport '../../interfaces/ILiquidityManager.sol';\nimport '../../tokenization/JuniorDepositToken.sol';\nimport '../../tokenization/SeniorDepositToken.sol';\n\ncontract LiquidityManager is ReserveManager, ILiquidityManager {\n    LiquidityDepositEscrow public liquidityDepositEscrow;\n\n    constructor(address payable _proxy, address _voyager)\n        ReserveManager(_proxy, _voyager)\n    {\n        liquidityDepositEscrow = LiquidityDepositEscrow(deployEscrow());\n        liquidityDepositEscrow.init(_voyager);\n    }\n\n    /************************************** User Functions **************************************/\n\n    function deposit(\n        address _asset,\n        ReserveLogic.Tranche _tranche,\n        uint256 _amount,\n        address _user,\n        address _onBehalfOf\n    ) external onlyProxy {\n        LiquidityManagerStorage lms = LiquidityManagerStorage(\n            liquidityManagerStorageAddress()\n        );\n        DataTypes.ReserveData memory reserve = getReserveData(_asset);\n\n        lms.updateStateOnDeposit(_asset, _tranche, _amount);\n\n        if (ReserveLogic.Tranche.JUNIOR == _tranche) {\n            JuniorDepositToken(reserve.juniorDepositTokenAddress).mint(\n                _onBehalfOf,\n                _amount,\n                getJuniorLiquidityIndex(_asset)\n            );\n        } else {\n            SeniorDepositToken(reserve.seniorDepositTokenAddress).mint(\n                _onBehalfOf,\n                _amount,\n                getSeniorLiquidityIndex(_asset)\n            );\n        }\n        liquidityDepositEscrow.deposit(_asset, _user, _amount);\n        proxy._emit(\n            abi.encode(_tranche, _user, _onBehalfOf, _amount),\n            2,\n            keccak256(\n                'Deposit(address, ReserveLogic.Tranche, address, address,uint256)'\n            ),\n            bytes32(abi.encodePacked(_asset)),\n            0,\n            0\n        );\n    }\n\n    /************************************** View Functions **************************************/\n\n    function getEscrowAddress() external view returns (address) {\n        return address(escrow());\n    }\n\n    function escrow() internal view override returns (LiquidityDepositEscrow) {\n        return liquidityDepositEscrow;\n    }\n\n    function getReserveNormalizedIncome(\n        address _asset,\n        ReserveLogic.Tranche _tranche\n    ) external view returns (uint256) {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        return\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\n                .getReserveNormalizedIncome(_asset, _tranche);\n    }\n\n    /************************************** Private Functions **************************************/\n\n    function deployEscrow() private returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender));\n        bytes memory bytecode = type(LiquidityDepositEscrow).creationCode;\n        address deployedEscrow;\n        assembly {\n            deployedEscrow := create2(\n                0,\n                add(bytecode, 32),\n                mload(bytecode),\n                salt\n            )\n        }\n        return deployedEscrow;\n    }\n}\n"
    },
    "contracts/component/infra/MessageBus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport './AddressResolver.sol';\nimport '../../interfaces/IMessageBus.sol';\nimport '../../interfaces/IDebtToken.sol';\nimport '../../interfaces/IVaultManager.sol';\nimport '../../libraries/ownership/Ownable.sol';\nimport '../../libraries/types/DataTypes.sol';\n//import \"../../libraries/utils/Address.sol\";\nimport '../../libraries/helpers/Errors.sol';\nimport '../liquiditymanager/LiquidityManager.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\n\n/**\n * todo it might be a bad name here, it actually performs as the centralise place\n * for querying each other among the internal components\n **/\ncontract MessageBus is IMessageBus, Ownable {\n    bytes32 public constant aclManagerName = 'aclManager';\n    bytes32 public constant liquidityManagerProxyName = 'liquidityManagerProxy';\n    bytes32 public constant liquidityManagerName = 'liquidityManager';\n    bytes32 public constant liquidityManagerStorageName =\n        'liquidityManagerStorage';\n    bytes32 public constant loanManagerName = 'loanManager';\n    bytes32 public constant vaultManagerProxyName = 'vaultManagerProxy';\n    bytes32 public constant vaultStorageName = 'vaultStorage';\n    bytes32 public constant securityDepositTokenName = 'securityDepositToken';\n    bytes32 public constant stableDebtTokenName = 'stableDebtToken';\n    bytes32 public constant extCallACLProxyName = 'extCallACLProxy';\n\n    AddressResolver public addressResolver;\n\n    /**\n     * @dev Get addressResolver contract address\n     * @return address of the resolver contract\n     **/\n    function getAddressResolverAddress() external view returns (address) {\n        return address(addressResolver);\n    }\n\n    /************************************** LiquidityManager Functions **************************************/\n\n    /**\n     * @dev Get LiquidityManagerProxy contract address\n     **/\n    function getLiquidityManagerProxyAddress()\n        public\n        view\n        returns (address payable)\n    {\n        address liquidityManagerProxyAddress = addressResolver.getAddress(\n            liquidityManagerProxyName\n        );\n        return payable(liquidityManagerProxyAddress);\n    }\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param _asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address _asset)\n        external\n        view\n        returns (DataTypes.ReserveData memory)\n    {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        return\n            LiquidityManager(getLiquidityManagerProxyAddress()).getReserveData(\n                _asset\n            );\n    }\n\n    /************************************** Vault Functions **************************************/\n\n    /**\n     * @dev Get vault address\n     * @param _user The owner of the vault\n     **/\n    function getVault(address _user) external view returns (address) {\n        return IVaultManager(getVaultManagerProxyAddress()).getVault(_user);\n    }\n\n    function getSecurityDeposit(address _user, address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            IVaultManager(getVaultManagerProxyAddress()).getSecurityDeposit(\n                _user,\n                _reserve\n            );\n    }\n\n    /**\n     * @dev Get max security deposit for _reserve\n     * @param _reserve reserve address\n     * @return max deposit amount\n     */\n    function getMaxSecurityDeposit(address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            IVaultManager(getVaultManagerProxyAddress()).getMaxSecurityDeposit(\n                _reserve\n            );\n    }\n\n    /**\n     * @dev Get current security deposit requirement\n     * @param _reserve reserve address\n     * @return requirement, expressed in Ray\n     **/\n    function getSecurityDepositRequirement(address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            IVaultManager(getVaultManagerProxyAddress())\n                .getSecurityDepositRequirement(_reserve);\n    }\n\n    /**\n     * @dev Get VaultManagerProxy contract address\n     * @return address of the VaultManager\n     **/\n    function getVaultManagerProxyAddress()\n        public\n        view\n        returns (address payable)\n    {\n        address vaultManagerProxyAddress = addressResolver.getAddress(\n            vaultManagerProxyName\n        );\n        return payable(vaultManagerProxyAddress);\n    }\n\n    /************************************** Stable Debt Token Functions **************************************/\n\n    function getCompoundedDebt(address _user) external view returns (uint256) {\n        return\n            IERC20(addressResolver.getAddress(stableDebtTokenName)).balanceOf(\n                _user\n            );\n    }\n\n    function getAggregateOptimalRepaymentRate(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            IStableDebtToken(addressResolver.getAddress(stableDebtTokenName))\n                .getAggregateOptimalRepaymentRate(_user);\n    }\n\n    function getAggregateActualRepaymentRate(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            IStableDebtToken(addressResolver.getAddress(stableDebtTokenName))\n                .getAggregateActualRepaymentRate(_user);\n    }\n\n    /************************************** Constant Functions **************************************/\n\n    function getVaultManagerProxyName() external view returns (bytes32) {\n        return vaultManagerProxyName;\n    }\n\n    function getVaultStorageName() external view returns (bytes32) {\n        return vaultStorageName;\n    }\n\n    function getLiquidityManagerProxyName() external view returns (bytes32) {\n        return liquidityManagerProxyName;\n    }\n\n    function getLiquidityManagerStorageName() external view returns (bytes32) {\n        return liquidityManagerStorageName;\n    }\n\n    function getLoanManagerName() external view returns (bytes32) {\n        return loanManagerName;\n    }\n\n    function getSecurityDepositTokenName() external view returns (bytes32) {\n        return securityDepositTokenName;\n    }\n\n    function getExtCallACLProxyName() external view returns (bytes32) {\n        return extCallACLProxyName;\n    }\n\n    function getACLManagerName() external view returns (bytes32) {\n        return aclManagerName;\n    }\n\n    function getStableDebtTokenName() external view returns (bytes32) {\n        return stableDebtTokenName;\n    }\n}\n"
    },
    "contracts/libraries/proxy/Proxyable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport './Proxy.sol';\nimport '../ownership/Ownable.sol';\n\nabstract contract Proxyable is Ownable {\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\n    address public messageSender;\n\n    modifier onlyProxy() {\n        _onlyProxy();\n        _;\n    }\n\n    modifier optionalProxy_onlyOwner() {\n        _optionalProxy_onlyOwner();\n        _;\n    }\n\n    event ProxyUpdated(address proxyAddress);\n\n    constructor(address payable _proxy) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), 'Owner must be set');\n\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function _onlyProxy() private view {\n        require(msg.sender == address(proxy), 'Only the proxy can call');\n    }\n\n    function setProxy(address payable _proxy) external onlyOwner {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setMessageSender(address sender) external onlyProxy {\n        messageSender = sender;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _optionalProxy_onlyOwner() private {\n        if (msg.sender != address(proxy) && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner, 'Owner only function');\n    }\n}\n"
    },
    "contracts/libraries/acl/IExtCallACL.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IExtCallACL {\n    function whitelistAddress(address[] calldata _address) external;\n\n    function blockAddress(address[] calldata _address) external;\n\n    function isWhitelistedAddress(address _address)\n        external\n        view\n        returns (bool);\n\n    function whitelistFunction(bytes32[] calldata _func) external;\n\n    function blockFunction(bytes32[] calldata _func) external;\n\n    function isWhitelistedFunction(bytes32 _func) external view returns (bool);\n}\n"
    },
    "contracts/libraries/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../ownership/Ownable.sol';\nimport './Proxyable.sol';\n\ncontract Proxy is Ownable {\n    Proxyable public target;\n\n    event TargetUpdated(Proxyable newTarget);\n\n    modifier onlyTarget() {\n        require(Proxyable(msg.sender) == target, 'Must be proxy target');\n        _;\n    }\n\n    function setTarget(Proxyable _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function _emit(\n        bytes calldata callData,\n        uint256 numTopics,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3,\n        bytes32 topic4\n    ) external onlyTarget {\n        uint256 size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n            case 0 {\n                log0(add(_callData, 32), size)\n            }\n            case 1 {\n                log1(add(_callData, 32), size, topic1)\n            }\n            case 2 {\n                log2(add(_callData, 32), size, topic1, topic2)\n            }\n            case 3 {\n                log3(add(_callData, 32), size, topic1, topic2, topic3)\n            }\n            case 4 {\n                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n            }\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n    fallback() external payable {\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\n        target.setMessageSender(msg.sender);\n\n        assembly {\n            let free_ptr := mload(0x40)\n            calldatacopy(free_ptr, 0, calldatasize())\n\n            /* We must explicitly forward ether to the underlying contract as well. */\n            let result := call(\n                gas(),\n                sload(target.slot),\n                callvalue(),\n                free_ptr,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(free_ptr, 0, returndatasize())\n\n            if iszero(result) {\n                revert(free_ptr, returndatasize())\n            }\n            return(free_ptr, returndatasize())\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/libraries/math/WadRayMath.sol": {
      "content": "pragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\n\n/******************\n@title WadRayMath library\n@author Aave\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n */\n\nlibrary WadRayMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant halfWAD = WAD / 2;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant halfRAY = RAY / 2;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    function Ray() public pure returns (uint256) {\n        return RAY;\n    }\n\n    function ray() internal pure returns (uint256) {\n        return RAY;\n    }\n\n    function wad() internal pure returns (uint256) {\n        return WAD;\n    }\n\n    function halfRay() internal pure returns (uint256) {\n        return halfRAY;\n    }\n\n    function halfWad() internal pure returns (uint256) {\n        return halfWAD;\n    }\n\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return halfWAD.add(a.mul(b)).div(WAD);\n    }\n\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        return halfB.add(a.mul(WAD)).div(b);\n    }\n\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return halfRAY.add(a.mul(b)).div(RAY);\n    }\n\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        return halfB.add(a.mul(RAY)).div(b);\n    }\n\n    function rayToWad(uint256 a) internal pure returns (uint256) {\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\n\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\n    }\n\n    function wadToRay(uint256 a) internal pure returns (uint256) {\n        return a.mul(WAD_RAY_RATIO);\n    }\n\n    // @dev calculates base^exp. The code uses the ModExp precompile\n    // @return base^exp, in ray\n    //solium-disable-next-line\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rayMul(x, x);\n\n            if (n % 2 != 0) {\n                z = rayMul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\nimport {WadRayMath} from './WadRayMath.sol';\n\nlibrary MathUtils {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @dev Function to calculate the interest accumulated using a linear interest rate formula\n     * @param rate The interest rate, in ray\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\n     * @return The interest rate linearly accumulated during the timeDelta, in ray\n     **/\n\n    function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        //solium-disable-next-line\n        uint256 timeDifference = block.timestamp.sub(\n            uint256(lastUpdateTimestamp)\n        );\n\n        return\n            (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());\n    }\n\n    /**\n     * @dev Function to calculate the interest using a compounded interest rate formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     *\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     *\n     * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\n     * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\n     *\n     * @param rate The interest rate, in ray\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\n     * @return The interest rate compounded during the timeDelta, in ray\n     **/\n    function calculateCompoundedInterest(\n        uint256 rate,\n        uint40 lastUpdateTimestamp,\n        uint256 currentTimestamp\n    ) internal pure returns (uint256) {\n        //solium-disable-next-line\n        uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));\n\n        if (exp == 0) {\n            return WadRayMath.ray();\n        }\n\n        uint256 expMinusOne = exp - 1;\n\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n        uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\n\n        uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\n        uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\n\n        uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;\n        uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(\n            basePowerThree\n        ) / 6;\n\n        return\n            WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(\n                thirdTerm\n            );\n    }\n\n    /**\n     * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\n     * @param rate The interest rate (in ray)\n     * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\n     **/\n    function calculateCompoundedInterest(\n        uint256 rate,\n        uint40 lastUpdateTimestamp\n    ) internal view returns (uint256) {\n        return\n            calculateCompoundedInterest(\n                rate,\n                lastUpdateTimestamp,\n                block.timestamp\n            );\n    }\n}\n"
    },
    "contracts/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.9;\n\n/**\n * @title Errors library\n * @author Voyager\n * @notice Defines the error messages emitted by the different contracts of the Voyager protocol\n * @dev Error messages prefix glossary:\n *  - VL = ValidationLogic\n *  - LM = LiquidityManager\n *  - LOM = LoanManager\n *  - CT = Common errors between tokens\n *  - RL = ReserveLogic\n */\nlibrary Errors {\n    string public constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0'\n    string public constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve'\n    string public constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve is frozen'\n    string public constant CT_CALLER_MUST_BE_LIQUIDITY_MANAGER_POOL = '20';\n    string public constant CT_CALLER_MUST_BE_LOAN_MANAGER = '21';\n    string public constant CT_INVALID_MINT_AMOUNT = '21';\n    string public constant CT_INVALID_BURN_AMOUNT = '22';\n    string public constant LM_NOT_CONTRACT = '60';\n    string public constant LP_IS_PAUSED = '61'; // 'Pool is paused'\n    string public constant LOM_RESERVE_NOT_SUFFICIENT = '70';\n    string public constant LOM_CREDIT_NOT_SUFFICIENT = '71';\n    string public constant LOM_HEALTH_RISK_BELOW_ONE = '71';\n    string public constant LOM_NOT_VAULT_OWNER = '72';\n    string public constant RL_LIQUIDITY_RATE_OVERFLOW = '80'; //  Liquidity rate overflows uint128\n    string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '81'; //  Stable borrow rate overflows uint128\n}\n"
    },
    "contracts/interfaces/IDebtToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IStableDebtToken {\n    /**\n     * @dev Emitted when new stable debt is minted\n     * @param user The address of the user who triggered the minting\n     * @param amount The amount minted (user entered amount + balance increase from interest)\n     * @param currentBalance The current balance of the user\n     * @param balanceIncrease The increase in balance since the last action of the user\n     * @param newRate The rate of the debt after the minting\n     * @param avgStableRate The next average stable rate after the minting\n     * @param newTotalSupply The next total supply of the stable debt token after the action\n     **/\n    event Mint(\n        address indexed user,\n        uint256 amount,\n        uint256 currentBalance,\n        uint256 balanceIncrease,\n        uint256 newRate,\n        uint256 avgStableRate,\n        uint256 newTotalSupply\n    );\n\n    function getAverageStableRate() external view returns (uint256);\n\n    function getTotalSupplyAndAvgRate()\n        external\n        view\n        returns (uint256, uint256);\n\n    function getAggregateOptimalRepaymentRate(address _user)\n        external\n        view\n        returns (uint256);\n\n    function getAggregateActualRepaymentRate(address _user)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/component/liquiditymanager/DefaultReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../libraries/math/WadRayMath.sol';\nimport '../../interfaces/IReserveInterestRateStrategy.sol';\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\n\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n    /**\n     * this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates\n     * Expressed in RAY\n     **/\n    uint256 public immutable OPTIMAL_UTILIZATION_RATE;\n\n    // Base interest rate set by governance. Expressed in ray\n    uint256 internal immutable baseBorrowRate;\n\n    // Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 internal immutable stableRateSlope1;\n\n    // Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 internal immutable stableRateSlope2;\n\n    constructor(\n        uint256 _optimalUtilizationRate,\n        uint256 _stableRateSlope1,\n        uint256 _stableRateSlope2,\n        uint256 _baseBorrowRate\n    ) public {\n        OPTIMAL_UTILIZATION_RATE = _optimalUtilizationRate;\n        baseBorrowRate = _baseBorrowRate;\n        stableRateSlope1 = _stableRateSlope1;\n        stableRateSlope2 = _stableRateSlope2;\n    }\n\n    struct CalcInterestRatesLocalVars {\n        uint256 totalDebt;\n        uint256 currentStableBorrowRate;\n        uint256 currentLiquidityRate;\n        uint256 utilizationRate;\n    }\n\n    /**\n     * @dev Calculates the interest rates depending on the reserve's state and configuration\n     * @param reserve The address of the reserve\n     * @param juniorDepositToken The address of junior deposit token\n     * @param seniorDepositToken The address of senior deposit token\n     * @param liquidityAdded The liquidity added during the operation\n     * @param liquidityTaken The liquidity taken during the operation\n     * @param totalStableDebt The total borrowed from the reserve a stable rate\n     * @param averageBorrowRate The current average borrow rate\n     **/\n    function calculateInterestRates(\n        address reserve,\n        address juniorDepositToken,\n        address seniorDepositToken,\n        uint256 liquidityAdded,\n        uint256 liquidityTaken,\n        uint256 totalStableDebt,\n        uint256 averageBorrowRate\n    ) external view returns (uint256, uint256) {\n        uint256 availableJuniorLiquidity = IERC20(reserve).balanceOf(\n            juniorDepositToken\n        );\n        uint256 availableSeniorLiquidity = IERC20(reserve).balanceOf(\n            seniorDepositToken\n        );\n        uint256 availableLiquidity = availableJuniorLiquidity.add(\n            availableSeniorLiquidity\n        );\n        availableLiquidity = availableLiquidity.add(liquidityAdded).sub(\n            liquidityTaken\n        );\n        return\n            calculateInterestRates(\n                reserve,\n                availableLiquidity,\n                totalStableDebt,\n                averageBorrowRate\n            );\n    }\n\n    /**\n     * @dev Calculates the interest rates depending on the reserve's state and configurations.\n     * @param reserve The address of the reserve\n     * @param availableLiquidity The liquidity available in the corresponding aToken\n     * @param totalStableDebt The total borrowed from the reserve a stable rate\n     * @return The liquidity rate, the stable borrow rate\n     * @param averageBorrowRate The current average borrow rate\n     **/\n    function calculateInterestRates(\n        address reserve,\n        uint256 availableLiquidity,\n        uint256 totalStableDebt,\n        uint256 averageBorrowRate\n    ) public view returns (uint256, uint256) {\n        CalcInterestRatesLocalVars memory vars;\n\n        vars.totalDebt = totalStableDebt;\n        vars.currentStableBorrowRate = baseBorrowRate;\n        vars.currentLiquidityRate = 0;\n\n        vars.utilizationRate = vars.totalDebt == 0\n            ? 0\n            : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\n\n        if (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) {\n            vars.currentStableBorrowRate = vars\n                .currentStableBorrowRate\n                .add(stableRateSlope1)\n                .add(\n                    stableRateSlope2\n                        .rayMul(\n                            vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE)\n                        )\n                        .rayDiv(WadRayMath.Ray().sub(OPTIMAL_UTILIZATION_RATE))\n                );\n        } else {\n            vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(\n                stableRateSlope1.rayMul(vars.utilizationRate).rayDiv(\n                    OPTIMAL_UTILIZATION_RATE\n                )\n            );\n        }\n\n        vars.currentLiquidityRate = averageBorrowRate.rayMul(\n            vars.utilizationRate\n        );\n        return (vars.currentLiquidityRate, vars.currentStableBorrowRate);\n    }\n}\n"
    },
    "contracts/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\n/**\n@title IReserveInterestRateStrategyInterface interface\n@notice Interface for the calculation of the interest rates.\n*/\n\ninterface IReserveInterestRateStrategy {\n    function calculateInterestRates(\n        address reserve,\n        uint256 availableLiquidity,\n        uint256 totalStableDebt,\n        uint256 averageBorrowRate\n    ) external view returns (uint256, uint256);\n\n    function calculateInterestRates(\n        address reserve,\n        address juniorDepositToken,\n        address seniorDepositToken,\n        uint256 liquidityAdded,\n        uint256 liquidityTaken,\n        uint256 totalStableDebt,\n        uint256 averageBorrowRate\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IAddressResolver {\n    event AddressImported(bytes32 name, address destination);\n\n    function importAddresses(\n        bytes32[] calldata names,\n        address[] calldata destinations\n    ) external;\n\n    function getAddress(bytes32 name) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason)\n        external\n        view\n        returns (address);\n}\n"
    },
    "contracts/tokenization/SecurityDepositToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\nimport 'openzeppelin-solidity/contracts/access/AccessControl.sol';\nimport '../libraries/math/WadRayMath.sol';\nimport '../component/vault/Vault.sol';\n\ncontract SecurityDepositToken is ERC20, AccessControl {\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n\n    bytes32 public constant VAULT = keccak256('VAULT');\n\n    address public underlyingAsset;\n    uint8 public underlyingAssetDecimals;\n    Vault public vault;\n\n    event MintOnDeposit(address indexed account, uint256 amount);\n\n    event BurnOnRedeem(address indexed account, uint256 amount);\n\n    constructor(\n        address _underlyingAsset,\n        uint8 _underlyingAssetDecimals,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        _setupRole(VAULT, msg.sender);\n        vault = Vault(msg.sender);\n        underlyingAsset = _underlyingAsset;\n        underlyingAssetDecimals = _underlyingAssetDecimals;\n    }\n\n    function mintOnDeposit(address account, uint256 amount)\n        external\n        onlyRole(VAULT)\n    {\n        _mint(account, amount);\n        emit MintOnDeposit(account, amount);\n    }\n\n    function burnOnRedeem(address account, uint256 amount)\n        external\n        onlyRole(VAULT)\n    {\n        _burn(account, amount);\n        emit BurnOnRedeem(account, amount);\n    }\n\n    function underlyingBalanceOf(address _sponsor)\n        external\n        view\n        returns (uint256)\n    {\n        return vault.underlyingBalance(_sponsor, underlyingAsset);\n    }\n}\n"
    },
    "contracts/mock/Tus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\n\ncontract Tus is ERC20 {\n    constructor(uint256 initialSupply) ERC20('Treasure Under Sea', 'TUS') {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"
    },
    "contracts/component/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/security/ReentrancyGuard.sol';\nimport './SecurityDepositEscrow.sol';\nimport '../infra/AddressResolver.sol';\nimport '../Voyager.sol';\nimport '../staking/StakingRewards.sol';\nimport '../../tokenization/SecurityDepositToken.sol';\nimport '../../tokenization/StableDebtToken.sol';\nimport '../../libraries/math/WadRayMath.sol';\nimport '../../interfaces/IVault.sol';\nimport './VaultManager.sol';\nimport '../../interfaces/IACLManager.sol';\n\ncontract Vault is ReentrancyGuard, IVault {\n    using WadRayMath for uint256;\n    bytes32 public constant BORROWER = keccak256('BORROWER');\n\n    address public factory;\n    address public voyager;\n    address[] public players;\n    SecurityDepositEscrow public securityDepositEscrow;\n    SecurityDepositToken public securityDepositToken;\n    StableDebtToken public stableDebtToken;\n    StakingRewards public stakingContract;\n\n    uint256 public totalDebt;\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, 'only factory error');\n        _;\n    }\n\n    modifier onlyLoanManager() {\n        _requireCallerLoanManager();\n        _;\n    }\n\n    constructor() public {\n        factory = msg.sender;\n        securityDepositEscrow = SecurityDepositEscrow(deployEscrow());\n    }\n\n    function deployEscrow() private returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender));\n        bytes memory bytecode = type(SecurityDepositEscrow).creationCode;\n        address deployedEscrow;\n        assembly {\n            deployedEscrow := create2(\n                0,\n                add(bytecode, 32),\n                mload(bytecode),\n                salt\n            )\n        }\n        return deployedEscrow;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _voyager, address borrower) external {\n        require(msg.sender == factory, 'Voyager Vault: FORBIDDEN'); // sufficient check\n        voyager = _voyager;\n    }\n\n    function getVaultManagerProxyAddress() private returns (address) {\n        Voyager voyager = Voyager(voyager);\n        address addressResolver = voyager.getAddressResolverAddress();\n        return\n            AddressResolver(addressResolver).getAddress(\n                voyager.getVaultManagerProxyName()\n            );\n    }\n\n    function initSecurityDepositToken(address _reserve) external onlyFactory {\n        require(\n            address(securityDepositToken) == address(0),\n            'Vault: security deposit token has been initialized'\n        );\n        ERC20 token = ERC20(_reserve);\n        securityDepositToken = new SecurityDepositToken(\n            _reserve,\n            token.decimals(),\n            token.name(),\n            token.symbol()\n        );\n    }\n\n    function initStakingContract(address _reserve) external onlyFactory {\n        require(\n            address(stakingContract) == address(0),\n            'Vault: staking contract has been initialized'\n        );\n        require(\n            address(securityDepositToken) != address(0),\n            'Vault: security deposit token has not been initialized'\n        );\n        stakingContract = new StakingRewards(\n            address(securityDepositToken),\n            _reserve\n        );\n    }\n\n    /**\n     * @dev Transfer some deposit security\n     * @param _sponsor user address who deposit to this escrow\n     * @param _reserve reserve address\n     * @param _amount deposit amount\n     **/\n    function depositSecurity(\n        address _sponsor,\n        address _reserve,\n        uint256 _amount\n    ) external payable nonReentrant onlyFactory {\n        // check max security deposit amount for this _reserve\n        uint256 maxAllowedAmount = Voyager(voyager).getMaxSecurityDeposit(\n            _reserve\n        );\n        uint256 depositedAmount = securityDepositEscrow.getDepositAmount(\n            _reserve\n        );\n        require(\n            depositedAmount + _amount < maxAllowedAmount,\n            'Vault: deposit amount exceed'\n        );\n        securityDepositEscrow.deposit(_reserve, _sponsor, _amount);\n        securityDepositToken.mintOnDeposit(_sponsor, _amount);\n    }\n\n    /**\n     * @dev get current security amount\n     * @param _reserve underlying asset address\n     **/\n    function getCurrentSecurityDeposit(address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        return securityDepositEscrow.getDepositAmount(_reserve);\n    }\n\n    function getActualSecurityDeposit(address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        return ERC20(_reserve).balanceOf(address(securityDepositEscrow));\n    }\n\n    /**\n     * @dev Get total debt of the vault\n     **/\n    function getTotalDebt() public view returns (uint256) {\n        return totalDebt;\n    }\n\n    /**\n     * @dev Get unused deposits\n     * @param _sponsor sponsor address\n     * @param _reserve reserve address\n     **/\n    function getUnusedDeposits(address _sponsor, address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 securityRequirement = VaultManager(factory)\n            .getSecurityDepositRequirement(_reserve);\n        return\n            securityDepositToken.balanceOf(_sponsor) -\n            totalDebt.wadToRay().rayMul(securityRequirement);\n    }\n\n    /**\n     * @dev Redeem underlying reserve\n     * @param _sponsor sponsor address\n     * @param _reserve reserve address\n     * @param _amount redeem amount\n     **/\n    function redeemSecurity(\n        address payable _sponsor,\n        address _reserve,\n        uint256 _amount\n    ) external payable nonReentrant onlyFactory {\n        require(\n            _amount <= getUnusedDeposits(_sponsor, _reserve),\n            'Vault: cannot redeem more than unused deposits'\n        );\n        securityDepositEscrow.withdraw(\n            _reserve,\n            _sponsor,\n            underlyingBalance(_sponsor, _reserve)\n        );\n        securityDepositToken.burnOnRedeem(_sponsor, _amount);\n    }\n\n    function underlyingBalance(address _sponsor, address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 amountToRedeemInRay = securityDepositToken\n            .balanceOf(_sponsor)\n            .wadToRay()\n            .rayDiv(securityDepositToken.totalSupply().wadToRay())\n            .rayMul(getActualSecurityDeposit(_reserve).wadToRay());\n        return amountToRedeemInRay.rayToWad();\n    }\n\n    function eligibleAmount(address _reserve, address _sponsor)\n        public\n        view\n        returns (uint256)\n    {\n        return securityDepositEscrow.eligibleAmount(_reserve, _sponsor);\n    }\n\n    function increaseTotalDebt(uint256 _amount) external onlyLoanManager {\n        totalDebt += _amount;\n    }\n\n    // placeholder function\n    function slash(\n        address _reserve,\n        address payable _to,\n        uint256 _amount\n    ) public nonReentrant onlyFactory {\n        securityDepositEscrow.slash(_reserve, _to, _amount);\n    }\n\n    function getSecurityDepositTokenAddress() external view returns (address) {\n        return address(securityDepositToken);\n    }\n\n    function getStakingContractAddress() external view returns (address) {\n        return address(stakingContract);\n    }\n\n    /**\n     * @dev Get SecurityDepositEscrow contract address\n     * @return address\n     **/\n    function getSecurityDepositEscrowAddress() external view returns (address) {\n        return address(securityDepositEscrow);\n    }\n\n    function getVersion() external view returns (string memory) {\n        string memory version = 'Vault 0.0.1';\n        return version;\n    }\n\n    function _requireCallerLoanManager() internal {\n        Voyager v = Voyager(voyager);\n        IACLManager aclManager = IACLManager(\n            v.addressResolver().getAddress(v.getACLManagerName())\n        );\n        require(aclManager.isLoanManager(msg.sender), 'Not liquidity manager');\n    }\n}\n"
    },
    "contracts/interfaces/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IVaultManager {\n    function getMaxSecurityDeposit(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getSecurityDepositRequirement(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getCreditLimit(address _user, address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function eligibleAmount(\n        address _vaultUser,\n        address _reserve,\n        address _sponsor\n    ) external view returns (uint256);\n\n    function underlyingBalance(\n        address _vaultUser,\n        address _reserve,\n        address _sponsor\n    ) external view returns (uint256);\n\n    function createVault(address _user) external returns (address vault);\n\n    function getVault(address _user) external view returns (address);\n\n    function getSecurityDeposit(address _user, address _reserve)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/component/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../libraries/state/State.sol';\nimport '../../libraries/types/DataTypes.sol';\nimport '../../libraries/math/WadRayMath.sol';\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\n\n// central storage for all vaults\ncontract VaultStorage is State {\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n\n    address[] public allVaults;\n    // player address => vault address\n    mapping(address => address) public getVault;\n\n    constructor(address _vaultManager) State(_vaultManager) {}\n\n    function pushNewVault(address _player, address vault)\n        external\n        onlyAssociatedContract\n        returns (uint256)\n    {\n        allVaults.push(vault);\n        getVault[_player] = vault;\n        return allVaults.length;\n    }\n\n    /**\n     * @dev Get Vault address for a specific user\n     * @param _user the address of the player\n     **/\n    function getVaultAddress(address _user) external view returns (address) {\n        return getVault[_user];\n    }\n\n    /**\n     * @dev Get all credit account addresses\n     **/\n    function getAllVaults() external view returns (address[] memory) {\n        return allVaults;\n    }\n}\n"
    },
    "contracts/component/vault/SecurityDepositEscrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../libraries/Escrow.sol';\nimport '../../libraries/ownership/Ownable.sol';\n\ncontract SecurityDepositEscrow is Escrow, Ownable {\n    function getVersion() external view returns (string memory) {\n        string memory version = 'SecurityDepositEscrow 0.0.1';\n        return version;\n    }\n\n    // placeholder function\n    function slash(\n        address _reserve,\n        address payable _to,\n        uint256 _amount\n    ) public payable nonReentrant onlyOwner {\n        transferToUser(_reserve, _to, _amount);\n    }\n\n    function deposit(\n        address _reserve,\n        address _user,\n        uint256 _amount\n    ) public payable nonReentrant onlyOwner {\n        _deposit(_reserve, _user, _amount);\n    }\n\n    function withdraw(\n        address _reserve,\n        address payable _user,\n        uint256 _amount\n    ) public onlyOwner {\n        _withdraw(_reserve, _user, _amount);\n    }\n}\n"
    },
    "contracts/component/staking/StakingRewards.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '../../libraries/helpers/Pausable.sol';\nimport 'openzeppelin-solidity/contracts/security/ReentrancyGuard.sol';\nimport './RewardsDistributionRecipient.sol';\n\ncontract StakingRewards is\n    ReentrancyGuard,\n    RewardsDistributionRecipient,\n    Pausable\n{\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public stakingToken;\n    IERC20 public rewardsToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 7 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    constructor(address _stakingToken, address _rewardsToken) {\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IERC20(_rewardsToken);\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(_totalSupply)\n            );\n    }\n\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0, 'Cannot stake 0');\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, 'Cannot withdraw 0');\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardsDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance.div(rewardsDuration),\n            'Provided reward too high'\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            'Previous rewards period must be complete before changing the duration for the new period'\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n}\n"
    },
    "contracts/tokenization/StableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../libraries/math/WadRayMath.sol';\nimport '../libraries/math/MathUtils.sol';\nimport '../component/infra/AddressResolver.sol';\nimport './DebtTokenBase.sol';\nimport '../interfaces/IDebtToken.sol';\nimport '../libraries/types/DataTypes.sol';\nimport 'openzeppelin-solidity/contracts/utils/math/SafeCast.sol';\nimport 'openzeppelin-solidity/contracts/utils/Context.sol';\nimport '../libraries/helpers/Errors.sol';\nimport '../interfaces/IInitializableDebtToken.sol';\n\ncontract StableDebtToken is\n    Context,\n    IInitializableDebtToken,\n    IStableDebtToken,\n    DebtTokenBase\n{\n    using WadRayMath for uint256;\n    using SafeCast for uint256;\n\n    modifier onlyLoanManager() {\n        require(\n            _msgSender() == addressResolver.getAddress('loanManager'),\n            Errors.CT_CALLER_MUST_BE_LOAN_MANAGER\n        );\n        _;\n    }\n\n    uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n    uint256 public constant SECONDS_PER_DAY = 1 days;\n\n    uint256 internal _avgStableRate;\n    mapping(address => uint256) internal _usersStableRate;\n    uint40 internal _totalSupplyTimestamp;\n    mapping(address => DataTypes.BorrowData) internal _borrowData;\n\n    AddressResolver internal addressResolver;\n    address internal underlyingAsset;\n\n    function initialize(\n        address _underlyingAsset,\n        uint8 _debtTokenDecimals,\n        string memory _debtTokenName,\n        string memory _debtTokenSymbol,\n        bytes calldata _params\n    ) external initializer {\n        _setName(_debtTokenName);\n        _setSymbol(_debtTokenSymbol);\n        _setDecimals(_debtTokenDecimals);\n\n        underlyingAsset = _underlyingAsset;\n\n        emit Initialized(\n            underlyingAsset,\n            _debtTokenDecimals,\n            _debtTokenName,\n            _debtTokenSymbol,\n            _params\n        );\n    }\n\n    /**\n     * @dev Returns the average stable rate\n     **/\n    function getAverageStableRate() external view override returns (uint256) {\n        return _avgStableRate;\n    }\n\n    /**\n     * @dev Calculate the current user debt principal\n     **/\n    function principalOf(address _account) public view returns (uint256) {\n        DataTypes.BorrowData storage borrowData = _borrowData[_account];\n        uint256 principal;\n        for (uint256 i = 0; i < borrowData.drawDownNumber; i++) {\n            principal += borrowData.drawDowns[i].amount;\n        }\n\n        return principal;\n    }\n\n    /**\n     * @dev Calculates the current user debt balance\n     * @return The accumulated debt of the user\n     **/\n    function balanceOf(address _account)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        DataTypes.BorrowData storage borrowData = _borrowData[_account];\n        uint256 cumulatedBalance;\n        for (uint256 i = 0; i < borrowData.drawDownNumber; i++) {\n            uint256 stableRate = borrowData.drawDowns[i].borrowRate;\n            uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\n                stableRate,\n                borrowData.drawDowns[i].timestamp\n            );\n            cumulatedBalance += borrowData.drawDowns[i].amount.rayMul(\n                cumulatedInterest\n            );\n        }\n        return cumulatedBalance;\n    }\n\n    function _mint(address _account) internal {\n        DataTypes.BorrowData storage borrowData = _borrowData[_account];\n        for (uint256 i = 0; i < borrowData.drawDownNumber; i++) {\n            DataTypes.DrawDown storage drawDown = borrowData.drawDowns[i];\n            uint256 stableRate = drawDown.borrowRate;\n            uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\n                stableRate,\n                drawDown.timestamp\n            );\n            drawDown.amount = drawDown.amount.rayMul(cumulatedInterest);\n            drawDown.timestamp = uint40(block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Returns the the total supply and the average stable rate\n     **/\n    function getTotalSupplyAndAvgRate()\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 avgRate = _avgStableRate;\n        return (_calcTotalSupply(avgRate), avgRate);\n    }\n\n    /**\n     * @dev Calculates the total supply\n     * @param avgRate The average rate at which the total supply increases\n     * @return The debt balance of the user since the last burn/mint action\n     **/\n    function _calcTotalSupply(uint256 avgRate)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 principalSupply = super.totalSupply();\n\n        if (principalSupply == 0) {\n            return 0;\n        }\n\n        uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\n            avgRate,\n            _totalSupplyTimestamp\n        );\n\n        return principalSupply.rayMul(cumulatedInterest);\n    }\n\n    function _getUnderlyingAssetAddress()\n        internal\n        view\n        override\n        returns (address)\n    {\n        return underlyingAsset;\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return DEBT_TOKEN_REVISION;\n    }\n\n    function getAggregateOptimalRepaymentRate(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        DataTypes.BorrowData storage bd = _borrowData[_user];\n        uint256 stableRate = _usersStableRate[_user];\n        uint256 aggregateOptimalRepaymentRate;\n        for (uint256 i = 0; i < bd.drawDownNumber; i++) {\n            DataTypes.DrawDown storage drawDone = bd.drawDowns[i];\n            uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\n                stableRate,\n                drawDone.timestamp\n            );\n            uint256 cumulatedBalance = drawDone.amount.rayMul(\n                cumulatedInterest\n            );\n            aggregateOptimalRepaymentRate += cumulatedBalance.rayDiv(\n                drawDone.tenure.rayMul(SECONDS_PER_DAY * WadRayMath.ray())\n            );\n        }\n        return aggregateOptimalRepaymentRate;\n    }\n\n    function getAggregateActualRepaymentRate(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        DataTypes.BorrowData storage bd = _borrowData[_user];\n        uint256 aggregateActualRepayment;\n        for (uint256 i = 0; i < bd.drawDownNumber; i++) {\n            DataTypes.DrawDown storage drawDone = bd.drawDowns[i];\n            DataTypes.Repayment storage repayment = drawDone.repayment;\n            if (\n                repayment.totalPaid != 0 && block.timestamp > drawDone.timestamp\n            ) {\n                aggregateActualRepayment += repayment.totalPaid.rayDiv(\n                    (block.timestamp - drawDone.timestamp) * WadRayMath.ray()\n                );\n            }\n        }\n        return aggregateActualRepayment;\n    }\n\n    struct MintLocalVars {\n        uint256 previousSupply;\n        uint256 nextSupply;\n        uint256 amountInRay;\n        uint256 currentStableRate;\n        uint256 nextStableRate;\n        uint256 currentAvgStableRate;\n    }\n\n    function mint(\n        address _user,\n        uint256 _amount,\n        uint256 _tenure,\n        uint256 _rate\n    ) external override onlyLoanManager {\n        MintLocalVars memory vars;\n\n        (\n            ,\n            uint256 currentBalance,\n            uint256 balanceIncrease\n        ) = _calculateBalanceIncrease(_user);\n\n        vars.previousSupply = totalSupply();\n        vars.currentAvgStableRate = _avgStableRate;\n        vars.nextSupply = _totalSupply = vars.previousSupply + _amount;\n\n        vars.amountInRay = _amount.wadToRay();\n        vars.currentStableRate = _usersStableRate[_user];\n\n        DataTypes.BorrowData storage bd = _borrowData[_user];\n        uint256 currentDrawDownNumber = bd.drawDownNumber;\n        bd.drawDowns[currentDrawDownNumber].amount = _amount;\n        bd.drawDowns[currentDrawDownNumber].tenure = _tenure;\n        bd.drawDowns[currentDrawDownNumber].borrowRate = _rate;\n        bd.drawDowns[currentDrawDownNumber].timestamp = uint40(block.timestamp);\n        bd.drawDownNumber++;\n\n        vars.nextStableRate = (vars.currentStableRate.rayMul(\n            currentBalance.wadToRay()\n        ) + vars.amountInRay.rayMul(_rate)).rayDiv(\n                (currentBalance + _amount).wadToRay()\n            );\n\n        _usersStableRate[_user] = vars.nextStableRate.toUint128();\n\n        _totalSupplyTimestamp = uint40(block.timestamp);\n\n        // Calculates the updated average stable rate\n        vars.currentAvgStableRate = _avgStableRate = (\n            (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +\n                _rate.rayMul(vars.amountInRay)).rayDiv(\n                    vars.nextSupply.wadToRay()\n                )\n        ).toUint128();\n        _mint(_user);\n        emit Mint(\n            _user,\n            _amount,\n            currentBalance,\n            balanceIncrease,\n            vars.nextStableRate,\n            vars.currentAvgStableRate,\n            vars.nextSupply\n        );\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _calcTotalSupply(_avgStableRate);\n    }\n\n    function getTotalSupplyLastUpdated() external view returns (uint40) {\n        return _totalSupplyTimestamp;\n    }\n\n    function underlyingAssetAddress() external view returns (address) {\n        return underlyingAsset;\n    }\n\n    /**\n     * @dev Calculates the increase in balance since the last user interaction\n     * @param _user The address of the user for which the\n     * @return The previous principal balance\n     * @return The new principal balance\n     * @return The balance increase\n     **/\n    function _calculateBalanceIncrease(address _user)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 principal = principalOf(_user);\n        if (principal == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 newPrincipalBalance = balanceOf(_user);\n        return (\n            principal,\n            newPrincipalBalance,\n            newPrincipalBalance - principal\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IVault {\n    function depositSecurity(\n        address _sponsor,\n        address _reserve,\n        uint256 _amount\n    ) external payable;\n\n    function redeemSecurity(\n        address payable _sponsor,\n        address _reserve,\n        uint256 _amount\n    ) external payable;\n\n    function increaseTotalDebt(uint256 _amount) external;\n}\n"
    },
    "contracts/component/liquiditymanager/ReserveManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../Voyager.sol';\nimport '../../libraries/helpers/Errors.sol';\nimport 'openzeppelin-solidity/contracts/utils/Address.sol';\nimport '../shared/storage/LiquidityManagerStorage.sol';\nimport '../infra/AddressResolver.sol';\nimport '../../libraries/proxy/Proxyable.sol';\nimport '../../libraries/logic/ReserveLogic.sol';\nimport '../../interfaces/IReserveManager.sol';\nimport '../../interfaces/IVoyagerComponent.sol';\nimport '../../interfaces/IDebtToken.sol';\nimport '../../interfaces/IACLManager.sol';\nimport '../shared/escrow/LiquidityDepositEscrow.sol';\n\nabstract contract ReserveManager is\n    Proxyable,\n    IReserveManager,\n    IVoyagerComponent\n{\n    constructor(address payable _proxy, address _voyager) Proxyable(_proxy) {\n        voyager = Voyager(_voyager);\n    }\n\n    modifier onlyAdmin() {\n        _requireCallerAdmin();\n        _;\n    }\n\n    /************************************** HouseKeeping Functions **************************************/\n\n    /**\n     * @dev Pause the protocol\n     **/\n    function pause() external onlyProxy onlyAdmin {\n        LiquidityManagerStorage(liquidityManagerStorageAddress()).pause();\n    }\n\n    /**\n     * @dev UnPause the protocol\n     **/\n    function unPause() external onlyProxy onlyAdmin {\n        LiquidityManagerStorage(liquidityManagerStorageAddress()).unPause();\n    }\n\n    /**\n     * @dev Initializes a reserve, activating it, assigning two deposit tokens and an interest rate strategy\n     * Only callable by protocol operator\n     * @param _asset The address of the underlying asset of the reserve\n     * @param _juniorDepositTokenAddress The address of the junior deposit token that will be assigned to the reserve\n     * @param _seniorDepositTokenAddress The address of the senior deposit token that will be assigned to the reserve\n     * @param _juniorIncomeAllocation Junior income allocation, express in RAY\n     * @param _seniorIncomeAllocation Senior income allocation, express in RAY\n     * @param _stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n     * @param _interestRateStrategyAddress The address of the interest rate strategy contract\n     **/\n    function initReserve(\n        address _asset,\n        address _juniorDepositTokenAddress,\n        address _seniorDepositTokenAddress,\n        uint256 _juniorIncomeAllocation,\n        uint256 _seniorIncomeAllocation,\n        address _stableDebtAddress,\n        address _interestRateStrategyAddress,\n        address _healthStrategyAddress\n    ) external onlyProxy onlyAdmin {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        LiquidityManagerStorage(liquidityManagerStorageAddress()).initReserve(\n            _asset,\n            _juniorDepositTokenAddress,\n            _seniorDepositTokenAddress,\n            _juniorIncomeAllocation,\n            _seniorIncomeAllocation,\n            _stableDebtAddress,\n            _interestRateStrategyAddress,\n            _healthStrategyAddress\n        );\n        proxy._emit(\n            abi.encode(\n                _juniorDepositTokenAddress,\n                _seniorDepositTokenAddress,\n                _juniorIncomeAllocation,\n                _seniorIncomeAllocation,\n                _stableDebtAddress,\n                _interestRateStrategyAddress,\n                _healthStrategyAddress\n            ),\n            2,\n            keccak256(\n                'ReverseInited(address, address,address, uint256, uint256,address,address,address)'\n            ),\n            bytes32(abi.encodePacked(_asset)),\n            0,\n            0\n        );\n    }\n\n    /**\n     * @dev Active a reserve for borrowing\n     * @param _asset The address of the reserve\n     **/\n    function activeReserve(address _asset) external onlyProxy onlyAdmin {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        LiquidityManagerStorage(liquidityManagerStorageAddress()).activeReserve(\n                _asset\n            );\n    }\n\n    /************************************** View Functions **************************************/\n\n    function getReserveData(address _asset)\n        public\n        view\n        returns (DataTypes.ReserveData memory)\n    {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        return\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\n                .getReserveData(_asset);\n    }\n\n    function getConfiguration(address _asset)\n        public\n        view\n        returns (DataTypes.ReserveConfigurationMap memory)\n    {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        return\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\n                .getConfiguration(_asset);\n    }\n\n    function getFlags(address _asset)\n        public\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        return\n            LiquidityManagerStorage(liquidityManagerStorageAddress()).getFlags(\n                _asset\n            );\n    }\n\n    function getLiquidityRate(address _asset, ReserveLogic.Tranche _tranche)\n        public\n        view\n        returns (uint256)\n    {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        return\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\n                .getLiquidityRate(_asset, _tranche);\n    }\n\n    function getJuniorLiquidityIndex(address _asset)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\n                .getJuniorLiquidityIndex(_asset);\n    }\n\n    function getSeniorLiquidityIndex(address _asset)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            LiquidityManagerStorage(liquidityManagerStorageAddress())\n                .getSeniorLiquidityIndex(_asset);\n    }\n\n    /************************************** Private Functions **************************************/\n\n    function _requireCallerAdmin() internal {\n        Voyager v = Voyager(voyager);\n        IACLManager aclManager = IACLManager(\n            v.addressResolver().getAddress(v.getACLManagerName())\n        );\n        require(\n            aclManager.isLiquidityManager(messageSender),\n            'Not vault admin'\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IReserveManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../libraries/logic/ReserveLogic.sol';\n\ninterface IReserveManager {\n    function initReserve(\n        address _asset,\n        address _juniorDepositTokenAddress,\n        address _seniorDepositTokenAddress,\n        uint256 _juniorIncomeAllocation,\n        uint256 _seniorIncomeAllocation,\n        address _stableDebtAddress,\n        address _interestRateStrategyAddress,\n        address _healthStrategyAddress\n    ) external;\n\n    function activeReserve(address _asset) external;\n\n    function getReserveData(address _asset)\n        external\n        view\n        returns (DataTypes.ReserveData memory);\n\n    function getConfiguration(address _asset)\n        external\n        view\n        returns (DataTypes.ReserveConfigurationMap memory);\n\n    function getFlags(address _asset)\n        external\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        );\n\n    function getLiquidityRate(address _reserve, ReserveLogic.Tranche _tranche)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../libraries/logic/ReserveLogic.sol';\n\ninterface ILiquidityManager {\n    function getReserveNormalizedIncome(\n        address _asset,\n        ReserveLogic.Tranche _tranche\n    ) external view returns (uint256);\n\n    function getEscrowAddress() external view returns (address);\n\n    function deposit(\n        address _asset,\n        ReserveLogic.Tranche _tranche,\n        uint256 _amount,\n        address _user,\n        address _onBehalfOf\n    ) external;\n}\n"
    },
    "contracts/tokenization/JuniorDepositToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../contracts/component/liquiditymanager/LiquidityManagerProxy.sol';\nimport '../libraries/helpers/Errors.sol';\nimport './IInitializableDepositToken.sol';\nimport '../interfaces/ILiquidityManagerProxy.sol';\nimport './BaseERC20.sol';\nimport 'openzeppelin-solidity/contracts/utils/Context.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '../libraries/math/WadRayMath.sol';\nimport '../libraries/logic/ReserveLogic.sol';\nimport '../component/infra/AddressResolver.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\n\ncontract JuniorDepositToken is\n    Context,\n    IInitializableDepositToken,\n    BaseERC20('JuniorDepositToken_IMPL', 'JuniorDepositToken_IMPL', 0)\n{\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    AddressResolver internal addressResolver;\n    address internal underlyingAsset;\n\n    uint256 public constant JUNIOR_DEPOSIT_TOKEN_REVISION = 0x1;\n\n    modifier onlyLiquidityManagerProxy() {\n        require(\n            _msgSender() == addressResolver.getAddress('liquidityManager'),\n            Errors.CT_CALLER_MUST_BE_LIQUIDITY_MANAGER_POOL\n        );\n        _;\n    }\n\n    /**\n     * @dev Initializes the JuniorDepositToken\n     * @param _addressResolver The address of the AddressResolver\n     * @param _underlyingAsset The address of the underlying asset of this JuniorDepositToken\n     * @param _juniorDepositTokenDecimals The decimals of the JuniorDepositToken, same as the underlying asset's\n     * @param _juniorDepositTokenName The name of the JuniorDepositToken\n     * @param _juniorDepositTokenSymbol The symbol of the JuniorDepositToken\n     **/\n    function initialize(\n        AddressResolver _addressResolver,\n        address _underlyingAsset,\n        uint8 _juniorDepositTokenDecimals,\n        string calldata _juniorDepositTokenName,\n        string calldata _juniorDepositTokenSymbol,\n        bytes calldata _params\n    ) external initializer {\n        _setName(_juniorDepositTokenName);\n        _setSymbol(_juniorDepositTokenSymbol);\n        _setDecimals(_juniorDepositTokenDecimals);\n\n        addressResolver = _addressResolver;\n        underlyingAsset = _underlyingAsset;\n\n        emit Initialized(\n            _underlyingAsset,\n            addressResolver.getAddress('liquidityManager'),\n            _juniorDepositTokenDecimals,\n            _juniorDepositTokenName,\n            _juniorDepositTokenSymbol,\n            _params\n        );\n    }\n\n    /**\n     * @dev Mints `_amount` junior deposit token to `_user`\n     * @param _user The address receiving the minted tokens\n     * @param _amount The amount of tokens getting minted\n     * @param _index The new liquidity index of the reserve\n     * @return `true` if the previous balance of the user was 0\n     **/\n    function mint(\n        address _user,\n        uint256 _amount,\n        uint256 _index\n    ) external onlyLiquidityManagerProxy returns (bool) {\n        uint256 previousBalance = super.balanceOf(_user);\n        uint256 amountScaled = _amount.rayDiv(_index);\n        require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n        _mint(_user, amountScaled);\n        emit Transfer(address(0), _user, _amount);\n        emit Mint(_user, _amount, _index);\n\n        return previousBalance == 0;\n    }\n\n    /**\n     * @dev Burns JuniorDepositToken from `_user` and sends the equivalent amount of underlying to `_receiverOfUnderlying`\n     * - Only callable by the LiquidityManagerProxy, as extra state updates there need to the managed\n     * @param _user The owner of the JuniorDepositToken, getting them burned\n     * @param _receiverOfUnderlying The address that will receive the underlying\n     * @param _amount The amount being burned\n     * @param _index The new liquidity index of the reserve\n     **/\n    function burn(\n        address _user,\n        address _receiverOfUnderlying,\n        uint256 _amount,\n        uint256 _index\n    ) external onlyLiquidityManagerProxy {\n        uint256 amountScaled = _amount.rayDiv(_index);\n        require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n        _burn(_user, amountScaled);\n        IERC20(underlyingAsset).safeTransfer(_receiverOfUnderlying, _amount);\n        emit Transfer(_user, address(0), _amount);\n        emit Burn(_user, _receiverOfUnderlying, _amount, _index);\n    }\n\n    /**\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the updated\n     * stored balance divided by the reserve's liquidity index at the moment of the update\n     * @param _user The user whose balance is calculated\n     * @return THe scaled balance of the user\n     **/\n    function scaledBalanceOf(address _user) external view returns (uint256) {\n        return super.balanceOf(_user);\n    }\n\n    /**\n     * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n     * @param _user The user whose balance is calculated\n     * @return The balance of the user\n     **/\n    function balanceOf(address _user)\n        public\n        view\n        override(BaseERC20)\n        returns (uint256)\n    {\n        ILiquidityManagerProxy liquidityManagerProxy = getLiquidityManagerProxy();\n        return\n            super.balanceOf(_user).rayMul(\n                liquidityManagerProxy.getReserveNormalizedIncome(\n                    underlyingAsset,\n                    ReserveLogic.Tranche.JUNIOR\n                )\n            );\n    }\n\n    /**\n     * @dev calculates the total supply of the specific junior deposit token\n     * since the balance of every single user increases over time, the totally supply does that too.\n     * @return the current total supply\n     **/\n    function totalSupply() public view override(BaseERC20) returns (uint256) {\n        uint256 currentSupplyScaled = super.totalSupply();\n        if (currentSupplyScaled == 0) {\n            return 0;\n        }\n        ILiquidityManagerProxy liquidityManagerProxy = getLiquidityManagerProxy();\n\n        return\n            currentSupplyScaled.rayMul(\n                liquidityManagerProxy.getLiquidityRate(\n                    underlyingAsset,\n                    ReserveLogic.Tranche.JUNIOR\n                )\n            );\n    }\n\n    function scaledTotalSupply() public view returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /**\n     * @dev Return instance of ILiquidityManagerProxy\n     **/\n    function getLiquidityManagerProxy()\n        internal\n        view\n        returns (ILiquidityManagerProxy)\n    {\n        address liquidityManagerProxyAddress = addressResolver.getAddress(\n            'liquidityManagerProxy'\n        );\n        return ILiquidityManagerProxy(liquidityManagerProxyAddress);\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return JUNIOR_DEPOSIT_TOKEN_REVISION;\n    }\n}\n"
    },
    "contracts/tokenization/SeniorDepositToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../contracts/component/liquiditymanager/LiquidityManagerProxy.sol';\nimport '../libraries/helpers/Errors.sol';\nimport './IInitializableDepositToken.sol';\nimport '../interfaces/ILiquidityManagerProxy.sol';\nimport './BaseERC20.sol';\nimport 'openzeppelin-solidity/contracts/utils/Context.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '../libraries/math/WadRayMath.sol';\nimport '../libraries/logic/ReserveLogic.sol';\nimport '../component/infra/AddressResolver.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\n\ncontract SeniorDepositToken is\n    Context,\n    IInitializableDepositToken,\n    BaseERC20('SeniorDepositToken_IMPL', 'SeniorDepositToken_IMPL', 0)\n{\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    AddressResolver internal addressResolver;\n    address internal underlyingAsset;\n\n    uint256 public constant SENIOR_DEPOSIT_TOKEN_REVISION = 0x1;\n\n    modifier onlyLiquidityManagerProxy() {\n        require(\n            _msgSender() == addressResolver.getAddress('liquidityManager'),\n            Errors.CT_CALLER_MUST_BE_LIQUIDITY_MANAGER_POOL\n        );\n        _;\n    }\n\n    /**\n     * @dev Initializes the JuniorDepositToken\n     * @param _addressResolver The address of the AddressResolver\n     * @param _underlyingAsset The address of the underlying asset of this SeniorDepositToken\n     * @param _seniorDepositTokenDecimals The decimals of the SeniorDepositToken, same as the underlying asset's\n     * @param _seniorDepositTokenName The name of the SeniorDepositToken\n     * @param _seniorDepositTokenSymbol The symbol of the SeniorDepositToken\n     **/\n    function initialize(\n        AddressResolver _addressResolver,\n        address _underlyingAsset,\n        uint8 _seniorDepositTokenDecimals,\n        string calldata _seniorDepositTokenName,\n        string calldata _seniorDepositTokenSymbol,\n        bytes calldata _params\n    ) external initializer {\n        _setName(_seniorDepositTokenName);\n        _setSymbol(_seniorDepositTokenSymbol);\n        _setDecimals(_seniorDepositTokenDecimals);\n\n        addressResolver = _addressResolver;\n        underlyingAsset = _underlyingAsset;\n\n        emit Initialized(\n            _underlyingAsset,\n            addressResolver.getAddress('liquidityManager'),\n            _seniorDepositTokenDecimals,\n            _seniorDepositTokenName,\n            _seniorDepositTokenSymbol,\n            _params\n        );\n    }\n\n    /**\n     * @dev Mints `_amount` junior deposit token to `_user`\n     * @param _user The address receiving the minted tokens\n     * @param _amount The amount of tokens getting minted\n     * @param _index The new liquidity index of the reserve\n     * @return `true` if the previous balance of the user was 0\n     **/\n    function mint(\n        address _user,\n        uint256 _amount,\n        uint256 _index\n    ) external onlyLiquidityManagerProxy returns (bool) {\n        uint256 previousBalance = super.balanceOf(_user);\n        uint256 amountScaled = _amount.rayDiv(_index);\n        require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n        _mint(_user, amountScaled);\n        emit Transfer(address(0), _user, _amount);\n        emit Mint(_user, _amount, _index);\n\n        return previousBalance == 0;\n    }\n\n    /**\n     * @dev Burns JuniorDepositToken from `_user` and sends the equivalent amount of underlying to `_receiverOfUnderlying`\n     * - Only callable by the LiquidityManagerProxy, as extra state updates there need to the managed\n     * @param _user The owner of the JuniorDepositToken, getting them burned\n     * @param _receiverOfUnderlying The address that will receive the underlying\n     * @param _amount The amount being burned\n     * @param _index The new liquidity index of the reserve\n     **/\n    function burn(\n        address _user,\n        address _receiverOfUnderlying,\n        uint256 _amount,\n        uint256 _index\n    ) external onlyLiquidityManagerProxy {\n        uint256 amountScaled = _amount.rayDiv(_index);\n        require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n        _burn(_user, amountScaled);\n        IERC20(underlyingAsset).safeTransfer(_receiverOfUnderlying, _amount);\n        emit Transfer(_user, address(0), _amount);\n        emit Burn(_user, _receiverOfUnderlying, _amount, _index);\n    }\n\n    /**\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the updated\n     * stored balance divided by the reserve's liquidity index at the moment of the update\n     * @param _user The user whose balance is calculated\n     * @return THe scaled balance of the user\n     **/\n    function scaledBalanceOf(address _user) external view returns (uint256) {\n        return super.balanceOf(_user);\n    }\n\n    /**\n     * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n     * @param _user The user whose balance is calculated\n     * @return The balance of the user\n     **/\n    function balanceOf(address _user)\n        public\n        view\n        override(BaseERC20)\n        returns (uint256)\n    {\n        ILiquidityManagerProxy liquidityManagerProxy = getLiquidityManagerProxy();\n        return\n            super.balanceOf(_user).rayMul(\n                liquidityManagerProxy.getReserveNormalizedIncome(\n                    underlyingAsset,\n                    ReserveLogic.Tranche.SENIOR\n                )\n            );\n    }\n\n    /**\n     * @dev calculates the total supply of the specific junior deposit token\n     * since the balance of every single user increases over time, the totally supply does that too.\n     * @return the current total supply\n     **/\n    function totalSupply() public view override(BaseERC20) returns (uint256) {\n        uint256 currentSupplyScaled = super.totalSupply();\n        if (currentSupplyScaled == 0) {\n            return 0;\n        }\n        ILiquidityManagerProxy liquidityManagerProxy = getLiquidityManagerProxy();\n\n        return\n            currentSupplyScaled.rayMul(\n                liquidityManagerProxy.getLiquidityRate(\n                    underlyingAsset,\n                    ReserveLogic.Tranche.SENIOR\n                )\n            );\n    }\n\n    function scaledTotalSupply() public view returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /**\n     * @dev Return instance of ILiquidityManagerProxy\n     **/\n    function getLiquidityManagerProxy()\n        internal\n        view\n        returns (ILiquidityManagerProxy)\n    {\n        address liquidityManagerProxyAddress = addressResolver.getAddress(\n            'liquidityManagerProxy'\n        );\n        return ILiquidityManagerProxy(liquidityManagerProxyAddress);\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return SENIOR_DEPOSIT_TOKEN_REVISION;\n    }\n}\n"
    },
    "contracts/component/shared/storage/LiquidityManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../../libraries/state/State.sol';\nimport '../../../libraries/types/DataTypes.sol';\nimport '../../../libraries/logic/ReserveLogic.sol';\nimport '../../../libraries/logic/ValidationLogic.sol';\nimport '../../../libraries/configuration/ReserveConfiguration.sol';\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\n\ncontract LiquidityManagerStorage is State {\n    using ReserveLogic for DataTypes.ReserveData;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using SafeMath for uint256;\n\n    mapping(address => DataTypes.ReserveData) internal _reserves;\n\n    bool internal _paused;\n    uint256 public juniorDepositAmount;\n    uint256 public seniorDepositAmount;\n    uint256 public totalDebt;\n\n    constructor(address _liquidityManager) State(_liquidityManager) {}\n\n    function initReserve(\n        address _asset,\n        address _juniorDepositTokenAddress,\n        address _seniorDepositTokenAddress,\n        uint256 _juniorIncomeAllocation,\n        uint256 _seniorIncomeAllocation,\n        address _stableDebtAddress,\n        address _interestRateStrategyAddress,\n        address _healthStrategyAddress\n    ) external onlyAssociatedContract {\n        _reserves[_asset].init(\n            _juniorDepositTokenAddress,\n            _seniorDepositTokenAddress,\n            _juniorIncomeAllocation,\n            _seniorIncomeAllocation,\n            _stableDebtAddress,\n            _interestRateStrategyAddress,\n            _healthStrategyAddress\n        );\n    }\n\n    function updateStateOnDeposit(\n        address _asset,\n        ReserveLogic.Tranche _tranche,\n        uint256 _amount\n    ) public onlyAssociatedContract {\n        DataTypes.ReserveData storage reserve = _reserves[_asset];\n        ValidationLogic.validateDeposit(reserve, _amount);\n        reserve.updateState(_tranche);\n        if (ReserveLogic.Tranche.JUNIOR == _tranche) {\n            reserve.updateInterestRates(_asset, _amount, 0, 0, 0);\n        } else {\n            reserve.updateInterestRates(_asset, 0, 0, _amount, 0);\n        }\n    }\n\n    function updateStateOnBorrow(address _asset, uint256 _amount)\n        public\n        onlyAssociatedContract\n    {\n        DataTypes.ReserveData storage reserve = _reserves[_asset];\n        reserve.updateState(ReserveLogic.Tranche.SENIOR);\n        reserve.updateInterestRates(_asset, 0, 0, 0, _amount);\n    }\n\n    function activeReserve(address _asset) public onlyAssociatedContract {\n        DataTypes.ReserveConfigurationMap\n            memory currentConfig = getConfiguration(_asset);\n        currentConfig.setActive(true);\n        setConfiguration(_asset, currentConfig.data);\n    }\n\n    function pause() public onlyAssociatedContract {\n        _paused = true;\n    }\n\n    function unPause() public onlyAssociatedContract {\n        _paused = false;\n    }\n\n    function increaseJuniorDeposit(uint256 _amount)\n        public\n        onlyAssociatedContract\n    {\n        juniorDepositAmount += _amount;\n    }\n\n    function increaseSeniorDeposit(uint256 _amount)\n        public\n        onlyAssociatedContract\n    {\n        seniorDepositAmount += _amount;\n    }\n\n    function decreaseJuniorDeposit(uint256 _amount)\n        public\n        onlyAssociatedContract\n    {\n        juniorDepositAmount -= _amount;\n    }\n\n    function decreaseSeniorDeposit(uint256 _amount)\n        public\n        onlyAssociatedContract\n    {\n        seniorDepositAmount -= _amount;\n    }\n\n    function increaseTotalDebt(uint256 _amount) public onlyAssociatedContract {\n        totalDebt += _amount;\n    }\n\n    /*********************************************** View functions ***********************************************/\n\n    function getFlags(address _asset)\n        public\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        DataTypes.ReserveConfigurationMap\n            memory currentConfig = getConfiguration(_asset);\n        return currentConfig.getFlags();\n    }\n\n    function getReserveData(address _asset)\n        public\n        view\n        returns (DataTypes.ReserveData memory)\n    {\n        return _reserves[_asset];\n    }\n\n    function getConfiguration(address _asset)\n        public\n        view\n        returns (DataTypes.ReserveConfigurationMap memory)\n    {\n        return _reserves[_asset].configuration;\n    }\n\n    function setConfiguration(address _asset, uint256 configuration) internal {\n        _reserves[_asset].configuration.data = configuration;\n    }\n\n    function getLiquidityRate(address _asset, ReserveLogic.Tranche _tranche)\n        public\n        view\n        returns (uint256)\n    {\n        return _reserves[_asset].getLiquidityRate(_tranche);\n    }\n\n    function getJuniorLiquidityIndex(address _asset)\n        public\n        view\n        returns (uint256)\n    {\n        return _reserves[_asset].juniorLiquidityIndex;\n    }\n\n    function getSeniorLiquidityIndex(address _asset)\n        public\n        view\n        returns (uint256)\n    {\n        return _reserves[_asset].seniorLiquidityIndex;\n    }\n\n    function getReserveNormalizedIncome(\n        address _asset,\n        ReserveLogic.Tranche _tranche\n    ) public view returns (uint256) {\n        return _reserves[_asset].getNormalizedIncome(_tranche);\n    }\n\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    function getDepositAndDebt()\n        public\n        view\n        returns (DataTypes.DepositAndDebt memory)\n    {\n        DataTypes.DepositAndDebt memory res;\n        res.juniorDepositAmount = juniorDepositAmount;\n        res.seniorDepositAmount = seniorDepositAmount;\n        res.totalDebt = totalDebt;\n        return res;\n    }\n}\n"
    },
    "contracts/interfaces/IVoyagerComponent.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../component/Voyager.sol';\nimport '../component/infra/AddressResolver.sol';\nimport '../component/shared/storage/LiquidityManagerStorage.sol';\nimport '../component/shared/escrow/LiquidityDepositEscrow.sol';\nimport '../libraries/types/DataTypes.sol';\n\nabstract contract IVoyagerComponent {\n    Voyager public voyager;\n\n    modifier requireNotPaused() {\n        _whenNotPaused();\n        _;\n    }\n\n    function liquidityManagerStorageAddress() internal view returns (address) {\n        return\n            AddressResolver(voyager.getAddressResolverAddress()).getAddress(\n                voyager.getLiquidityManagerStorageName()\n            );\n    }\n\n    function _whenNotPaused() internal view {\n        require(!paused(), Errors.LP_IS_PAUSED);\n    }\n\n    function paused() internal view returns (bool) {\n        address storageAddress = liquidityManagerStorageAddress();\n        return LiquidityManagerStorage(storageAddress).paused();\n    }\n\n    function getDepositAndDebt()\n        public\n        view\n        returns (DataTypes.DepositAndDebt memory)\n    {\n        address storageAddress = liquidityManagerStorageAddress();\n        return LiquidityManagerStorage(storageAddress).getDepositAndDebt();\n    }\n\n    function escrow() internal view virtual returns (LiquidityDepositEscrow);\n}\n"
    },
    "contracts/interfaces/IMessageBus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../libraries/types/DataTypes.sol';\n\ninterface IMessageBus {\n    function getAddressResolverAddress() external view returns (address);\n\n    function getVault(address _user) external view returns (address);\n\n    function getMaxSecurityDeposit(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getSecurityDepositRequirement(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getReserveData(address _asset)\n        external\n        view\n        returns (DataTypes.ReserveData memory);\n\n    function getSecurityDeposit(address _user, address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getCompoundedDebt(address _user) external view returns (uint256);\n\n    function getAggregateOptimalRepaymentRate(address _user)\n        external\n        view\n        returns (uint256);\n\n    function getAggregateActualRepaymentRate(address _user)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/component/liquiditymanager/LiquidityManagerProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../libraries/proxy/Proxy.sol';\nimport '../../interfaces/IReserveManager.sol';\nimport '../../interfaces/ILiquidityManager.sol';\nimport '../../libraries/logic/ReserveLogic.sol';\n\ncontract LiquidityManagerProxy is Proxy {\n    function getLiquidityRate(address _reserve, ReserveLogic.Tranche _tranche)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            IReserveManager(address(target)).getLiquidityRate(\n                _reserve,\n                _tranche\n            );\n    }\n\n    function getReserveData(address _reserve)\n        external\n        view\n        returns (DataTypes.ReserveData memory)\n    {\n        return IReserveManager(address(target)).getReserveData(_reserve);\n    }\n\n    function getConfiguration(address _reserve)\n        external\n        view\n        returns (DataTypes.ReserveConfigurationMap memory)\n    {\n        return IReserveManager(address(target)).getConfiguration(_reserve);\n    }\n\n    function getFlags(address _asset)\n        external\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        return IReserveManager(address(target)).getFlags(_asset);\n    }\n\n    function getReserveNormalizedIncome(\n        address _asset,\n        ReserveLogic.Tranche _tranche\n    ) external view returns (uint256) {\n        return\n            ILiquidityManager(address(target)).getReserveNormalizedIncome(\n                _asset,\n                _tranche\n            );\n    }\n\n    function getEscrowAddress() external view returns (address) {\n        return ILiquidityManager(address(target)).getEscrowAddress();\n    }\n}\n"
    },
    "contracts/tokenization/IInitializableDepositToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\n/**\n * @title IDepositToken\n * @notice Interface for the initialize function on JuniorDepositToken and SeniorDepositToken\n **/\nabstract contract IInitializableDepositToken {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    uint256 private lastInitializedRevision = 0;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        uint256 revision = getRevision();\n        require(\n            initializing ||\n                isConstructor() ||\n                revision > lastInitializedRevision,\n            'Contract instance has already been initialized'\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            lastInitializedRevision = revision;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /**\n     * @dev returns the revision number of the contract\n     * Needs to be defined in the inherited class as a constant.\n     **/\n    function getRevision() internal pure virtual returns (uint256);\n\n    /**\n     * @dev Emitted when an depositToken is initialized\n     * @param underlyingAsset The address of the underlying asset\n     * @param liquidityManagerProxy The address of the associated liquidity manager proxy\n     * @param tokenDecimals the decimals of the underlying\n     * @param tokenName the name of the depositToken\n     * @param tokenSymbol the symbol of the depositToken\n     * @param params A set of encoded parameters for additional initialization\n     **/\n    event Initialized(\n        address indexed underlyingAsset,\n        address indexed liquidityManagerProxy,\n        uint8 tokenDecimals,\n        string tokenName,\n        string tokenSymbol,\n        bytes params\n    );\n\n    /**\n     * @dev Emitted after the mint action\n     * @param from The address performing the mint\n     * @param value The amount being\n     * @param index The new liquidity index of the reserve\n     **/\n    event Mint(address indexed from, uint256 value, uint256 index);\n\n    /**\n     * @dev Emitted after aTokens are burned\n     * @param from The owner of the aTokens, getting them burned\n     * @param target The address that will receive the underlying\n     * @param value The amount being burned\n     * @param index The new liquidity index of the reserve\n     **/\n    event Burn(\n        address indexed from,\n        address indexed target,\n        uint256 value,\n        uint256 index\n    );\n\n    /**\n     * @dev Returns true if the contract has been initialized\n     **/\n    function isInitialized() public view returns (bool) {\n        return !initializing && getRevision() <= lastInitializedRevision;\n    }\n\n    /**\n     * @dev Returns true if and only if the function is running in the constructor\n     **/\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address())\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/interfaces/ILiquidityManagerProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../libraries/logic/ReserveLogic.sol';\n\ninterface ILiquidityManagerProxy {\n    function getLiquidityRate(address _reserve, ReserveLogic.Tranche _tranche)\n        external\n        view\n        returns (uint256);\n\n    function getReserveData(address _reserve)\n        external\n        view\n        returns (DataTypes.ReserveData memory);\n\n    function getFlags(address _asset)\n        external\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        );\n\n    function getConfiguration(address _reserve)\n        external\n        view\n        returns (DataTypes.ReserveConfigurationMap memory);\n\n    function getReserveNormalizedIncome(\n        address _asset,\n        ReserveLogic.Tranche _tranche\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/tokenization/BaseERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\nimport 'openzeppelin-solidity/contracts/utils/Context.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract BaseERC20 is Context, IERC20, IERC20Metadata {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 internal _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 _decimals\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = _decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @return The balance of the token\n     **/\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            'ERC20: transfer amount exceeds allowance'\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            'ERC20: decreased allowance below zero'\n        );\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), 'ERC20: transfer from the zero address');\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            'ERC20: transfer amount exceeds balance'\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: mint to the zero address');\n        _beforeTokenTransfer(address(0), account, amount);\n\n        uint256 oldTotalSupply = _totalSupply;\n        _totalSupply = oldTotalSupply.add(amount);\n\n        uint256 oldAccountBalance = _balances[account];\n        _balances[account] = oldAccountBalance.add(amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: burn from the zero address');\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 oldTotalSupply = _totalSupply;\n        _totalSupply = oldTotalSupply.sub(amount);\n\n        uint256 oldAccountBalance = _balances[account];\n        _balances[account] = oldAccountBalance.sub(\n            amount,\n            'ERC20: burn amount exceeds balance'\n        );\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), 'ERC20: approve from the zero address');\n        require(spender != address(0), 'ERC20: approve to the zero address');\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _setName(string memory newName) internal {\n        _name = newName;\n    }\n\n    function _setSymbol(string memory newSymbol) internal {\n        _symbol = newSymbol;\n    }\n\n    function _setDecimals(uint8 newDecimals) internal {\n        _decimals = newDecimals;\n    }\n}\n"
    },
    "contracts/libraries/state/State.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../ownership/Ownable.sol';\n\nabstract contract State is Ownable {\n    mapping(address => bool) public associatedContracts;\n\n    constructor(address _associatedContract) {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), 'Owner must be set');\n\n        associatedContracts[_associatedContract] = true;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    event AssociatedContractUpdated(address associatedContract);\n\n    modifier onlyAssociatedContract() {\n        require(\n            associatedContracts[msg.sender],\n            'Only the associated contract can perform this action'\n        );\n        _;\n    }\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract)\n        external\n        onlyOwner\n    {\n        associatedContracts[_associatedContract] = true;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n}\n"
    },
    "contracts/libraries/logic/ValidationLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../types/DataTypes.sol';\nimport '../configuration/ReserveConfiguration.sol';\nimport '../helpers/Errors.sol';\n\nlibrary ValidationLogic {\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    /**\n     * @dev Validates a deposit token\n     * @param reserve The reserve object on which the user is depositing\n     * @param amount The amount to be deposited\n     **/\n    function validateDeposit(\n        DataTypes.ReserveData storage reserve,\n        uint256 amount\n    ) external view {\n        (bool isActive, bool isFrozen, ) = reserve.configuration.getFlags();\n        require(amount != 0, Errors.VL_INVALID_AMOUNT);\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n        require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n    }\n}\n"
    },
    "contracts/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../types/DataTypes.sol';\n\n/**\n * @title ReserveConfiguration library\n * @author Voyage\n * @notice Implements the bitmap logic to handle the reserve configuration, inspired by Aave\n **/\nlibrary ReserveConfiguration {\n    uint256 constant LIQUIDATE_BONUS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n    uint256 constant DECIMAL_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80FFFF; // prettier-ignore\n    uint256 constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFF; // prettier-ignore\n    uint256 constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFF; // prettier-ignore\n    uint256 constant BORROWING_ENABLE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFF; // prettier-ignore\n    uint256 constant RESERVED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF87FFFFFF; // prettier-ignore\n    uint256 constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA0007FFFFFFF; // prettier-ignore\n    uint256 constant LOCKUP_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80007FFFFFFFFFFF; // prettier-ignore\n\n    uint256 constant DECIMAL_MASK_BIT_POSITION = 16;\n    uint256 constant ACTIVE_MASK_BIT_POSITION = 24;\n    uint256 constant FROZEN_MASK_BIT_POSITION = 25;\n    uint256 constant BORROWING_ENABLE_MASK_POSITION = 26;\n    uint256 constant RESERVED_MASK_BIT_POSITION = 27;\n    uint256 constant RESERVE_FACTOR_MASK_BIT_POSITION = 31;\n    uint256 constant LOCKUP_PERIOD_MASK_BIT_POSITION = 47;\n\n    /**\n     * Gets the configuration flags of the reserve\n     * @param self The reserve configuration\n     * @return The state flags representing active, frozen, borrowing enabled\n     **/\n    function getFlags(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        uint256 dataLocal = self.data;\n\n        return (\n            (dataLocal & ~ACTIVE_MASK) != 0,\n            (dataLocal & ~FROZEN_MASK) != 0,\n            (dataLocal & ~BORROWING_ENABLE_MASK) != 0\n        );\n    }\n\n    /**\n     * @dev Gets the active state of the reserve\n     * @param self The reserve configuration\n     * @param active The active state\n     **/\n    function setActive(\n        DataTypes.ReserveConfigurationMap memory self,\n        bool active\n    ) internal pure {\n        self.data =\n            (self.data & ACTIVE_MASK) |\n            (uint256(active ? 1 : 0) << ACTIVE_MASK_BIT_POSITION);\n    }\n\n    function getActive(DataTypes.ReserveConfigurationMap storage self)\n        internal\n        view\n        returns (bool)\n    {\n        return (self.data & ~ACTIVE_MASK) != 0;\n    }\n}\n"
    },
    "contracts/libraries/helpers/Pausable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.9;\n\nimport '../ownership/Ownable.sol';\n\nabstract contract Pausable is Ownable {\n    uint256 public lastPauseTime;\n    bool public paused;\n\n    constructor() {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), 'Owner must be set');\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = block.timestamp;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused() {\n        require(\n            !paused,\n            'This action cannot be performed while the contract is paused'\n        );\n        _;\n    }\n}\n"
    },
    "contracts/component/staking/RewardsDistributionRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../../libraries/ownership/Ownable.sol';\n\nabstract contract RewardsDistributionRecipient is Ownable {\n    address public rewardsDistribution;\n\n    function notifyRewardAmount(uint256 reward) external virtual;\n\n    modifier onlyRewardsDistribution() {\n        require(\n            msg.sender == rewardsDistribution,\n            'Caller is not RewardsDistribution contract'\n        );\n        _;\n    }\n\n    function setRewardsDistribution(address _rewardsDistribution)\n        external\n        onlyOwner\n    {\n        rewardsDistribution = _rewardsDistribution;\n    }\n}\n"
    },
    "contracts/tokenization/DebtTokenBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport './BaseERC20.sol';\n\nabstract contract DebtTokenBase is\n    BaseERC20('DEBTTOKEN_IMPL', 'DEBTTOKEN_IMPL', 0)\n{\n    mapping(address => mapping(address => uint256)) internal _borrowAllowances;\n\n    /**\n     * @dev Being non transferrable, the debt token does not implement any of the\n     * standard ERC20 functions for transfer and allowance.\n     **/\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        recipient;\n        amount;\n        revert('TRANSFER_NOT_SUPPORTED');\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        owner;\n        spender;\n        revert('ALLOWANCE_NOT_SUPPORTED');\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        spender;\n        amount;\n        revert('APPROVAL_NOT_SUPPORTED');\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        sender;\n        recipient;\n        amount;\n        revert('TRANSFER_NOT_SUPPORTED');\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        spender;\n        addedValue;\n        revert('ALLOWANCE_NOT_SUPPORTED');\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        spender;\n        subtractedValue;\n        revert('ALLOWANCE_NOT_SUPPORTED');\n    }\n\n    function _getUnderlyingAssetAddress()\n        internal\n        view\n        virtual\n        returns (address);\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/interfaces/IInitializableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nabstract contract IInitializableDebtToken {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    uint256 private lastInitializedRevision = 0;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Emitted when a debt token is initialized\n     * @param underlyingAsset The address of the underlying asset\n     * @param debtTokenDecimals the decimals of the debt token\n     * @param debtTokenName the name of the debt token\n     * @param debtTokenSymbol the symbol of the debt token\n     * @param params A set of encoded parameters for additional initialization\n     **/\n    event Initialized(\n        address indexed underlyingAsset,\n        uint8 debtTokenDecimals,\n        string debtTokenName,\n        string debtTokenSymbol,\n        bytes params\n    );\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        uint256 revision = getRevision();\n        require(\n            initializing ||\n                isConstructor() ||\n                revision > lastInitializedRevision,\n            'Contract instance has already been initialized'\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            lastInitializedRevision = revision;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /**\n     * @dev returns the revision number of the contract\n     * Needs to be defined in the inherited class as a constant.\n     **/\n    function getRevision() internal pure virtual returns (uint256);\n\n    /**\n     * @dev Returns true if the contract has been initialized\n     **/\n    function isInitialized() public view returns (bool) {\n        return !initializing && getRevision() <= lastInitializedRevision;\n    }\n\n    // todo return value\n    function mint(\n        address _user,\n        uint256 _amount,\n        uint256 _tenure,\n        uint256 _rate\n    ) external virtual;\n\n    /**\n     * @dev Returns true if and only if the function is running in the constructor\n     **/\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address())\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/component/loan/LoanManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';\nimport '../../libraries/proxy/Proxyable.sol';\nimport '../../interfaces/IVoyagerComponent.sol';\nimport '../../libraries/helpers/Errors.sol';\nimport '../../libraries/math/WadRayMath.sol';\nimport '../../libraries/types/DataTypes.sol';\nimport '../../interfaces/IMessageBus.sol';\nimport '../../interfaces/IHealthStrategy.sol';\nimport '../../interfaces/IInitializableDebtToken.sol';\nimport '../../interfaces/IVault.sol';\nimport '../Voyager.sol';\n\ncontract LoanManager is Proxyable, IVoyagerComponent {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    LiquidityDepositEscrow public liquidityDepositEscrow;\n\n    constructor(\n        address payable _proxy,\n        address _voyager,\n        address _escrow\n    ) Proxyable(_proxy) {\n        voyager = Voyager(_voyager);\n        liquidityDepositEscrow = LiquidityDepositEscrow(_escrow);\n    }\n\n    struct ExecuteBorrowParams {\n        address asset;\n        address user;\n        uint256 amount;\n    }\n\n    function borrow(\n        address _user,\n        address _asset,\n        uint256 _amount,\n        address payable _vault,\n        uint256 _grossAssetValue\n    ) external requireNotPaused {\n        // 0. check if the user owns the vault\n        require(voyager.getVault(_user) == _vault, Errors.LOM_NOT_VAULT_OWNER);\n\n        // 1. check if pool liquidity is sufficient\n        DataTypes.DepositAndDebt memory depositAndDebt = getDepositAndDebt();\n        require(\n            depositAndDebt.seniorDepositAmount - depositAndDebt.totalDebt >=\n                _amount,\n            Errors.LOM_RESERVE_NOT_SUFFICIENT\n        );\n\n        // 2. check HF\n        DataTypes.ReserveData memory reserveData = voyager.getReserveData(\n            _asset\n        );\n        IHealthStrategy healthStrategy = IHealthStrategy(\n            reserveData.healthStrategyAddress\n        );\n        DataTypes.HealthRiskParameter memory hrp;\n        hrp.securityDeposit = voyager.getSecurityDeposit(_user, _asset);\n        hrp.currentBorrowRate = reserveData.currentBorrowRate;\n        hrp.compoundedDebt = voyager.getCompoundedDebt(_user);\n        hrp.grossAssetValue = _grossAssetValue;\n        hrp.aggregateOptimalRepaymentRate = voyager\n            .getAggregateOptimalRepaymentRate(_user);\n        hrp.aggregateActualRepaymentRate = voyager\n            .getAggregateActualRepaymentRate(_user);\n\n        uint256 hr = healthStrategy.calculateHealthRisk(hrp);\n\n        require(hr > WadRayMath.ray(), Errors.LOM_HEALTH_RISK_BELOW_ONE);\n\n        // 3. check credit limit\n        uint256 availableCreditLimit = voyager.getAvailableCredit(\n            _user,\n            _asset\n        );\n        require(\n            availableCreditLimit >= _amount,\n            Errors.LOM_CREDIT_NOT_SUFFICIENT\n        );\n\n        // 4. update liquidity index and interest rate\n        LiquidityManagerStorage lms = LiquidityManagerStorage(\n            liquidityManagerStorageAddress()\n        );\n        lms.updateStateOnBorrow(_asset, _amount);\n\n        // 5. increase vault debt\n        IVault(_vault).increaseTotalDebt(_amount);\n\n        // 6. mint debt token and transfer underlying token\n        address debtToken = voyager.addressResolver().getAddress(\n            voyager.getStableDebtTokenName()\n        );\n        IInitializableDebtToken(debtToken).mint(\n            _user,\n            _amount,\n            healthStrategy.getLoanTenure(),\n            reserveData.currentBorrowRate\n        );\n\n        liquidityDepositEscrow.transfer(_asset, _vault, _amount);\n    }\n\n    function _executeBorrow(ExecuteBorrowParams memory vars) internal {}\n\n    function escrow() internal view override returns (LiquidityDepositEscrow) {\n        return liquidityDepositEscrow;\n    }\n}\n"
    },
    "contracts/interfaces/IHealthStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../libraries/types/DataTypes.sol';\n\ninterface IHealthStrategy {\n    function getPremiumFactor() external view returns (uint256);\n\n    function getLoanTenure() external view returns (uint256);\n\n    function getWightedLTV() external view returns (uint256);\n\n    function getWeightedRepaymentRatio() external view returns (uint256);\n\n    function calculateHealthRisk(DataTypes.HealthRiskParameter memory)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/misc/VoyageProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../libraries/types/DataTypes.sol';\nimport '../interfaces/IAddressResolver.sol';\n\ncontract VoyageProtocolDataProvider {\n    IAddressResolver public addressResolver;\n\n    constructor(IAddressResolver _addressResolver) {\n        addressResolver = _addressResolver;\n    }\n\n    function getPoolTokens()\n        external\n        view\n        returns (DataTypes.FungibleTokenData[] memory tokens)\n    {\n        DataTypes.FungibleTokenData[]\n            memory reserves = new DataTypes.FungibleTokenData[](1);\n        return reserves;\n    }\n}\n"
    },
    "contracts/misc/IVoyageDataProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport '../libraries/types/DataTypes.sol';\n\ninterface IVoyageDataProvider {\n    function getPoolTokens()\n        external\n        view\n        returns (DataTypes.FungibleTokenData[] memory tokens);\n\n    function getPoolData(address underlyingAsset)\n        external\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 juniorLiquidity,\n            uint256 seniorLiquidity,\n            uint256 juniorLiquidityRate,\n            uint256 seniorLiquidityRate,\n            uint256 totalDebt,\n            uint256 borrowRate,\n            uint256 trancheRatio\n        );\n\n    function getPoolConfiguration(address underlyingAsset)\n        external\n        view\n        returns (\n            uint256 securityRequirement,\n            uint256 minSecurity,\n            uint256 maxSecurity,\n            uint256 loanTenure,\n            uint256 optimalTrancheRatio,\n            uint256 optimalIncomeRatio,\n            bool isActive\n        );\n\n    function userPoolData(address underlyingAsset, address user)\n        external\n        view\n        returns (uint256 juniorTrancheBalance, uint256 seniorTrancheBalance);\n\n    function getVaults()\n        external\n        view\n        returns (address[] memory vaultAddresses);\n\n    /**\n     * @notice get the address of vault managed by this address\n     * @param user address\n     * @return vaultAddress the vault address. if no vault exists for this address, returns 0x0\n     **/\n    function getUserVaults(address user)\n        external\n        view\n        returns (address vaultAddress);\n\n    /**\n     * @notice Returns vault data for a given underlying credit asset\n     * @param vaultAddress the vault contract address, returned by getVaults\n     * @param underlyingPool the address of the pool asset for which you want to get the vault state\n     **/\n    function getVaultData(address vaultAddress, address underlyingPool)\n        external\n        view\n        returns (\n            uint256 borrowRate,\n            uint256 totalDebt,\n            uint256 totalSecurityDeposit,\n            uint256 withdrawableSecurityDeposit,\n            uint256 creditLimit,\n            uint256 spendableBalance,\n            uint256 gav,\n            uint256 ltv,\n            uint256 minRepaymentRate,\n            uint256 aggregateRepaymentRate,\n            uint256 healthFactor\n        );\n\n    /**\n     * @notice Returns the actual draw downs for a vault and underlying asset pool\n     * @param vaultAddress vault contract address\n     * @param underlyingPool address of the underlying pool asset (ERC20)\n     * @return principal principal amount borrowed\n     * @return balance balance the outstanding compounded balance to be repaid\n     * @return amountRepaid the total repaid amount from origination\n     * @return tenure the underlying term of the draw down\n     * @return minRepaymentRate minimum repayment per second\n     * @return timestamp block timestamp at time of origination\n     **/\n    function getVaultDebt(address vaultAddress, address underlyingPool)\n        external\n        view\n        returns (\n            uint256 principal,\n            uint256 balance,\n            uint256 amountRepaid,\n            uint256 tenure,\n            uint256 minRepaymentRate,\n            uint256 timestamp\n        );\n\n    function getVaultFungibleAssets(\n        address vaultAddress,\n        address underlyingPool\n    ) external view returns (uint256 earningsBalance, uint256 creditBalance);\n\n    /**\n     * @notice returns the vault's collateralised assets (i.e. not repaid)\n     * @param vaultAddress the vault address\n     * @param underlyingPool the address of the underlying pool's ERC20 asset\n     * @param underlyingCollection address of the collateralised NFT collection\n     * @return floorPrice the **current** floor price\n     * @return gav the gav based on the floor\n     * @return ids ERC721 token IDs\n     **/\n    function getVaultCollateral(\n        address vaultAddress,\n        address underlyingPool,\n        address underlyingCollection\n    )\n        external\n        view\n        returns (\n            uint256 floorPrice,\n            uint256 gav,\n            uint256[] memory ids\n        );\n\n    /**\n     * @notice returns the details of a specific collateralised asset (i.e. not repaid)\n     * @param vaultAddress the vault's address\n     * @param underlyingPool the address of the underlying pool's ERC20 asset\n     * @param id the ID of the collateral asset\n     * @param underlyingCollection address of the collateralised NFT collection\n     * @return currentValue the **current** value of the asset (collection floor)\n     * @return purchasePrice the value of the asset at purchase\n     * @return protocolFee fees taken by the protocol\n     * @return affiliateFee fees taken by protocol affiliates\n     **/\n    function getVaultCollateralDetail(\n        address vaultAddress,\n        address underlyingPool,\n        uint256 id,\n        address underlyingCollection\n    )\n        external\n        view\n        returns (\n            uint256 currentValue,\n            uint256 purchasePrice,\n            uint256 protocolFee,\n            uint256 affiliateFee\n        );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}