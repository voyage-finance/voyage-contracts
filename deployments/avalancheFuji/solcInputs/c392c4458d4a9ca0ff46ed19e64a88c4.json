{
  "language": "Solidity",
  "sources": {
    "contracts/component/facets/DataProviderFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IAddressResolver} from \"../../interfaces/IAddressResolver.sol\";\nimport {WadRayMath} from \"../../libraries/math/WadRayMath.sol\";\nimport {IVToken} from \"../../interfaces/IVToken.sol\";\nimport {AppStorage, ADDRESS_RESOLVER, ReserveData, Tranche, VaultConfig, VaultData, DrawDownList} from \"../../libraries/LibAppStorage.sol\";\nimport {LibLiquidity} from \"../../libraries/LibLiquidity.sol\";\nimport {LibLoan} from \"../../libraries/LibLoan.sol\";\nimport {LibVault} from \"../../libraries/LibVault.sol\";\n\ncontract DataProviderFacet {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    AppStorage internal s;\n\n    struct PoolData {\n        uint256 totalLiquidity;\n        uint256 juniorLiquidity;\n        uint256 seniorLiquidity;\n        uint256 juniorLiquidityRate;\n        uint256 seniorLiquidityRate;\n        uint256 totalDebt;\n        uint256 utilizationRate;\n        uint256 trancheRatio;\n        uint256 decimals;\n        string symbol;\n        bool isActive;\n    }\n\n    struct UserPoolData {\n        uint256 juniorTrancheBalance;\n        uint256 withdrawableJuniorTrancheBalance;\n        uint256 seniorTrancheBalance;\n        uint256 withdrawableSeniorTrancheBalance;\n        uint256 decimals;\n    }\n\n    struct PoolConfiguration {\n        uint256 marginRequirement;\n        uint256 minMargin;\n        uint256 maxMargin;\n        uint256 loanTenure;\n        uint256 optimalTrancheRatio;\n        uint256 optimalIncomeRatio;\n        bool isActive;\n    }\n\n    struct FungibleTokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    function getPoolConfiguration(address _reserve)\n        external\n        view\n        returns (PoolConfiguration memory)\n    {\n        PoolConfiguration memory poolConfiguration;\n        ReserveData memory reserve = LibLiquidity.getReserveData(_reserve);\n        address healthStrategyAddr = reserve.healthStrategyAddress;\n        require(healthStrategyAddr != address(0), \"invalid health strategy\");\n        VaultConfig memory vc = LibVault.getVaultConfig(_reserve);\n        poolConfiguration.marginRequirement = vc.marginRequirement;\n        poolConfiguration.minMargin = vc.minMargin;\n        poolConfiguration.maxMargin = vc.maxMargin;\n        poolConfiguration.optimalIncomeRatio = reserve.optimalIncomeRatio;\n        poolConfiguration.optimalTrancheRatio = reserve.optimalTrancheRatio;\n        (bool isActive, , ) = LibLiquidity.getFlags(_reserve);\n        poolConfiguration.isActive = isActive;\n\n        return poolConfiguration;\n    }\n\n    function getPoolData(address underlyingAsset)\n        external\n        view\n        returns (PoolData memory)\n    {\n        LibLiquidity.DepositAndDebt memory depositAndDebt = LibLiquidity\n            .getDepositAndDebt(underlyingAsset);\n        IERC20Metadata token = IERC20Metadata(underlyingAsset);\n\n        PoolData memory poolData;\n        poolData.juniorLiquidity = depositAndDebt.juniorDepositAmount;\n        poolData.seniorLiquidity = depositAndDebt.seniorDepositAmount;\n        poolData.totalLiquidity = depositAndDebt.seniorDepositAmount.add(\n            depositAndDebt.juniorDepositAmount\n        );\n        poolData.juniorLiquidityRate = LibLiquidity.getLiquidityRate(\n            underlyingAsset,\n            Tranche.JUNIOR\n        );\n        poolData.seniorLiquidityRate = LibLiquidity.getLiquidityRate(\n            underlyingAsset,\n            Tranche.SENIOR\n        );\n        poolData.totalDebt = depositAndDebt.totalDebt;\n        if (depositAndDebt.seniorDepositAmount == 0) {\n            poolData.trancheRatio = 0;\n        } else {\n            poolData.trancheRatio = depositAndDebt.juniorDepositAmount.rayDiv(\n                depositAndDebt.seniorDepositAmount\n            );\n        }\n\n        poolData.decimals = token.decimals();\n        poolData.utilizationRate = LibLiquidity.utilizationRate(\n            underlyingAsset\n        );\n        poolData.symbol = token.symbol();\n        (bool isActive, , ) = LibLiquidity.getFlags(underlyingAsset);\n        poolData.isActive = isActive;\n\n        return poolData;\n    }\n\n    function getUserVault(address _user) external view returns (address) {\n        return LibVault.getVaultAddress(_user);\n    }\n\n    function getPoolTokens()\n        external\n        view\n        returns (FungibleTokenData[] memory tokens)\n    {\n        address[] memory reserveList = LibLiquidity.getReserveList();\n\n        FungibleTokenData[] memory reserves = new FungibleTokenData[](\n            reserveList.length\n        );\n\n        for (uint256 i = 0; i < reserveList.length; i++) {\n            address reserveAddress = reserveList[i];\n            reserves[i] = FungibleTokenData({\n                symbol: IERC20Metadata(reserveAddress).symbol(),\n                tokenAddress: reserveAddress\n            });\n        }\n\n        return reserves;\n    }\n\n    function getUserPoolData(address _reserve, address _user)\n        external\n        view\n        returns (UserPoolData memory)\n    {\n        UserPoolData memory userPoolData;\n        IERC20Metadata token = IERC20Metadata(_reserve);\n\n        uint256 seniorTrancheWithdrawable = LibLiquidity.balance(\n            _reserve,\n            _user,\n            Tranche.SENIOR\n        );\n        uint256 seniorTrancheUnbonding = LibLiquidity.unbonding(\n            _reserve,\n            _user,\n            Tranche.SENIOR\n        );\n        uint256 seniorTrancheTotalBalance = seniorTrancheWithdrawable.add(\n            seniorTrancheUnbonding\n        );\n        uint256 juniorTrancheWithdrawable = LibLiquidity.balance(\n            _reserve,\n            _user,\n            Tranche.JUNIOR\n        );\n        uint256 juniorTrancheUnbonding = LibLiquidity.unbonding(\n            _reserve,\n            _user,\n            Tranche.JUNIOR\n        );\n        uint256 juniorTrancheTotalBalance = juniorTrancheWithdrawable.add(\n            juniorTrancheUnbonding\n        );\n\n        userPoolData.juniorTrancheBalance = juniorTrancheTotalBalance;\n        userPoolData\n            .withdrawableJuniorTrancheBalance = juniorTrancheWithdrawable;\n        userPoolData.seniorTrancheBalance = seniorTrancheTotalBalance;\n        userPoolData\n            .withdrawableSeniorTrancheBalance = seniorTrancheWithdrawable;\n        userPoolData.decimals = token.decimals();\n\n        return userPoolData;\n    }\n\n    function getVaultData(\n        address _user,\n        address _reserve,\n        address _sponsor\n    ) external view returns (VaultData memory) {\n        VaultData memory vaultData;\n        address vault = LibVault.getVaultAddress(_user);\n        uint256 principal;\n        uint256 interest;\n        DrawDownList memory drawDownList;\n        (drawDownList.head, drawDownList.tail) = LibLoan.getDrawDownList(\n            _reserve,\n            vault\n        );\n        (principal, interest) = LibVault.getVaultDebt(_reserve, vault);\n        vaultData.drawDownList = drawDownList;\n        vaultData.borrowRate = 0;\n        vaultData.totalDebt = principal.add(interest);\n        vaultData.totalMargin = LibVault.getMargin(_user, _reserve);\n        vaultData.withdrawableSecurityDeposit = LibVault.getWithdrawableDeposit(\n            _user,\n            _reserve,\n            _sponsor\n        );\n        vaultData.creditLimit = LibVault.getCreditLimit(_user, _reserve);\n        vaultData.spendableBalance = LibVault.getAvailableCredit(\n            _user,\n            _reserve\n        );\n        vaultData.ltv = vaultData.gav.add(vaultData.totalMargin).rayDiv(\n            vaultData.totalDebt\n        );\n\n        return vaultData;\n    }\n\n    function getDrawDownDetail(\n        address _user,\n        address _reserve,\n        uint256 _drawDownId\n    ) external view returns (LibLoan.DebtDetail memory) {\n        address vault = LibVault.getVaultAddress(_user);\n        return LibLoan.getDrawDownDetail(_reserve, vault, _drawDownId);\n    }\n\n    function pendingSeniorWithdrawals(address _user, address _reserve)\n        public\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        ReserveData memory reserve = LibLiquidity.getReserveData(_reserve);\n\n        (uint256[] memory times, uint256[] memory amounts) = IVToken(\n            reserve.seniorDepositTokenAddress\n        ).unbonding(_user);\n\n        return (times, amounts);\n    }\n\n    function pendingJuniorWithdrawals(address _user, address _reserve)\n        public\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        ReserveData memory reserve = LibLiquidity.getReserveData(_reserve);\n\n        (uint256[] memory times, uint256[] memory amounts) = IVToken(\n            reserve.juniorDepositTokenAddress\n        ).unbonding(_user);\n\n        return (times, amounts);\n    }\n\n    function addressResolver() internal view returns (IAddressResolver) {\n        return IAddressResolver(s._addresses[ADDRESS_RESOLVER]);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IAddressResolver {\n    event AddressImported(bytes32 name, address destination);\n\n    function importAddresses(\n        bytes32[] calldata names,\n        address[] calldata destinations\n    ) external;\n\n    function getAddress(bytes32 name) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason)\n        external\n        view\n        returns (address);\n\n    function getVoyage() external view returns (address);\n\n    // function getLiquidityManagerProxy() external view returns (address);\n\n    // function getLiquidityManagerStorage() external view returns (address);\n\n    // function getLoanManagerProxy() external view returns (address);\n\n    // function getLoanManager() external view returns (address);\n\n    function getVaultManagerProxy() external view returns (address);\n\n    function getVaultManager() external view returns (address);\n\n    function getExtCallProxy() external view returns (address);\n\n    function getAclManager() external view returns (address);\n\n    function getPriceOracle() external view returns (address);\n\n    function getVaultStorage() external view returns (address);\n\n    function getJuniorDepositToken() external view returns (address);\n\n    function getSeniorDepositToken() external view returns (address);\n}\n"
    },
    "contracts/libraries/math/WadRayMath.sol": {
      "content": "pragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/******************\n@title WadRayMath library\n@author Aave\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n */\n\nlibrary WadRayMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant halfWAD = WAD / 2;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant halfRAY = RAY / 2;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    function Ray() public pure returns (uint256) {\n        return RAY;\n    }\n\n    function ray() internal pure returns (uint256) {\n        return RAY;\n    }\n\n    function wad() internal pure returns (uint256) {\n        return WAD;\n    }\n\n    function halfRay() internal pure returns (uint256) {\n        return halfRAY;\n    }\n\n    function halfWad() internal pure returns (uint256) {\n        return halfWAD;\n    }\n\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return halfWAD.add(a.mul(b)).div(WAD);\n    }\n\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        return halfB.add(a.mul(WAD)).div(b);\n    }\n\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return halfRAY.add(a.mul(b)).div(RAY);\n    }\n\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        return halfB.add(a.mul(RAY)).div(b);\n    }\n\n    function rayToWad(uint256 a) internal pure returns (uint256) {\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\n\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\n    }\n\n    function wadToRay(uint256 a) internal pure returns (uint256) {\n        return a.mul(WAD_RAY_RATIO);\n    }\n\n    // @dev calculates base^exp. The code uses the ModExp precompile\n    // @return base^exp, in ray\n    //solium-disable-next-line\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rayMul(x, x);\n\n            if (n % 2 != 0) {\n                z = rayMul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IVToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20, ERC4626} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\n\nabstract contract IVToken is ERC4626 {\n    constructor(\n        ERC20 _underlyingAsset,\n        string memory _name,\n        string memory _symbol\n    ) ERC4626(_underlyingAsset, _name, _symbol) {}\n\n    function transferUnderlyingTo(address _target, uint256 _amount)\n        external\n        virtual;\n\n    function claim(uint256 _withdrawlIdx) external virtual;\n\n    function unbonding(address _user)\n        external\n        view\n        virtual\n        returns (uint256[] memory, uint256[] memory);\n\n    function totalUnbonding() external view virtual returns (uint256);\n}\n"
    },
    "contracts/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {IACLManager} from \"../interfaces/IACLManager.sol\";\nimport {AddressResolver} from \"../component/infra/AddressResolver.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nbytes32 constant ADDRESS_RESOLVER = \"address_resolver\";\nbytes32 constant ACL = \"ACL\";\n\nenum Tranche {\n    JUNIOR,\n    SENIOR\n}\n\nstruct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    // for calculating overall interested accumulated\n    // then split it into two indexs base on two allocations\n    uint256 currentOverallLiquidityRate;\n    uint256 currentJuniorLiquidityRate;\n    uint256 currentSeniorLiquidityRate;\n    uint256 currentBorrowRate;\n    // Expressed in ray\n    uint256 marginRequirement;\n    //the decimals of the reserve asset\n    uint256 decimals;\n    address interestRateStrategyAddress;\n    address healthStrategyAddress;\n    address loanStrategyAddress;\n    address juniorDepositTokenAddress;\n    address seniorDepositTokenAddress;\n    uint40 juniorLastUpdateTimestamp;\n    uint40 seniorLastUpdateTimestamp;\n    uint256 optimalTrancheRatio;\n    uint256 currentIncomeRatio;\n    uint256 optimalIncomeRatio;\n    address nftAddress;\n    bool initialized;\n}\n\nstruct ReserveConfigurationMap {\n    //bit 0-15: Liquidate bonus\n    //bit 16-23: Decimals\n    //bit 24: Reserve is active\n    //bit 25: reserve is frozen\n    //bit 26: borrowing is enabled\n    //bit 27-30: reserved\n    //bit 31-46: reserve factor\n    //bit 47-62: lock up period in seconds\n    uint256 data;\n}\n\nstruct PMT {\n    uint256 principal;\n    uint256 interest;\n    uint256 pmt;\n}\n\nstruct RepaymentData {\n    uint256 principal;\n    uint256 interest;\n    // principal + interest\n    uint256 total;\n    uint40 paidAt;\n    bool isLiquidated;\n}\n\nstruct DrawDown {\n    uint256 principal;\n    // the total intended length of the loan in seconds - e.g., 90 days\n    uint256 term;\n    // the repayment interval - e.g., 30 days\n    uint256 epoch;\n    // number of instalments, term / epoch\n    uint256 nper;\n    // the amount to be repaid per instalment (principal + interest)\n    PMT pmt;\n    // the borrow rate of this loan\n    uint256 apr;\n    uint256 borrowAt;\n    // next due data\n    uint256 nextPaymentDue;\n    // principal paid\n    uint256 totalPrincipalPaid;\n    // interest paid\n    uint256 totalInterestPaid;\n    RepaymentData[] repayments;\n    // size pf repayments\n    uint256 paidTimes;\n}\n\nstruct DrawDownList {\n    uint256 head;\n    uint256 tail;\n}\n\nstruct BorrowData {\n    uint256 paidDrawDownNumber;\n    // next draw down number\n    uint256 nextDrawDownNumber;\n    uint256 totalPrincipal;\n    uint256 totalInterest;\n    uint256 mapSize;\n    mapping(uint256 => DrawDown) drawDowns;\n}\n\nstruct BorrowState {\n    uint256 totalDebt;\n    uint256 totalInterest;\n    uint256 avgBorrowRate;\n}\n\nstruct VaultConfig {\n    uint256 minMargin;\n    uint256 maxMargin;\n    uint256 marginRequirement;\n}\n\nstruct VaultData {\n    uint256 borrowRate;\n    uint256 totalDebt;\n    DrawDownList drawDownList;\n    uint256 totalMargin;\n    uint256 withdrawableSecurityDeposit;\n    uint256 creditLimit;\n    uint256 spendableBalance;\n    uint256 gav;\n    uint256 ltv;\n    uint256 healthFactor;\n}\n\nstruct AppStorage {\n    /* -------------------------------- plumbing -------------------------------- */\n    mapping(bytes32 => address) _addresses;\n    /* -------------------------------- liquidity ------------------------------- */\n    mapping(address => ReserveData) _reserves;\n    // List of reserves as a map (reserveId => reserve)\n    mapping(uint256 => address) _reserveList;\n    uint16 _reservesCount;\n    /* ---------------------------------- debt ---------------------------------- */\n    mapping(address => mapping(address => BorrowData)) _borrowData;\n    mapping(address => BorrowState) _borrowState;\n    bool _paused;\n    /* ---------------------------------- vault --------------------------------- */\n    UpgradeableBeacon upgradeableBeacon;\n    address[] vaults;\n    // mapping of vault owner to vault instance address\n    mapping(address => address) vaultMap;\n    // mapping of vault instance to vault configuration\n    mapping(address => VaultConfig) vaultConfigMap;\n}\n\nlibrary LibAppStorage {\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\n        assembly {\n            ds.slot := 0\n        }\n    }\n}\n\ncontract Storage is Context {\n    AppStorage internal s;\n\n    modifier whenPaused() {\n        require(s._paused, \"Pausable: not paused\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!s._paused, \"Pausable: paused\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        IACLManager aclManager = IACLManager(\n            AddressResolver(_addressResolver()).getAclManager()\n        );\n        require(aclManager.isProtocolManager(msg.sender), \"Not protocol admin\");\n        _;\n    }\n\n    function _addressResolver() internal view returns (address) {\n        return s._addresses[ADDRESS_RESOLVER];\n    }\n}\n"
    },
    "contracts/libraries/LibLiquidity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {Errors} from \"./helpers/Errors.sol\";\nimport {ReserveConfiguration} from \"./configuration/ReserveConfiguration.sol\";\nimport {IReserveInterestRateStrategy} from \"../interfaces/IReserveInterestRateStrategy.sol\";\nimport {ValidationLogic} from \"./logic/ValidationLogic.sol\";\nimport {LibAppStorage, AppStorage, ReserveData, ReserveConfigurationMap, BorrowData, BorrowState, Tranche} from \"./LibAppStorage.sol\";\nimport {IVToken} from \"../interfaces/IVToken.sol\";\nimport {WadRayMath} from \"./math/WadRayMath.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary LibLiquidity {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using ReserveConfiguration for ReserveConfigurationMap;\n\n    event ReserveDataUpdated(\n        address indexed asset,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate\n    );\n\n    struct DepositAndDebt {\n        uint256 juniorDepositAmount;\n        uint256 seniorDepositAmount;\n        uint256 totalDebt;\n        uint256 totalInterest;\n        uint256 avgBorrowRate;\n    }\n\n    uint256 internal constant RAY = 1e27;\n\n    /* --------------------------- reserve management --------------------------- */\n    function init(\n        ReserveData storage reserve,\n        address _juniorDepositTokenAddress,\n        address _seniorDepositTokenAddress,\n        address _interestRateStrategyAddress,\n        address _loanStrategyAddress,\n        uint256 _optimalIncomeRatio\n    ) internal {\n        reserve.juniorDepositTokenAddress = _juniorDepositTokenAddress;\n        reserve.seniorDepositTokenAddress = _seniorDepositTokenAddress;\n        reserve.interestRateStrategyAddress = _interestRateStrategyAddress;\n        reserve.optimalIncomeRatio = _optimalIncomeRatio;\n        reserve.loanStrategyAddress = _loanStrategyAddress;\n        reserve.initialized = true;\n    }\n\n    struct UpdateInterestRatesLocalVars {\n        uint256 availableLiquidity;\n        uint256 juniorLiquidity;\n        uint256 seniorLiquidity;\n        uint256 liquidityRatio;\n        uint256 totalDebt;\n        // total liquidity rate\n        uint256 newLiquidityRate;\n        uint256 effectiveJuniorLiquidityRate;\n        uint256 effectSeniorLiquidityRate;\n        uint256 newBorrowRate;\n        uint256 avgBorrowRate;\n    }\n\n    function updateInterestRates(\n        address _reserveAddress,\n        address _juniorDepositTokenAddress,\n        address _seniorDepositTokenAddress,\n        uint256 _juniorLiquidityAdded,\n        uint256 _juniorLiquidityTaken,\n        uint256 _seniorLiquidityAdded,\n        uint256 _seniorLiquidityTaken,\n        uint256 _totalDebt,\n        uint256 _avgBorrowRate\n    ) internal {\n        UpdateInterestRatesLocalVars memory vars;\n        ReserveData storage reserve = getReserveData(_reserveAddress);\n\n        (vars.totalDebt, vars.avgBorrowRate) = (_totalDebt, _avgBorrowRate);\n\n        (\n            vars.newLiquidityRate,\n            vars.newBorrowRate\n        ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n            .calculateInterestRates(\n                _reserveAddress,\n                _seniorDepositTokenAddress,\n                _seniorLiquidityAdded,\n                _seniorLiquidityTaken,\n                vars.totalDebt,\n                vars.avgBorrowRate\n            );\n        require(\n            vars.newLiquidityRate <= type(uint128).max,\n            Errors.RL_LIQUIDITY_RATE_OVERFLOW\n        );\n\n        vars.seniorLiquidity = IERC20(_seniorDepositTokenAddress).totalSupply();\n        vars.juniorLiquidity =\n            IERC20(_juniorDepositTokenAddress).totalSupply() +\n            _juniorLiquidityAdded -\n            _juniorLiquidityTaken;\n\n        if (vars.juniorLiquidity == 0) {\n            vars.effectiveJuniorLiquidityRate = 0;\n            vars.effectSeniorLiquidityRate = vars.newLiquidityRate;\n        } else {\n            vars.liquidityRatio = vars.seniorLiquidity.rayDiv(\n                vars.juniorLiquidity\n            );\n\n            vars.effectiveJuniorLiquidityRate = vars\n                .newLiquidityRate\n                .rayMul(RAY - reserve.optimalIncomeRatio)\n                .rayMul(vars.liquidityRatio);\n\n            vars.effectSeniorLiquidityRate = vars.newLiquidityRate.rayMul(\n                reserve.optimalIncomeRatio\n            );\n        }\n\n        reserve.currentOverallLiquidityRate = vars.newLiquidityRate;\n        reserve.currentJuniorLiquidityRate = vars.effectiveJuniorLiquidityRate;\n        reserve.currentSeniorLiquidityRate = vars.effectSeniorLiquidityRate;\n\n        emit ReserveDataUpdated(\n            _reserveAddress,\n            vars.newLiquidityRate,\n            vars.newBorrowRate\n        );\n    }\n\n    /* ------------------------ state mutation functions ------------------------ */\n    function updateStateOnDeposit(\n        address _asset,\n        Tranche _tranche,\n        uint256 _amount,\n        uint256 _totalDebt,\n        uint256 _avgBorrowRate\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        ReserveData storage reserve = s._reserves[_asset];\n        ValidationLogic.validateDeposit(reserve, _amount);\n        if (Tranche.JUNIOR == _tranche) {\n            updateInterestRates(\n                _asset,\n                reserve.juniorDepositTokenAddress,\n                reserve.seniorDepositTokenAddress,\n                _amount,\n                0,\n                0,\n                0,\n                _totalDebt,\n                _avgBorrowRate\n            );\n        } else {\n            updateInterestRates(\n                _asset,\n                reserve.juniorDepositTokenAddress,\n                reserve.seniorDepositTokenAddress,\n                0,\n                0,\n                _amount,\n                0,\n                _totalDebt,\n                _avgBorrowRate\n            );\n        }\n    }\n\n    function updateStateOnWithdraw(\n        address _asset,\n        Tranche _tranche,\n        uint256 _amount,\n        uint256 _totalDebt,\n        uint256 _avgBorrowRate\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        ReserveData storage reserve = s._reserves[_asset];\n        if (Tranche.JUNIOR == _tranche) {\n            updateInterestRates(\n                _asset,\n                reserve.juniorDepositTokenAddress,\n                reserve.seniorDepositTokenAddress,\n                0,\n                _amount,\n                0,\n                0,\n                _totalDebt,\n                _avgBorrowRate\n            );\n        } else {\n            updateInterestRates(\n                _asset,\n                reserve.juniorDepositTokenAddress,\n                reserve.seniorDepositTokenAddress,\n                0,\n                0,\n                0,\n                0,\n                _totalDebt,\n                _avgBorrowRate\n            );\n        }\n    }\n\n    /* ----------------------------- view functions ----------------------------- */\n    function getReserveData(address _asset)\n        internal\n        view\n        returns (ReserveData storage)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s._reserves[_asset];\n    }\n\n    function getReserveList() internal view returns (address[] memory) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address[] memory reserveList = new address[](s._reservesCount);\n        for (uint256 i = 0; i < s._reservesCount; i++) {\n            reserveList[i] = s._reserveList[i];\n        }\n        return reserveList;\n    }\n\n    function balance(\n        address _reserve,\n        address _user,\n        Tranche _tranche\n    ) internal view returns (uint256) {\n        ReserveData memory reserve = getReserveData(_reserve);\n        address vToken;\n        if (Tranche.JUNIOR == _tranche) {\n            vToken = reserve.juniorDepositTokenAddress;\n        } else {\n            vToken = reserve.seniorDepositTokenAddress;\n        }\n        return IVToken(vToken).maxWithdraw(_user);\n    }\n\n    function unbonding(\n        address _reserve,\n        address _user,\n        Tranche _tranche\n    ) internal view returns (uint256) {\n        ReserveData memory reserve = getReserveData(_reserve);\n        address vToken;\n        if (Tranche.JUNIOR == _tranche) {\n            vToken = reserve.juniorDepositTokenAddress;\n        } else {\n            vToken = reserve.seniorDepositTokenAddress;\n        }\n        (, uint256[] memory amounts) = IVToken(vToken).unbonding(_user);\n        uint256 unbondingBalance = 0;\n        for (uint8 i = 0; i < amounts.length; i++) {\n            unbondingBalance += amounts[i];\n        }\n        return unbondingBalance;\n    }\n\n    function getDepositAndDebt(address _reserve)\n        internal\n        view\n        returns (DepositAndDebt memory)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        ReserveData storage reserve = s._reserves[_reserve];\n        BorrowState storage borrowState = s._borrowState[_reserve];\n\n        DepositAndDebt memory res;\n        res.juniorDepositAmount = IVToken(reserve.juniorDepositTokenAddress)\n            .totalAssets();\n        res.seniorDepositAmount = IVToken(reserve.seniorDepositTokenAddress)\n            .totalAssets();\n        (res.totalDebt, res.totalInterest, res.avgBorrowRate) = (\n            borrowState.totalDebt,\n            borrowState.totalInterest,\n            borrowState.avgBorrowRate\n        );\n        return res;\n    }\n\n    function getLiquidityRate(address _asset, Tranche _tranche)\n        internal\n        view\n        returns (uint256)\n    {\n        ReserveData memory reserve = getReserveData(_asset);\n        if (_tranche == Tranche.JUNIOR) {\n            return reserve.currentJuniorLiquidityRate;\n        } else {\n            return reserve.currentSeniorLiquidityRate;\n        }\n    }\n\n    function getConfiguration(address _asset)\n        internal\n        view\n        returns (ReserveConfigurationMap memory)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s._reserves[_asset].configuration;\n    }\n\n    function getFlags(address _asset)\n        internal\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        ReserveConfigurationMap memory currentConfig = getConfiguration(_asset);\n        return currentConfig.getFlags();\n    }\n\n    function utilizationRate(address _reserve) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        ReserveData memory reserve = getReserveData(_reserve);\n        BorrowState memory borrowState = s._borrowState[_reserve];\n        uint256 totalDebt = borrowState.totalDebt.add(\n            borrowState.totalInterest\n        );\n\n        uint256 totalPendingWithdrawal = IVToken(\n            reserve.seniorDepositTokenAddress\n        ).totalUnbonding();\n\n        uint256 availableLiquidity = IERC20(_reserve).balanceOf(\n            reserve.seniorDepositTokenAddress\n        ) - totalPendingWithdrawal;\n\n        return\n            totalDebt == 0\n                ? 0\n                : totalDebt.rayDiv(availableLiquidity.add(totalDebt));\n    }\n}\n"
    },
    "contracts/libraries/LibLoan.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {LibAppStorage, AppStorage, BorrowData, BorrowState, DrawDown, PMT, RepaymentData, ReserveData} from \"./LibAppStorage.sol\";\nimport {WadRayMath} from \"./math/WadRayMath.sol\";\nimport {MathUtils} from \"./math/MathUtils.sol\";\nimport {LibLiquidity} from \"./LibLiquidity.sol\";\n\nlibrary LibLoan {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant SECOND_PER_MONTH = 30 days;\n\n    struct DebtDetail {\n        uint256 principal;\n        uint256 term;\n        uint256 epoch;\n        uint256 nper;\n        PMT pmt;\n        uint256 apr;\n        uint256 borrowAt;\n        uint256 nextPaymentDue;\n        uint256 totalPrincipalPaid;\n        uint256 totalInterestPaid;\n        uint256 paidTimes;\n    }\n\n    /* ----------------------------- state mutations ---------------------------- */\n\n    function insertDebt(\n        address _reserve,\n        address _vault,\n        uint256 _principal,\n        uint256 _term,\n        uint256 _epoch,\n        uint256 _apr\n    ) internal {\n        BorrowState storage borrowState = getBorrowState(_reserve);\n        BorrowData storage borrowData = getBorrowData(_reserve, _vault);\n        uint256 currentDrawDownNumber = borrowData.nextDrawDownNumber;\n        DrawDown storage dd = borrowData.drawDowns[currentDrawDownNumber];\n        dd.principal = _principal;\n        dd.term = _term;\n        dd.epoch = _epoch;\n        dd.apr = _apr;\n        dd.nper = _term.div(_epoch);\n        dd.borrowAt = block.timestamp;\n\n        uint256 principalRay = _principal.wadToRay();\n        uint256 interestRay = principalRay.rayMul(_apr);\n\n        PMT memory pmt;\n        pmt.principal = _principal.div(dd.nper);\n        pmt.interest = interestRay.rayToWad().div(dd.nper);\n        pmt.pmt = pmt.principal.add(pmt.interest);\n        dd.pmt = pmt;\n\n        dd.nextPaymentDue = dd.borrowAt.add(\n            dd.nper.sub(dd.paidTimes).mul(dd.epoch.mul(SECOND_PER_MONTH))\n        );\n\n        borrowData.nextDrawDownNumber++;\n        borrowData.mapSize++;\n        borrowData.totalPrincipal = borrowData.totalPrincipal.add(_principal);\n        borrowData.totalInterest = borrowData.totalInterest.add(\n            interestRay.rayToWad()\n        );\n\n        uint256 totalDebtRay = borrowState.totalDebt.wadToRay();\n        borrowState.avgBorrowRate = totalDebtRay\n            .rayMul(borrowState.avgBorrowRate)\n            .add(principalRay.rayMul(_apr))\n            .rayDiv(totalDebtRay.add(principalRay));\n        borrowState.totalDebt = borrowState.totalDebt.add(\n            principalRay.rayToWad()\n        );\n        borrowState.totalInterest = borrowState.totalInterest.add(\n            interestRay.rayToWad()\n        );\n    }\n\n    function repay(\n        address underlying,\n        address vault,\n        uint256 drawDownNumber,\n        uint256 principal,\n        uint256 interest,\n        bool isLiquidated\n    ) internal {\n        BorrowData storage debtData = getBorrowData(underlying, vault);\n        BorrowState storage borrowStat = getBorrowState(underlying);\n        DrawDown storage dd = debtData.drawDowns[drawDownNumber];\n        dd.paidTimes += 1;\n        if (dd.paidTimes == dd.nper) {\n            delete debtData.drawDowns[drawDownNumber];\n        } else {\n            dd.totalPrincipalPaid = dd.totalPrincipalPaid.add(principal);\n            dd.totalInterestPaid = dd.totalInterestPaid.add(interest);\n            RepaymentData memory repayment;\n            repayment.interest = interest;\n            repayment.principal = principal;\n            repayment.total = principal.add(interest);\n            repayment.paidAt = uint40(block.timestamp);\n            dd.repayments.push(repayment);\n            dd.nextPaymentDue = dd.borrowAt.add(\n                dd.nper.sub(dd.paidTimes).mul(dd.epoch.mul(SECOND_PER_MONTH))\n            );\n        }\n\n        debtData.totalPrincipal.sub(principal);\n        debtData.totalInterest.sub(interest);\n        uint256 interestRay = interest.wadToRay();\n        uint256 principalRay = principal.wadToRay();\n\n        uint256 totalDebtRay = borrowStat.totalDebt.wadToRay();\n        borrowStat.avgBorrowRate = totalDebtRay\n            .rayMul(borrowStat.avgBorrowRate)\n            .sub(principalRay.rayMul(dd.apr))\n            .rayDiv(totalDebtRay.sub(principalRay));\n        borrowStat.totalDebt = borrowStat.totalDebt.sub(\n            principalRay.rayToWad()\n        );\n        borrowStat.totalInterest = borrowStat.totalInterest.sub(\n            interestRay.rayToWad()\n        );\n    }\n\n    function updateStateOnBorrow(\n        address _asset,\n        uint256 _amount,\n        uint256 _totalDebt,\n        uint256 _avgBorrowRate\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        ReserveData storage reserve = s._reserves[_asset];\n        LibLiquidity.updateInterestRates(\n            _asset,\n            reserve.juniorDepositTokenAddress,\n            reserve.seniorDepositTokenAddress,\n            0,\n            0,\n            0,\n            _amount,\n            _totalDebt,\n            _avgBorrowRate\n        );\n    }\n\n    function updateStateOnRepayment(\n        address _asset,\n        uint256 _amount,\n        uint256 _totalDebt,\n        uint256 _avgBorrowRate\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        ReserveData storage reserve = s._reserves[_asset];\n        LibLiquidity.updateInterestRates(\n            _asset,\n            reserve.juniorDepositTokenAddress,\n            reserve.seniorDepositTokenAddress,\n            0,\n            0,\n            _amount,\n            0,\n            _totalDebt,\n            _avgBorrowRate\n        );\n    }\n\n    /* ----------------------------- view functions ----------------------------- */\n\n    function getBorrowState(address _underlying)\n        internal\n        view\n        returns (BorrowState storage)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s._borrowState[_underlying];\n    }\n\n    function getBorrowData(address _underlying, address _vault)\n        internal\n        view\n        returns (BorrowData storage)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s._borrowData[_underlying][_vault];\n    }\n\n    function getDrawDownDetail(\n        address _reserve,\n        address _vault,\n        uint256 _drawDownId\n    ) internal view returns (DebtDetail memory) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        BorrowData storage borrowData = s._borrowData[_reserve][_vault];\n        DrawDown storage dd = borrowData.drawDowns[_drawDownId];\n        DebtDetail memory debtDetail;\n        debtDetail.principal = dd.principal;\n        debtDetail.term = dd.term;\n        debtDetail.epoch = dd.epoch;\n        debtDetail.nper = dd.nper;\n        debtDetail.pmt = dd.pmt;\n        debtDetail.apr = dd.apr;\n        debtDetail.borrowAt = dd.borrowAt;\n        debtDetail.nextPaymentDue = dd.nextPaymentDue;\n        debtDetail.totalInterestPaid = dd.totalInterestPaid;\n        debtDetail.totalPrincipalPaid = dd.totalPrincipalPaid;\n        debtDetail.paidTimes = dd.paidTimes;\n        return debtDetail;\n    }\n\n    function getDrawDownList(address _reserve, address _vault)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        BorrowData storage borrowData = s._borrowData[_reserve][_vault];\n        return (borrowData.paidDrawDownNumber, borrowData.nextDrawDownNumber);\n    }\n\n    function getPMT(\n        address _reserve,\n        address _vault,\n        uint256 _drawDown\n    ) internal view returns (uint256, uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        DrawDown storage dd = s._borrowData[_reserve][_vault].drawDowns[\n            _drawDown\n        ];\n        return (dd.pmt.principal, dd.pmt.interest);\n    }\n}\n"
    },
    "contracts/libraries/LibVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {Vault} from \"../component/vault/Vault.sol\";\nimport {MarginEscrow} from \"../component/vault/MarginEscrow.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {LibAppStorage, AppStorage, BorrowData, VaultConfig} from \"./LibAppStorage.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nlibrary LibVault {\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n\n    function deployVault(\n        address _voyager,\n        address _owner,\n        address _reserve\n    ) internal returns (address, uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (address(s.upgradeableBeacon) == address(0)) {\n            Vault vault = new Vault();\n            s.upgradeableBeacon = new UpgradeableBeacon(address(vault));\n        }\n        MarginEscrow sde = new MarginEscrow();\n        BeaconProxy proxy = new BeaconProxy(\n            address(s.upgradeableBeacon),\n            abi.encodeWithSelector(\n                Vault(address(0)).initialize.selector,\n                _voyager,\n                _owner,\n                _reserve,\n                address(sde)\n            )\n        );\n        address vault = address(proxy);\n        sde.initialize(vault);\n        require(vault != address(0), \"deploy vault failed\");\n        require(s.vaultMap[_owner] == address(0), \"one vault per owner\");\n        s.vaults.push(vault);\n        s.vaultMap[_owner] = vault;\n        return (vault, s.vaults.length);\n    }\n\n    function setMaxMargin(address _reserve, uint256 _amount) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.vaultConfigMap[_reserve].maxMargin = _amount;\n    }\n\n    function setMinMargin(address _reserve, uint256 _amount) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.vaultConfigMap[_reserve].minMargin = _amount;\n    }\n\n    function setMarginRequirement(address _reserve, uint256 _requirement)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.vaultConfigMap[_reserve].marginRequirement = _requirement;\n    }\n\n    function updateVaultImplContract(address _vault) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.upgradeableBeacon.upgradeTo(_vault);\n    }\n\n    /* ----------------------------- view functions ----------------------------- */\n    function getVaultAddress(address _owner) internal view returns (address) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.vaultMap[_owner];\n    }\n\n    function getVaultDebt(address _reserve, address _vault)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        BorrowData storage borrowData = s._borrowData[_reserve][_vault];\n        return (borrowData.totalPrincipal, borrowData.totalInterest);\n    }\n\n    function getVaultConfig(address _reserve)\n        internal\n        view\n        returns (VaultConfig memory)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.vaultConfigMap[_reserve];\n    }\n\n    /**\n     * @dev Get available credit\n     * @param _user user address\n     * @param _reserve reserve address\n     **/\n    function getAvailableCredit(address _user, address _reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 creditLimit = getCreditLimit(_user, _reserve);\n        uint256 principal;\n        uint256 interest;\n        address vault = getVaultAddress(_user);\n        getVaultDebt(_reserve, vault);\n        uint256 accumulatedDebt = principal.add(interest);\n        if (creditLimit < accumulatedDebt) {\n            return 0;\n        }\n        return creditLimit - accumulatedDebt;\n    }\n\n    /**\n     * @dev Get credit limit for a specific reserve\n     * @param _user user address\n     * @return _reserve reserve address\n     **/\n    function getCreditLimit(address _user, address _reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 currentMargin = getMargin(_user, _reserve);\n        VaultConfig memory vc = getVaultConfig(_reserve);\n        uint256 marginRequirement = vc.marginRequirement;\n        require(marginRequirement != 0, \"margin requirement cannot be 0\");\n        uint256 creditLimitInRay = currentMargin.wadToRay().rayDiv(\n            marginRequirement\n        );\n        return creditLimitInRay.rayToWad();\n    }\n\n    function getMargin(address _user, address _reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        address vault = getVaultAddress(_user);\n        return IVault(vault).getCurrentMargin(_reserve);\n    }\n\n    function getWithdrawableDeposit(\n        address _owner,\n        address _reserve,\n        address _sponsor\n    ) internal view returns (uint256) {\n        address vault = getVaultAddress(_owner);\n        return IVault(vault).getWithdrawableDeposit(_sponsor, _reserve);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IACLManager {\n    function grantLiquidityManager(address _admin) external;\n\n    function isLiquidityManager(address _admin) external view returns (bool);\n\n    function grantVaultManager(address _admin) external;\n\n    function isVaultManager(address _admin) external view returns (bool);\n\n    function grantPoolManager(address _admin) external;\n\n    function grantLoanManager(address _admin) external;\n\n    function isLoanManager(address _admin) external view returns (bool);\n\n    function isProtocolManager(address _admin) external view returns (bool);\n\n    function grantLiquidityManagerContract(address _admin) external;\n\n    function isLiquidityManagerContract(address _admin)\n        external\n        view\n        returns (bool);\n\n    function grantLoanManagerContract(address _admin) external;\n\n    function isLoanManagerContract(address _admin) external view returns (bool);\n\n    function grantVaultManagerContract(address _admin) external;\n\n    function isVaultManagerContract(address _admin)\n        external\n        view\n        returns (bool);\n\n    function grantVaultConfigurator(address _amin) external;\n\n    function isVaultConfigurator(address _admin) external view returns (bool);\n\n    function grantVoyagerContract(address _admin) external;\n\n    function isVoyagerContract(address _admin) external view returns (bool);\n\n    function grantOracleManager(address _admin) external;\n\n    function isOracleManager(address _admin) external view returns (bool);\n}\n"
    },
    "contracts/component/infra/AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {IAddressResolver} from \"../../interfaces/IAddressResolver.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract AddressResolver is IAddressResolver, Ownable {\n    bytes32 public constant voyageName = \"voyager\";\n    bytes32 public constant aclManagerName = \"aclManager\";\n    bytes32 public constant liquidityDepositEscrowName =\n        \"liquidityDepositEscrow\";\n    bytes32 public constant vaultManagerProxyName = \"vaultManagerProxy\";\n    bytes32 public constant vaultManagerName = \"vaultManager\";\n    bytes32 public constant vaultStorageName = \"vaultStorage\";\n    bytes32 public constant juniorDepositTokenName = \"juniorDepositToken\";\n    bytes32 public constant seniorDepositTokenName = \"seniorDepositToken\";\n    bytes32 public constant securityDepositTokenName = \"securityDepositToken\";\n    bytes32 public constant extCallACLProxyName = \"extCallACLProxy\";\n    bytes32 public constant priceOracleName = \"priceOracle\";\n\n    mapping(bytes32 => address) public repository;\n\n    function importAddresses(\n        bytes32[] calldata names,\n        address[] calldata destinations\n    ) external onlyOwner {\n        require(\n            names.length == destinations.length,\n            \"Input lengths must match\"\n        );\n\n        for (uint256 i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    function getVoyage() external view returns (address) {\n        return repository[voyageName];\n    }\n\n    // function getLiquidityManagerProxy() external view returns (address) {\n    //     return repository[liquidityManagerProxyName];\n    // }\n\n    // function getLiquidityManagerStorage() external view returns (address) {\n    //     return repository[liquidityManagerStorageName];\n    // }\n\n    // function getLoanManagerProxy() external view returns (address) {\n    //     return repository[loanManagerProxyName];\n    // }\n\n    // function getLoanManager() external view returns (address) {\n    //     return repository[loanManagerName];\n    // }\n\n    function getVaultManagerProxy() external view returns (address) {\n        return repository[vaultManagerProxyName];\n    }\n\n    function getVaultManager() external view returns (address) {\n        return repository[vaultManagerName];\n    }\n\n    function getVaultStorage() external view returns (address) {\n        return repository[vaultStorageName];\n    }\n\n    function getJuniorDepositToken() external view returns (address) {\n        return repository[juniorDepositTokenName];\n    }\n\n    function getSeniorDepositToken() external view returns (address) {\n        return repository[seniorDepositTokenName];\n    }\n\n    function getExtCallProxy() external view returns (address) {\n        return repository[extCallACLProxyName];\n    }\n\n    function getAclManager() external view returns (address) {\n        return repository[aclManagerName];\n    }\n\n    function getPriceOracle() external view returns (address) {\n        return repository[priceOracleName];\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason)\n        external\n        view\n        returns (address)\n    {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.9;\n\n/**\n * @title Errors library\n * @author Voyager\n * @notice Defines the error messages emitted by the different contracts of the Voyager protocol\n * @dev Error messages prefix glossary:\n *  - VL = ValidationLogic\n *  - LM = LiquidityManager\n *  - LOM = LoanManager\n *  - CT = Common errors between tokens\n *  - RL = ReserveLogic\n */\nlibrary Errors {\n    string public constant VL_INVALID_AMOUNT = \"1\"; // 'Amount must be greater than 0'\n    string public constant VL_NO_ACTIVE_RESERVE = \"2\"; // 'Action requires an active reserve'\n    string public constant VL_RESERVE_FROZEN = \"3\"; // 'Action cannot be performed because the reserve is frozen'\n    string public constant CT_CALLER_MUST_BE_LIQUIDITY_MANAGER_POOL = \"20\";\n    string public constant CT_CALLER_MUST_BE_LOAN_MANAGER = \"21\";\n    string public constant CT_INVALID_MINT_AMOUNT = \"21\";\n    string public constant CT_INVALID_BURN_AMOUNT = \"22\";\n    string public constant LM_NOT_CONTRACT = \"60\";\n    string public constant LP_IS_PAUSED = \"61\"; // 'Pool is paused'\n    string public constant LOM_RESERVE_NOT_SUFFICIENT = \"70\";\n    string public constant LOM_CREDIT_NOT_SUFFICIENT = \"71\";\n    string public constant LOM_HEALTH_RISK_BELOW_ONE = \"72\";\n    string public constant LOM_NOT_VAULT_OWNER = \"73\";\n    string public constant LOM_INVALID_AMOUNT = \"74\";\n    string public constant LOM_INVALID_DEBT = \"75\";\n    string public constant LOM_INVALID_LIQUIDATE = \"76\";\n    string public constant LOM_INSUFFICIENT_JUNIOR = \"77\";\n    string public constant RL_LIQUIDITY_RATE_OVERFLOW = \"80\"; //  Liquidity rate overflows uint128\n    string public constant RL_STABLE_BORROW_RATE_OVERFLOW = \"81\"; //  Stable borrow rate overflows uint128\n}\n"
    },
    "contracts/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {ReserveData, ReserveConfigurationMap} from \"../LibAppStorage.sol\";\n\n/**\n * @title ReserveConfiguration library\n * @author Voyage\n * @notice Implements the bitmap logic to handle the reserve configuration, inspired by Aave\n **/\nlibrary ReserveConfiguration {\n    uint256 constant LIQUIDATE_BONUS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n    uint256 constant DECIMAL_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80FFFF; // prettier-ignore\n    uint256 constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFF; // prettier-ignore\n    uint256 constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFF; // prettier-ignore\n    uint256 constant BORROWING_ENABLE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFF; // prettier-ignore\n    uint256 constant RESERVED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF87FFFFFF; // prettier-ignore\n    uint256 constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA0007FFFFFFF; // prettier-ignore\n    uint256 constant LOCKUP_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80007FFFFFFFFFFF; // prettier-ignore\n\n    uint256 constant DECIMAL_MASK_BIT_POSITION = 16;\n    uint256 constant ACTIVE_MASK_BIT_POSITION = 24;\n    uint256 constant FROZEN_MASK_BIT_POSITION = 25;\n    uint256 constant BORROWING_ENABLE_MASK_POSITION = 26;\n    uint256 constant RESERVED_MASK_BIT_POSITION = 27;\n    uint256 constant RESERVE_FACTOR_MASK_BIT_POSITION = 31;\n    uint256 constant LOCKUP_PERIOD_MASK_BIT_POSITION = 47;\n\n    /**\n     * Gets the configuration flags of the reserve\n     * @param self The reserve configuration\n     * @return The state flags representing active, frozen, borrowing enabled\n     **/\n    function getFlags(ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        uint256 dataLocal = self.data;\n\n        return (\n            (dataLocal & ~ACTIVE_MASK) != 0,\n            (dataLocal & ~FROZEN_MASK) != 0,\n            (dataLocal & ~BORROWING_ENABLE_MASK) != 0\n        );\n    }\n\n    /**\n     * @dev Gets the active state of the reserve\n     * @param self The reserve configuration\n     * @param active The active state\n     **/\n    function setActive(ReserveConfigurationMap memory self, bool active)\n        internal\n        pure\n    {\n        self.data =\n            (self.data & ACTIVE_MASK) |\n            (uint256(active ? 1 : 0) << ACTIVE_MASK_BIT_POSITION);\n    }\n\n    function getActive(ReserveConfigurationMap storage self)\n        internal\n        view\n        returns (bool)\n    {\n        return (self.data & ~ACTIVE_MASK) != 0;\n    }\n}\n"
    },
    "contracts/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\n/**\n@title IReserveInterestRateStrategyInterface interface\n@notice Interface for the calculation of the interest rates.\n*/\n\ninterface IReserveInterestRateStrategy {\n    function calculateInterestRates(\n        address reserve,\n        uint256 availableLiquidity,\n        uint256 totalStableDebt,\n        uint256 averageBorrowRate\n    ) external view returns (uint256, uint256);\n\n    function calculateInterestRates(\n        address reserve,\n        address liquidityEscrow,\n        uint256 liquidityAdded,\n        uint256 liquidityTaken,\n        uint256 totalStableDebt,\n        uint256 averageBorrowRate\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/libraries/logic/ValidationLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\n\nimport {ReserveConfigurationMap, ReserveData} from \"../LibAppStorage.sol\";\n\nlibrary ValidationLogic {\n    using ReserveConfiguration for ReserveConfigurationMap;\n\n    /**\n     * @dev Validates a deposit token\n     * @param reserve The reserve object on which the user is depositing\n     * @param amount The amount to be deposited\n     **/\n    function validateDeposit(ReserveData storage reserve, uint256 amount)\n        internal\n        view\n    {\n        (bool isActive, bool isFrozen, ) = reserve.configuration.getFlags();\n        require(amount != 0, Errors.VL_INVALID_AMOUNT);\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n        require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {WadRayMath} from \"./WadRayMath.sol\";\n\nlibrary MathUtils {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @dev Function to calculate the interest accumulated using a linear interest rate formula\n     * @param rate The interest rate, in ray\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\n     * @return The interest rate linearly accumulated during the timeDelta, in ray\n     **/\n\n    function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        //solium-disable-next-line\n        uint256 timeDifference = block.timestamp.sub(\n            uint256(lastUpdateTimestamp)\n        );\n\n        return\n            (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());\n    }\n\n    /**\n     * @dev Function to calculate the interest using a compounded interest rate formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     *\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     *\n     * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\n     * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\n     *\n     * @param rate The interest rate, in ray\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\n     * @return The interest rate compounded during the timeDelta, in ray\n     **/\n    function calculateCompoundedInterest(\n        uint256 rate,\n        uint40 lastUpdateTimestamp,\n        uint256 currentTimestamp\n    ) internal pure returns (uint256) {\n        //solium-disable-next-line\n        uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));\n\n        if (exp == 0) {\n            return WadRayMath.ray();\n        }\n\n        uint256 expMinusOne = exp - 1;\n\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n        uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\n\n        uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\n        uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\n\n        uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;\n        uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(\n            basePowerThree\n        ) / 6;\n\n        return\n            WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(\n                thirdTerm\n            );\n    }\n\n    /**\n     * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\n     * @param rate The interest rate (in ray)\n     * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\n     **/\n    function calculateCompoundedInterest(\n        uint256 rate,\n        uint40 lastUpdateTimestamp\n    ) internal view returns (uint256) {\n        return\n            calculateCompoundedInterest(\n                rate,\n                lastUpdateTimestamp,\n                block.timestamp\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "contracts/component/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {MarginEscrow} from \"./MarginEscrow.sol\";\nimport {AddressResolver} from \"../infra/AddressResolver.sol\";\nimport {Voyager} from \"../Voyager.sol\";\nimport {VaultFacet} from \"../facets/VaultFacet.sol\";\nimport {LoanFacet} from \"../facets/LoanFacet.sol\";\nimport {VaultConfig} from \"../../libraries/LibAppStorage.sol\";\nimport {WadRayMath} from \"../../libraries/math/WadRayMath.sol\";\nimport {IACLManager} from \"../../interfaces/IACLManager.sol\";\nimport {IVault} from \"../../interfaces/IVault.sol\";\nimport {IAddressResolver} from \"../../interfaces/IAddressResolver.sol\";\nimport {PriorityQueue, Heap} from \"../../libraries/logic/PriorityQueue.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Vault is ReentrancyGuard, Initializable, IVault, IERC1271, IERC165 {\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n    using PriorityQueue for Heap;\n\n    // about to remove or refactor\n    address voyager;\n\n    struct VaultStorageV1 {\n        address owner;\n        MarginEscrow marginEscrow;\n        mapping(address => Heap) nfts;\n        /// @dev You must not set element 0xffffffff to true\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    modifier onlyVoyager() {\n        require(msg.sender == voyager, \"Not Voyager\");\n        _;\n    }\n\n    function initialize(\n        address _voyager,\n        address _owner,\n        address _reserve,\n        address _marginEscrow\n    ) external initializer {\n        voyager = _voyager;\n        diamondStorage().marginEscrow = MarginEscrow(_marginEscrow);\n        diamondStorage().owner = _owner;\n        ERC165MappingImplementation();\n        vaultMappingImplementation();\n    }\n\n    /// @notice Transfer some margin deposit\n    /// @param _sponsor user address who deposit to this escrow\n    /// @param _reserve reserve address\n    /// @param _amount deposit amount\n    function depositMargin(\n        address _sponsor,\n        address _reserve,\n        uint256 _amount\n    ) external payable nonReentrant onlyVoyager {\n        VaultConfig memory vaultConfig = vaultFacet().getVaultConfig(_reserve);\n\n        uint256 maxAllowedAmount = vaultConfig.maxMargin;\n        uint256 depositedAmount = diamondStorage()\n            .marginEscrow\n            .getDepositAmount(_reserve);\n        require(\n            depositedAmount + _amount <= maxAllowedAmount,\n            \"Vault: deposit amount exceed\"\n        );\n\n        uint256 minAllowedAmount = vaultConfig.minMargin;\n        require(minAllowedAmount <= _amount, \"Vault: deposit too small\");\n\n        diamondStorage().marginEscrow.deposit(_reserve, _sponsor, _amount);\n    }\n\n    /// @notice Redeem underlying reserve\n    /// @param _sponsor sponsor address\n    /// @param _reserve reserve address\n    /// @param _amount redeem amount\n    function redeemMargin(\n        address payable _sponsor,\n        address _reserve,\n        uint256 _amount\n    ) external payable nonReentrant onlyVoyager {\n        require(\n            _amount <= getWithdrawableDepositInternal(_sponsor, _reserve),\n            \"Vault: cannot redeem more than withdrawable deposit amount\"\n        );\n        diamondStorage().marginEscrow.withdraw(_reserve, _sponsor, _amount);\n    }\n\n    /// @return Returns the actual value that has been transferred\n    function slash(\n        address _reserve,\n        address payable _to,\n        uint256 _amount\n    ) external nonReentrant onlyVoyager returns (uint256) {\n        return diamondStorage().marginEscrow.slash(_reserve, _to, _amount);\n    }\n\n    /// @notice Insert new NFT\n    /// @param _erc721Addr NFT address\n    /// @param _tokenId Token id\n    function insertNFT(address _erc721Addr, uint256 _tokenId)\n        external\n        onlyVoyager\n    {\n        diamondStorage().nfts[_erc721Addr].insert(_tokenId, block.timestamp);\n    }\n\n    /// @notice Transfer nft out\n    /// @param _erc721Addr NFT address\n    /// @param _to whom to transfer\n    /// @param _num Number of nfts to transfer\n    function transferNFT(\n        address _erc721Addr,\n        address _to,\n        uint256 _num\n    ) external nonReentrant onlyVoyager {\n        for (uint256 i = 0; i < _num; i++) {\n            uint256 tokenId;\n            uint256 timestamp;\n            (tokenId, timestamp) = diamondStorage().nfts[_erc721Addr].delMin();\n            IERC721(_erc721Addr).transferFrom(address(this), _to, tokenId);\n        }\n    }\n\n    /// @notice Should return whether the signature provided is valid for the provided data\n    /// @param hash      Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue)\n    {\n        address sender = recoverSigner(hash, signature);\n        console.log(\"sender: \", sender);\n        if (diamondStorage().owner == sender) {\n            return 0x1626ba7e;\n        }\n        return 0xffffffff;\n    }\n\n    /************************************** View Functions **************************************/\n\n    /// @notice Returns true if this contract implements the interface defined by\n    /// `interfaceId`. See the corresponding\n    ///  https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n    /// to learn more about how these ids are created.\n    ///\n    /// This function call must use less than 30 000 gas.\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        returns (bool)\n    {\n        return diamondStorage().supportedInterfaces[interfaceId];\n    }\n\n    // Returns the struct from a specified position in contract storage\n    // ds is short for DiamondStorage\n    function diamondStorage()\n        internal\n        pure\n        returns (VaultStorageV1 storage ds)\n    {\n        // Specifies a random position in contract storage\n        // This can be done with a keccak256 hash of a unique string as is\n        // done here or other schemes can be used such as this:\n        // bytes32 storagePosition = keccak256(abi.encodePacked(ERC1155.interfaceId, ERC1155.name, address(this)));\n        bytes32 storagePosition = keccak256(\"finance.voyage.vault.v1.storage\");\n        // Set the position of our struct in contract storage\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function addressResolver() internal view returns (IAddressResolver) {\n        return Voyager(payable(voyager)).addressResolver();\n    }\n\n    function aclManager() internal view returns (IACLManager) {\n        return IACLManager(addressResolver().getAclManager());\n    }\n\n    function loanFacet() internal view returns (LoanFacet) {\n        return LoanFacet(voyager);\n    }\n\n    function vaultFacet() internal view returns (VaultFacet) {\n        return VaultFacet(voyager);\n    }\n\n    function getCurrentMargin(address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return diamondStorage().marginEscrow.getDepositAmount(_reserve);\n    }\n\n    function getActualSecurityDeposit(address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            ERC20(_reserve).balanceOf(address(diamondStorage().marginEscrow));\n    }\n\n    function getWithdrawableDeposit(address _sponsor, address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return getWithdrawableDepositInternal(_sponsor, _reserve);\n    }\n\n    /**\n     * @dev Get MarginEscrow contract address\n     * @return address\n     **/\n    function getMarginEscrowAddress() external view returns (address) {\n        return address(diamondStorage().marginEscrow);\n    }\n\n    function getTotalNFTNumbers(address _erc721Addr)\n        external\n        view\n        returns (uint256)\n    {\n        return diamondStorage().nfts[_erc721Addr].currentSize;\n    }\n\n    /************************************** Internal Functions **************************************/\n\n    /// @notice Recover the signer of hash, assuming it's an EOA account\n    /// @dev Only for EthSign signatures\n    /// @param _hash       Hash of message that was signed\n    /// @param _signature  Signature encoded as (bytes32 r, bytes32 s, uint8 v)\n    function recoverSigner(bytes32 _hash, bytes memory _signature)\n        internal\n        pure\n        returns (address signer)\n    {\n        require(\n            _signature.length == 65,\n            \"SignatureValidator#recoverSigner: invalid signature length\"\n        );\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(_signature, 32))\n            s := mload(add(_signature, 64))\n            v := byte(0, mload(add(_signature, 96)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        //\n        // Source OpenZeppelin\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\n\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            revert(\n                \"SignatureValidator#recoverSigner: invalid signature 's' value\"\n            );\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\n                \"SignatureValidator#recoverSigner: invalid signature 'v' value\"\n            );\n        }\n\n        // Recover ECDSA signer\n        signer = ecrecover(\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)\n            ),\n            v,\n            r,\n            s\n        );\n\n        // Prevent signer from being 0x0\n        require(\n            signer != address(0x0),\n            \"SignatureValidator#recoverSigner: INVALID_SIGNER\"\n        );\n\n        return signer;\n    }\n\n    function ERC165MappingImplementation() internal {\n        diamondStorage().supportedInterfaces[\n            this.supportsInterface.selector\n        ] = true;\n    }\n\n    function vaultMappingImplementation() internal {\n        mapping(bytes4 => bool) storage supportedInterfaces = diamondStorage()\n            .supportedInterfaces;\n        supportedInterfaces[this.depositMargin.selector] = true;\n        supportedInterfaces[this.redeemMargin.selector] = true;\n        supportedInterfaces[this.slash.selector] = true;\n        supportedInterfaces[this.insertNFT.selector] = true;\n        supportedInterfaces[this.transferNFT.selector] = true;\n    }\n\n    function getWithdrawableDepositInternal(address _sponsor, address _reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        VaultConfig memory vaultConfig = vaultFacet().getVaultConfig(_reserve);\n        uint256 marginRequirement = vaultConfig.marginRequirement;\n        uint256 principal;\n        uint256 interest;\n        (principal, interest) = loanFacet().getVaultDebt(\n            _reserve,\n            address(this)\n        );\n\n        uint256 totalDebt = principal.add(interest);\n        uint256 eligibleAmount = diamondStorage().marginEscrow.eligibleAmount(\n            _reserve,\n            _sponsor\n        );\n        uint256 withdrawableAmount = eligibleAmount -\n            totalDebt.wadToRay().rayMul(marginRequirement).rayToWad();\n\n        return withdrawableAmount;\n    }\n}\n"
    },
    "contracts/component/vault/MarginEscrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {BaseMarginEscrow} from \"./BaseMarginEscrow.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MarginEscrow is BaseMarginEscrow, Initializable {\n    address public vault;\n\n    modifier onlyOwner() {\n        require(msg.sender == vault, \"Not vault\");\n        _;\n    }\n\n    function initialize(address _vault) external initializer {\n        vault = _vault;\n    }\n\n    function getVersion() external view returns (string memory) {\n        string memory version = \"MarginEscrow 0.0.1\";\n        return version;\n    }\n\n    // placeholder function\n    function slash(\n        address _reserve,\n        address payable _to,\n        uint256 _amount\n    ) public payable nonReentrant onlyOwner returns (uint256) {\n        uint256 balance = IERC20(_reserve).balanceOf(address(this));\n        if (balance < _amount) {\n            _amount = balance;\n        }\n        transferToUser(_reserve, _to, _amount);\n        return _amount;\n    }\n\n    function deposit(\n        address _reserve,\n        address _user,\n        uint256 _amount\n    ) public payable nonReentrant onlyOwner {\n        _deposit(_reserve, _user, _amount);\n    }\n\n    function withdraw(\n        address _reserve,\n        address payable _user,\n        uint256 _amount\n    ) public onlyOwner {\n        _withdraw(_reserve, _user, _amount);\n    }\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {MarginEscrow} from \"../component/vault/MarginEscrow.sol\";\n\ninterface IVault {\n    function initialize(\n        address _voyager,\n        address _owner,\n        address _reserve,\n        address _marginEscrow\n    ) external;\n\n    function depositMargin(\n        address _sponsor,\n        address _reserve,\n        uint256 _amount\n    ) external payable;\n\n    function redeemMargin(\n        address payable _sponsor,\n        address _reserve,\n        uint256 _amount\n    ) external payable;\n\n    function slash(\n        address _reserve,\n        address payable _to,\n        uint256 _amount\n    ) external returns (uint256);\n\n    function transferNFT(\n        address _erc721Addr,\n        address _to,\n        uint256 _num\n    ) external;\n\n    function getTotalNFTNumbers(address _erc721Addr)\n        external\n        view\n        returns (uint256);\n\n    function insertNFT(address _erc721Addr, uint256 tokenId) external;\n\n    function getCurrentMargin(address _reserve) external view returns (uint256);\n\n    function getWithdrawableDeposit(address _sponsor, address _reserve)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "contracts/component/Voyager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {MessageBus} from \"./infra/MessageBus.sol\";\nimport {Diamond} from \"../diamond/Diamond.sol\";\nimport {LibDiamond} from \"../diamond/libraries/LibDiamond.sol\";\n\ncontract Voyager is Diamond, MessageBus {\n    constructor(address _owner) Diamond(_owner) {}\n}\n"
    },
    "contracts/component/facets/VaultFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {MarginEscrow} from \"../../component/vault/MarginEscrow.sol\";\nimport {WadRayMath} from \"../../libraries/math/WadRayMath.sol\";\nimport {IVault} from \"../../interfaces/IVault.sol\";\nimport {IACLManager} from \"../../interfaces/IACLManager.sol\";\nimport {LibAppStorage, Storage, VaultConfig} from \"../../libraries/LibAppStorage.sol\";\nimport {LibVault} from \"../../libraries/LibVault.sol\";\n\ncontract VaultFacet is Storage, ReentrancyGuard {\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n\n    /* --------------------------------- events --------------------------------- */\n    event VaultCreated(address _vault, address _owner, uint256 _numVaults);\n    event VaultInitialized(address _vault, address _reserve);\n    event VaultMarginCredited(\n        address indexed _vault,\n        address indexed _asset,\n        address _sponsor,\n        uint256 _amount\n    );\n    event VaultMarginRedeemed(\n        address indexed _vault,\n        address indexed _asset,\n        address _sponsor,\n        uint256 _amount\n    );\n\n    /* ----------------------------- admin interface ---------------------------- */\n    function createVault(\n        address _voyager,\n        address owner,\n        address _reserve\n    ) external onlyAdmin returns (address) {\n        address vault;\n        uint256 numVaults;\n        (vault, numVaults) = LibVault.deployVault(_voyager, owner, _reserve);\n        emit VaultCreated(vault, owner, numVaults);\n        return vault;\n    }\n\n    /* ----------------------------- user interface ----------------------------- */\n    /**\n     * @param _sponsor deposits the reserve into the amount\n     * @param _owner vault admin address\n     * @param _reserve reserve address\n     * @param _amount amount user is willing to deposit\n     */\n    function depositMargin(\n        address _sponsor,\n        address _owner,\n        address _reserve,\n        uint256 _amount\n    ) external {\n        address vaultAddress = LibVault.getVaultAddress(_owner);\n        IVault(vaultAddress).depositMargin(_sponsor, _reserve, _amount);\n        emit VaultMarginCredited(vaultAddress, _reserve, _sponsor, _amount);\n    }\n\n    /**\n     * @dev  Delegate call to Vault's redeemSecurity\n     * @param _sponsor sponsor address\n     * @param _owner user address\n     * @param _reserve reserve address\n     * @param _amount redeem amount\n     **/\n    function redeemMargin(\n        address payable _sponsor,\n        address _owner,\n        address _reserve,\n        uint256 _amount\n    ) external {\n        address vaultAddress = LibVault.getVaultAddress(_owner);\n        IVault(vaultAddress).redeemMargin(_sponsor, _reserve, _amount);\n        emit VaultMarginRedeemed(vaultAddress, _reserve, _sponsor, _amount);\n    }\n\n    /************************ HouseKeeping Function ******************************/\n\n    /**\n     * @dev Set max margin for _reserve\n     * @param _reserve reserve address\n     * @param _amount max amount sponsor can deposit\n     */\n    function setMaxMargin(address _reserve, uint256 _amount)\n        external\n        onlyAdmin\n    {\n        LibVault.setMaxMargin(_reserve, _amount);\n    }\n\n    /**\n     * @dev Set min margin for _reserve\n     * @param _reserve reserve address\n     * @param _amount min amount sponsor can deposit\n     */\n    function setMinMargin(address _reserve, uint256 _amount)\n        external\n        onlyAdmin\n    {\n        LibVault.setMinMargin(_reserve, _amount);\n    }\n\n    /**\n     * @dev Update the margin requirement\n     * @param _reserve reserve address\n     * @param _requirement expressed in Ray\n     */\n    function setMarginRequirement(address _reserve, uint256 _requirement)\n        external\n        onlyAdmin\n    {\n        LibVault.setMarginRequirement(_reserve, _requirement);\n    }\n\n    /**\n     * @dev Update the vault impl address\n     * @param _impl vault impl contract\n     */\n    function updateVaultImplContract(address _impl) external onlyAdmin {\n        LibVault.updateVaultImplContract(_impl);\n    }\n\n    /************************************** View Functions **************************************/\n\n    function getVaultConfig(address _reserve)\n        external\n        view\n        returns (VaultConfig memory)\n    {\n        return LibVault.getVaultConfig(_reserve);\n    }\n\n    /**\n     * @dev Get available credit\n     * @param _user user address\n     * @param _reserve reserve address\n     **/\n    function getAvailableCredit(address _user, address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return LibVault.getAvailableCredit(_user, _reserve);\n    }\n\n    /**\n     * @dev Get credit limit for a specific reserve\n     * @param _user user address\n     * @return _reserve reserve address\n     **/\n    function getCreditLimit(address _user, address _reserve)\n        public\n        view\n        returns (uint256)\n    {\n        return LibVault.getCreditLimit(_user, _reserve);\n    }\n\n    function getMargin(address _user, address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        return LibVault.getMargin(_user, _reserve);\n    }\n\n    function getVault(address _owner) external view returns (address) {\n        return LibVault.getVaultAddress(_owner);\n    }\n\n    function getAllVaults() external view returns (address[] memory) {\n        return s.vaults;\n    }\n\n    function getWithdrawableDeposit(\n        address _owner,\n        address _reserve,\n        address _sponsor\n    ) public view returns (uint256) {\n        return LibVault.getWithdrawableDeposit(_owner, _reserve, _sponsor);\n    }\n}\n"
    },
    "contracts/component/facets/LoanFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\nimport {WadRayMath} from \"../../libraries/math/WadRayMath.sol\";\nimport {IReserveInterestRateStrategy} from \"../../interfaces/IReserveInterestRateStrategy.sol\";\nimport {ILoanStrategy} from \"../../interfaces/ILoanStrategy.sol\";\nimport {IVault} from \"../../interfaces/IVault.sol\";\nimport {IVToken} from \"../../interfaces/IVToken.sol\";\nimport {IPriceOracle} from \"../../interfaces/IPriceOracle.sol\";\nimport {LibLiquidity} from \"../../libraries/LibLiquidity.sol\";\nimport {LibLoan} from \"../../libraries/LibLoan.sol\";\nimport {LibVault} from \"../../libraries/LibVault.sol\";\nimport {LibAppStorage, AppStorage, Storage, BorrowData, BorrowState, DrawDown, ReserveData} from \"../../libraries/LibAppStorage.sol\";\nimport {ERC4626} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {AddressResolver} from \"../infra/AddressResolver.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LoanFacet is Storage {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct ExecuteBorrowParams {\n        address asset;\n        address user;\n        uint256 amount;\n        uint256 term;\n        uint256 epoch;\n        uint256 liquidityRate;\n        uint256 borrowRate;\n    }\n\n    struct ExecuteLiquidateParams {\n        address reserve;\n        address vault;\n        uint256 drawDownId;\n        uint256 principal;\n        uint256 interest;\n        uint256 totalDebt;\n        uint256 totalFromMargin;\n        uint256 totalToLiquidate;\n        uint256 discount;\n        uint256 totalSlash;\n        address liquidator;\n        uint256 floorPrice;\n        uint256 totalNFTNums;\n        uint256 numNFTsToLiquidate;\n        uint256 gracePeriod;\n        uint256 liquidationBonus;\n        uint256 marginRequirement;\n    }\n\n    function borrow(\n        address _asset,\n        uint256 _amount,\n        address payable _vault\n    ) external whenNotPaused {\n        ExecuteBorrowParams memory executeBorrowParams;\n        // todo use min security deposit\n        require(_amount >= 1e19, Errors.LOM_INVALID_AMOUNT);\n\n        // 0. check if the user owns the vault\n        require(\n            LibVault.getVaultAddress(_msgSender()) == _vault,\n            Errors.LOM_NOT_VAULT_OWNER\n        );\n\n        // 1. check if pool liquidity is sufficient\n        ReserveData memory reserveData = LibLiquidity.getReserveData(_asset);\n\n        uint256 availableSeniorLiquidity = IERC20(_asset).balanceOf(\n            reserveData.seniorDepositTokenAddress\n        );\n        require(\n            availableSeniorLiquidity >= _amount,\n            Errors.LOM_RESERVE_NOT_SUFFICIENT\n        );\n\n        // 2. check HF\n        //        IHealthStrategy healthStrategy = IHealthStrategy(\n        //            reserveData.healthStrategyAddress\n        //        );\n\n        // 3. check credit limit\n        uint256 availableCreditLimit = LibVault.getAvailableCredit(\n            _msgSender(),\n            _asset\n        );\n        console.log(\"credit limit: %s\", availableCreditLimit);\n\n        require(\n            availableCreditLimit >= _amount,\n            Errors.LOM_CREDIT_NOT_SUFFICIENT\n        );\n\n        // 4. update debt logic\n        executeBorrowParams.term = ILoanStrategy(\n            reserveData.loanStrategyAddress\n        ).getTerm();\n        executeBorrowParams.epoch = ILoanStrategy(\n            reserveData.loanStrategyAddress\n        ).getEpoch();\n\n        // 5. update liquidity index and interest rate\n        BorrowState memory borrowStat = LibLoan.getBorrowState(_asset);\n        (\n            executeBorrowParams.liquidityRate,\n            executeBorrowParams.borrowRate\n        ) = IReserveInterestRateStrategy(\n            reserveData.interestRateStrategyAddress\n        ).calculateInterestRates(\n                _asset,\n                reserveData.seniorDepositTokenAddress,\n                0,\n                _amount,\n                borrowStat.totalDebt,\n                borrowStat.avgBorrowRate\n            );\n\n        LibLoan.updateStateOnBorrow(\n            _asset,\n            _amount,\n            borrowStat.totalDebt.add(borrowStat.totalInterest),\n            executeBorrowParams.borrowRate\n        );\n\n        LibLoan.insertDebt(\n            _asset,\n            _vault,\n            _amount,\n            executeBorrowParams.term,\n            executeBorrowParams.epoch,\n            executeBorrowParams.borrowRate\n        );\n\n        IVToken(reserveData.seniorDepositTokenAddress).transferUnderlyingTo(\n            _vault,\n            _amount\n        );\n    }\n\n    function repay(\n        address _user,\n        address _asset,\n        uint256 _drawDown,\n        address payable _vault\n    ) external whenNotPaused {\n        // 0. check if the user owns the vault\n        require(\n            LibVault.getVaultAddress(_msgSender()) == _vault,\n            Errors.LOM_NOT_VAULT_OWNER\n        );\n        // 1. check draw down to get principal and interest\n        uint256 principal;\n        uint256 interest;\n        (principal, interest) = LibLoan.getPMT(_asset, _vault, _drawDown);\n        require(principal.add(interest) != 0, Errors.LOM_INVALID_DEBT);\n\n        // 2. update liquidity index and interest rate\n        BorrowState memory borrowStat = LibLoan.getBorrowState(_asset);\n        uint256 totalDebt = borrowStat.totalDebt.add(borrowStat.totalInterest);\n        uint256 avgBorrowRate = borrowStat.avgBorrowRate;\n        LibLoan.updateStateOnRepayment(\n            _asset,\n            principal.add(interest),\n            totalDebt,\n            avgBorrowRate\n        );\n\n        // 3. update repay data\n        LibLoan.repay(_asset, _vault, _drawDown, principal, interest, false);\n\n        // 4. transfer underlying asset\n        ReserveData memory reserveData = LibLiquidity.getReserveData(_asset);\n\n        IERC20(_asset).safeTransferFrom(\n            _user,\n            reserveData.seniorDepositTokenAddress,\n            principal.add(interest)\n        );\n    }\n\n    function liquidate(\n        address _liquidator,\n        address _reserve,\n        address _vault,\n        uint256 _drawDownId\n    ) external whenNotPaused {\n        ExecuteLiquidateParams memory param;\n        ReserveData memory reserveData = LibLiquidity.getReserveData(\n            param.reserve\n        );\n\n        // 1. prepare basic info and some strategy parameters\n        param.reserve = _reserve;\n        param.vault = _vault;\n        param.drawDownId = _drawDownId;\n        param.liquidator = _liquidator;\n        (\n            param.gracePeriod,\n            param.liquidationBonus,\n            param.marginRequirement\n        ) = ILoanStrategy(reserveData.loanStrategyAddress)\n            .getLiquidationParams();\n        param.totalNFTNums = IVault(param.vault).getTotalNFTNumbers(\n            reserveData.nftAddress\n        );\n\n        LibLoan.DebtDetail memory debtDetail = LibLoan.getDrawDownDetail(\n            param.reserve,\n            param.vault,\n            param.drawDownId\n        );\n\n        // 2. check if the debt is qualified to be liquidated\n        require(\n            block.timestamp.sub(debtDetail.nextPaymentDue) > param.gracePeriod,\n            Errors.LOM_INVALID_LIQUIDATE\n        );\n\n        // 3.1 if it is, get debt info\n        (param.principal, param.interest) = LibLoan.getPMT(\n            param.reserve,\n            param.vault,\n            param.drawDownId\n        );\n        param.totalDebt = param.principal.add(param.interest);\n        param.totalFromMargin = param\n            .totalDebt\n            .wadToRay()\n            .rayMul(param.marginRequirement)\n            .rayToWad();\n        param.totalToLiquidate = param.totalDebt.sub(param.totalFromMargin);\n        param.discount = getDiscount(\n            param.totalToLiquidate,\n            param.liquidationBonus\n        );\n\n        // 3.2 get floor price from oracle contract\n        IPriceOracle priceOracle = IPriceOracle(\n            AddressResolver(_addressResolver()).getPriceOracle()\n        );\n        param.floorPrice = priceOracle.getAssetPrice(reserveData.nftAddress);\n\n        param.numNFTsToLiquidate = param\n            .totalToLiquidate\n            .sub(param.discount)\n            .div(param.floorPrice);\n        param.totalSlash = param.totalFromMargin.add(param.discount);\n\n        // 4.1 slash margin account\n        uint256 amountSlashed = IVault(param.vault).slash(\n            param.reserve,\n            payable(address(this)),\n            param.totalSlash\n        );\n\n        uint256 amountNeedExtra = param.totalSlash.sub(amountSlashed);\n\n        // 4.2 transfer from liquidator\n        IERC20(param.reserve).safeTransferFrom(\n            param.liquidator,\n            address(this),\n            param.totalToLiquidate\n        );\n\n        if (param.totalNFTNums < param.numNFTsToLiquidate) {\n            uint256 missingNFTNums = param.numNFTsToLiquidate.sub(\n                param.totalNFTNums\n            );\n            amountNeedExtra = missingNFTNums.mul(param.floorPrice).add(\n                amountNeedExtra\n            );\n            param.numNFTsToLiquidate = param.totalNFTNums;\n        }\n\n        // 4.3 sell nft\n        IVault(param.vault).transferNFT(\n            reserveData.nftAddress,\n            param.liquidator,\n            param.numNFTsToLiquidate\n        );\n\n        // 4.4 transfer from junior tranche\n        uint256 totalAssetFromJuniorTranche = ERC4626(\n            reserveData.juniorDepositTokenAddress\n        ).totalAssets();\n\n        if (totalAssetFromJuniorTranche >= amountNeedExtra) {\n            IVToken(reserveData.juniorDepositTokenAddress).transferUnderlyingTo(\n                    address(this),\n                    amountNeedExtra\n                );\n        } else {\n            IVToken(reserveData.juniorDepositTokenAddress).transferUnderlyingTo(\n                    address(this),\n                    totalAssetFromJuniorTranche\n                );\n\n            uint256 amountToWriteDown = amountNeedExtra.sub(\n                totalAssetFromJuniorTranche\n            );\n            // todo write down to somewhere\n        }\n\n        LibLoan.repay(\n            param.reserve,\n            param.vault,\n            param.drawDownId,\n            param.principal,\n            param.interest,\n            true\n        );\n\n        IERC20(param.reserve).safeTransfer(\n            reserveData.seniorDepositTokenAddress,\n            param.totalDebt\n        );\n    }\n\n    function getVaultDebt(address _reserve, address _vault)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return LibVault.getVaultDebt(_reserve, _vault);\n    }\n\n    /// @notice Returns the total outstanding principal debt for a particular underlying asset pool\n    /// @param underlyingAsset the address of the underlying reserve asset\n    /// @return The total outstanding principal owed to depositors.\n    function principalBalance(address underlyingAsset)\n        external\n        view\n        returns (uint256)\n    {\n        BorrowState memory borrowState = LibLoan.getBorrowState(\n            underlyingAsset\n        );\n        return borrowState.totalDebt;\n    }\n\n    /// @notice Returns the total outstanding interest debt for a particular underlying asset pool\n    /// @param underlyingAsset the address of the underlying reserve asset\n    /// @return The total outstanding interest owed to depositors.\n    function interestBalance(address underlyingAsset)\n        external\n        view\n        returns (uint256)\n    {\n        BorrowState memory borrowState = LibLoan.getBorrowState(\n            underlyingAsset\n        );\n        return borrowState.totalInterest;\n    }\n\n    function getDiscount(uint256 _value, uint256 _liquidationBonus)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 valueInRay = _value.wadToRay();\n        uint256 discountValueInRay = valueInRay.rayMul(_liquidationBonus);\n        return discountValueInRay.rayToWad();\n    }\n}\n"
    },
    "contracts/libraries/logic/PriorityQueue.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport \"openzeppelin-solidity/contracts/utils/math/SafeMath.sol\";\n\nstruct Heap {\n    uint256[] heapList;\n    uint256 currentSize;\n}\n\nlibrary PriorityQueue {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Returns the top element of the heap.\n     * @return The smallest element in the priority queue.\n     */\n    function getMin(Heap storage heap)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        return _splitElement(heap.heapList[1]);\n    }\n\n    /**\n     * @dev Inserts an element into the priority queue.\n     * @param _tokenId Token id.\n     * @param _timestamp Timestamp.\n     */\n    function insert(\n        Heap storage heap,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) internal {\n        uint256 element = (_tokenId << 128) | _timestamp;\n        heap.heapList.push(element);\n        heap.currentSize = heap.currentSize.add(1);\n        _percUp(heap, heap.currentSize);\n    }\n\n    /**\n     * @dev Deletes the top element of the heap and shifts everything up.\n     * @return The smallest element in the priorty queue.\n     */\n    function delMin(Heap storage heap) internal returns (uint256, uint256) {\n        uint256 retVal = heap.heapList[1];\n        heap.heapList[1] = heap.heapList[heap.currentSize];\n        delete heap.heapList[heap.currentSize];\n        heap.currentSize = heap.currentSize.sub(1);\n        _percDown(heap, 1);\n        //heap.heapList.length = heap.heapList.length.sub(1);\n        return _splitElement(retVal);\n    }\n\n    /**\n     * @dev Bubbles the element at some index up.\n     */\n    function _percUp(Heap storage heap, uint256 _index) internal {\n        uint256 index = _index;\n        uint256 j = index;\n        uint256 newVal = heap.heapList[index];\n        while (newVal < heap.heapList[index.div(2)]) {\n            heap.heapList[index] = heap.heapList[index.div(2)];\n            index = index.div(2);\n        }\n        if (index != j) heap.heapList[index] = newVal;\n    }\n\n    /**\n     * @dev Determines the minimum child of a given node in the tree.\n     * @param _index Index of the node in the tree.\n     * @return The smallest child node.\n     */\n    function _minChild(Heap storage heap, uint256 _index)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_index.mul(2).add(1) > heap.currentSize) {\n            return _index.mul(2);\n        } else {\n            if (\n                heap.heapList[_index.mul(2)] <\n                heap.heapList[_index.mul(2).add(1)]\n            ) {\n                return _index.mul(2);\n            } else {\n                return _index.mul(2).add(1);\n            }\n        }\n    }\n\n    /**\n     * @dev Bubbles the element at some index down.\n     */\n    function _percDown(Heap storage heap, uint256 _index) internal {\n        uint256 index = _index;\n        uint256 j = index;\n        uint256 newVal = heap.heapList[index];\n        uint256 mc = _minChild(heap, index);\n        while (mc <= heap.currentSize && newVal > heap.heapList[mc]) {\n            heap.heapList[index] = heap.heapList[mc];\n            index = mc;\n            mc = _minChild(heap, index);\n        }\n        if (index != j) heap.heapList[index] = newVal;\n    }\n\n    /**\n     * @dev Split an element into its priority and value.\n     * @param _element Element to decode.\n     * @return A tuple containing the token id and timestamp.\n     */\n    function _splitElement(uint256 _element)\n        internal\n        pure\n        returns (uint256, uint256)\n    {\n        uint256 tokenId = _element >> 128;\n        uint256 timestamp = uint256(uint128(_element));\n        return (tokenId, timestamp);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/component/vault/BaseMarginEscrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {EthAddressLib} from \"../../libraries/EthAddressLib.sol\";\n\ncontract BaseMarginEscrow is ReentrancyGuard {\n    using Address for address payable;\n    using SafeERC20 for ERC20;\n\n    struct Deposit {\n        uint256 amount;\n        uint40 depositTime;\n    }\n\n    event Deposited(address indexed payee, address token, uint256 amount);\n    event Withdrawn(address indexed payee, address token, uint256 amount);\n\n    // reserve address => amount\n    mapping(address => uint256) private _deposits;\n    // reserve address => user address => deposit record\n    mapping(address => mapping(address => Deposit[])) private _depositRecords;\n\n    uint40 private _lockupTimeInSeconds = 7 days;\n\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     * @param _reserve the asset address\n     * @param _user user address who deposit to this escrow\n     * @param _amount token amount need to transfer\n     */\n    function _deposit(\n        address _reserve,\n        address _user,\n        uint256 _amount\n    ) internal {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                \"User is sending ETH along with the ERC20 transfer.\"\n            );\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n        } else {\n            require(\n                msg.value == _amount,\n                \"The amount and the value sent to deposit do not match\"\n            );\n        }\n        _deposits[_reserve] += _amount;\n        Deposit memory deposit = Deposit(_amount, uint40(block.timestamp));\n        _depositRecords[_reserve][_user].push(deposit);\n        emit Deposited(_user, _reserve, _amount);\n    }\n\n    function eligibleAmount(address _reserve, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        Deposit[] storage deposits = _depositRecords[_reserve][_user];\n        uint256 eligibleAmount = 0;\n        for (uint256 i = 0; i < deposits.length; i++) {\n            if (\n                uint40(block.timestamp) - deposits[i].depositTime >\n                _lockupTimeInSeconds\n            ) {\n                eligibleAmount += deposits[i].amount;\n            }\n        }\n        return eligibleAmount;\n    }\n\n    /**\n     * @dev Withdraw accumulated balance for a payee, only beyond _lockupTimeInSeconds\n     * @param _reserve the asset address\n     * @param _user user address who deposit to this escrow\n     */\n    function _withdraw(\n        address _reserve,\n        address payable _user,\n        uint256 _amount\n    ) internal {\n        Deposit[] storage deposits = _depositRecords[_reserve][_user];\n        uint256 eligibleAmount = 0;\n        uint40 lastUpdateTime;\n        for (uint256 i = 0; i < deposits.length; i++) {\n            if (\n                uint40(block.timestamp) - deposits[i].depositTime >\n                _lockupTimeInSeconds\n            ) {\n                eligibleAmount += deposits[i].amount;\n                lastUpdateTime = deposits[i].depositTime;\n                delete deposits[i];\n            }\n        }\n\n        require(\n            eligibleAmount >= _amount,\n            \"Do not have enough amount to withdraw\"\n        );\n        // todo check borrow amount\n        // if there is any amount left from eligible amount, push it back\n        if (eligibleAmount > _amount) {\n            uint256 leftAmount = eligibleAmount - _amount;\n            Deposit memory leftDeposit = Deposit(leftAmount, lastUpdateTime);\n            _depositRecords[_reserve][_user].push(leftDeposit);\n        }\n\n        _deposits[_reserve] -= _amount;\n        transferToUser(_reserve, _user, _amount);\n        emit Withdrawn(_user, _reserve, _amount);\n    }\n\n    /**\n     * @dev get accumulated amount of deposit.\n     * @param _reserve the address of the reserve where the transfer is happening\n     * @return accumulated deposit amount\n     **/\n    function getDepositAmount(address _reserve) public view returns (uint256) {\n        return _deposits[_reserve];\n    }\n\n    /**\n     * @dev get all records of deposit.\n     * @param _reserve the address of the reserve where the transfer is happening\n     * @param _user the address of the user receiving the transfer\n     * @return deposit records\n     **/\n    function getDepositRecords(address _reserve, address _user)\n        public\n        view\n        returns (Deposit[] memory)\n    {\n        Deposit[] storage deposits = _depositRecords[_reserve][_user];\n        return deposits;\n    }\n\n    /**\n     * @dev transfers to the user a specific amount from the reserve.\n     * @param _reserve the address of the reserve where the transfer is happening\n     * @param _user the address of the user receiving the transfer\n     * @param _amount the amount being transferred\n     **/\n    function transferToUser(\n        address _reserve,\n        address payable _user,\n        uint256 _amount\n    ) internal {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call{value: _amount}(\"\");\n            require(result, \"Transfer of ETH failed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/EthAddressLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nlibrary EthAddressLib {\n    /**\n     * @dev returns the address used within the protocol to identify ETH\n     * @return the address assigned to ETH\n     */\n    function ethAddress() internal pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    }\n}\n"
    },
    "contracts/component/infra/MessageBus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {AddressResolver} from \"./AddressResolver.sol\";\nimport {IMessageBus} from \"../../interfaces/IMessageBus.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Storage, ADDRESS_RESOLVER} from \"../../libraries/LibAppStorage.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\n\n/**\n * todo it might be a bad name here, it actually performs as the centralise place\n * for querying each other among the internal components\n **/\ncontract MessageBus is Storage {\n    /**\n     * @dev Get addressResolver contract address\n     * @return address of the resolver contract\n     **/\n    function addressResolver() external view returns (AddressResolver) {\n        return AddressResolver(_addressResolver());\n    }\n}\n"
    },
    "contracts/diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n* \n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"./libraries/LibDiamond.sol\";\nimport {DiamondCutFacet} from \"./facets/DiamondCutFacet.sol\";\nimport {DiamondLoupeFacet} from \"./facets/DiamondLoupeFacet.sol\";\nimport {OwnershipFacet} from \"./facets/OwnershipFacet.sol\";\n\ncontract Diamond {\n    // more arguments are added to this struct\n    // this avoids stack too deep errors\n    struct DiamondArgs {\n        address owner;\n    }\n\n    constructor(address _owner) payable {\n        LibDiamond.setContractOwner(_owner);\n        LibDiamond.addDiamondFunctions(\n            address(new DiamondCutFacet()),\n            address(new DiamondLoupeFacet()),\n            address(new OwnershipFacet())\n        );\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {IERC173} from \"../interfaces/IERC173.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(\n            msg.sender == diamondStorage().contractOwner,\n            \"LibDiamond: Must be contract owner\"\n        );\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    /// @notice Adds default diamond facets\n    /// @dev This is always called in the Diamond constructor.\n    /// @param _diamondCutFacet - address of DiamondCutFacet\n    /// @param _diamondLoupeFacet - address of the DiamondLoupeFacet\n    /// @param _ownershipFacet - address of the OwnershipFacet\n    function addDiamondFunctions(\n        address _diamondCutFacet,\n        address _diamondLoupeFacet,\n        address _ownershipFacet\n    ) internal {\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](3);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        functionSelectors = new bytes4[](5);\n        functionSelectors[0] = IDiamondLoupe.facets.selector;\n        functionSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\n        functionSelectors[3] = IDiamondLoupe.facetAddress.selector;\n        functionSelectors[4] = IERC165.supportsInterface.selector;\n        cut[1] = IDiamondCut.FacetCut({\n            facetAddress: _diamondLoupeFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        functionSelectors = new bytes4[](2);\n        functionSelectors[0] = IERC173.transferOwnership.selector;\n        functionSelectors[1] = IERC173.owner.selector;\n        cut[2] = IDiamondCut.FacetCut({\n            facetAddress: _ownershipFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        diamondCut(cut, address(0), \"\");\n    }\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (\n            uint256 facetIndex;\n            facetIndex < _diamondCut.length;\n            facetIndex++\n        ) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        // uint16 selectorCount = uint16(diamondStorage().selectors.length);\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Add facet can't be address(0)\"\n        );\n        uint16 selectorPosition = uint16(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            enforceHasContractCode(\n                _facetAddress,\n                \"LibDiamondCut: New facet has no code\"\n            );\n            ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition = uint16(ds.facetAddresses.length);\n            ds.facetAddresses.push(_facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            require(\n                oldFacetAddress == address(0),\n                \"LibDiamondCut: Can't add function that already exists\"\n            );\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\n                selector\n            );\n            ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress = _facetAddress;\n            ds\n                .selectorToFacetAndPosition[selector]\n                .functionSelectorPosition = selectorPosition;\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Add facet can't be address(0)\"\n        );\n        uint16 selectorPosition = uint16(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            enforceHasContractCode(\n                _facetAddress,\n                \"LibDiamondCut: New facet has no code\"\n            );\n            ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition = uint16(ds.facetAddresses.length);\n            ds.facetAddresses.push(_facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            require(\n                oldFacetAddress != _facetAddress,\n                \"LibDiamondCut: Can't replace function with same function\"\n            );\n            removeFunction(oldFacetAddress, selector);\n            // add function\n            ds\n                .selectorToFacetAndPosition[selector]\n                .functionSelectorPosition = selectorPosition;\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\n                selector\n            );\n            ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress = _facetAddress;\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(\n            _facetAddress == address(0),\n            \"LibDiamondCut: Remove facet address must be address(0)\"\n        );\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Can't remove function that doesn't exist\"\n        );\n        // an immutable function is a function defined directly in a diamond\n        require(\n            _facetAddress != address(this),\n            \"LibDiamondCut: Can't remove immutable function\"\n        );\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition;\n        uint256 lastSelectorPosition = ds\n            .facetFunctionSelectors[_facetAddress]\n            .functionSelectors\n            .length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds\n                .facetFunctionSelectors[_facetAddress]\n                .functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\n                    selectorPosition\n                ] = lastSelector;\n            ds\n                .selectorToFacetAndPosition[lastSelector]\n                .functionSelectorPosition = uint16(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[\n                    lastFacetAddressPosition\n                ];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds\n                    .facetFunctionSelectors[lastFacetAddress]\n                    .facetAddressPosition = uint16(facetAddressPosition);\n            }\n            ds.facetAddresses.pop();\n            delete ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata)\n        internal\n    {\n        if (_init == address(0)) {\n            require(\n                _calldata.length == 0,\n                \"LibDiamondCut: _init is address(0) but_calldata is not empty\"\n            );\n        } else {\n            require(\n                _calldata.length > 0,\n                \"LibDiamondCut: _calldata is empty but _init is not address(0)\"\n            );\n            if (_init != address(this)) {\n                enforceHasContractCode(\n                    _init,\n                    \"LibDiamondCut: _init address has no code\"\n                );\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/interfaces/IMessageBus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {AddressResolver} from \"../component/infra/AddressResolver.sol\";\n\ninterface IMessageBus {\n    function addressResolver() external view returns (AddressResolver);\n\n    function getVault(address _user) external view returns (address);\n\n    function getSecurityDeposit(address _user, address _reserve)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/diamond/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../libraries/LibDiamond.sol\";\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n}\n"
    },
    "contracts/diamond/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../libraries/LibDiamond.sol\";\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../interfaces/IDiamondLoupe.sol\";\nimport \"../interfaces/IERC165.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds\n                .facetFunctionSelectors[facetAddress_]\n                .functionSelectors;\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet)\n        external\n        view\n        override\n        returns (bytes4[] memory facetFunctionSelectors_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds\n            .facetFunctionSelectors[_facet]\n            .functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector)\n        external\n        view\n        override\n        returns (address facetAddress_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds\n            .selectorToFacetAndPosition[_functionSelector]\n            .facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/diamond/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/LibDiamond.sol\";\nimport \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external view override returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/diamond/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet)\n        external\n        view\n        returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector)\n        external\n        view\n        returns (address facetAddress_);\n}\n"
    },
    "contracts/diamond/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/diamond/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/ILoanStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface ILoanStrategy {\n    function getTerm() external view returns (uint256);\n\n    function getEpoch() external view returns (uint256);\n\n    function getGrace() external view returns (uint256);\n\n    function getLiquidateBonus() external view returns (uint256);\n\n    function getMarginRequirement() external view returns (uint256);\n\n    function getLiquidationParams()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IPriceOracle {\n    function getAssetPrice(address _asset) external view returns (uint256);\n\n    function updateAssetPrice(address _asset) external;\n\n    function updateAssetPrices(address[] calldata _assets) external;\n\n    function updateCumulative(address _asset, uint256 _price) external;\n\n    function updateCumulativeBatch(\n        address[] calldata _assets,\n        uint256[] calldata _prices\n    ) external;\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/tokenization/SeniorDepositToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {AddressResolver} from \"../component/infra/AddressResolver.sol\";\nimport {LoanFacet} from \"../component/facets/LoanFacet.sol\";\nimport {BaseDepositToken} from \"./base/BaseDepositToken.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SeniorDepositToken is BaseDepositToken {\n    using SafeMath for uint256;\n\n    constructor(\n        address _voyager,\n        ERC20 _underlyingAsset,\n        string memory _name,\n        string memory _symbol\n    ) BaseDepositToken(_voyager, _underlyingAsset, _name, _symbol) {}\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 underlyingBalance = asset.balanceOf(address(this));\n        console.log(\"underlyingBalance: %s\", underlyingBalance);\n        uint256 outstandingPrincipal = LoanFacet(voyager).principalBalance(\n            address(asset)\n        );\n        console.log(\"outstandingPrincipal: %s\", outstandingPrincipal);\n        return underlyingBalance + outstandingPrincipal - totalUnbonding;\n    }\n}\n"
    },
    "contracts/tokenization/base/BaseDepositToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\nimport {IVToken} from \"../../interfaces/IVToken.sol\";\nimport {AddressResolver} from \"../../component/infra/AddressResolver.sol\";\n\nabstract contract BaseDepositToken is Context, IVToken {\n    using SafeMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    address internal immutable voyager;\n    // user address => timestamp => amount\n    mapping(address => mapping(uint256 => uint256)) private withdrawals;\n\n    // user address => timestamp array\n    mapping(address => uint256[]) private pendingTimestamp;\n\n    uint256 public override totalUnbonding;\n\n    uint256 public cooldown = 7 days;\n\n    event Claim(address receiver, uint256 amount);\n\n    modifier onlyAdmin() {\n        require(\n            _msgSender() == voyager,\n            Errors.CT_CALLER_MUST_BE_LIQUIDITY_MANAGER_POOL\n        );\n        _;\n    }\n\n    constructor(\n        address _voyager,\n        ERC20 _underlyingAsset,\n        string memory _name,\n        string memory _symbol\n    ) IVToken(_underlyingAsset, _name, _symbol) {\n        voyager = _voyager;\n    }\n\n    function withdraw(\n        uint256 _amount,\n        address _receiver,\n        address _owner\n    ) public override returns (uint256 shares) {\n        shares = previewWithdraw(_amount); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance[_owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[_owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(_amount, shares);\n\n        _burn(_owner, shares);\n        pushWithdraw(_owner, _amount);\n\n        emit Withdraw(msg.sender, _receiver, _owner, _amount, shares);\n    }\n\n    function claim(uint256 _index) public override {\n        uint256 amount = popWithdraw(msg.sender, _index);\n        require(\n            asset.balanceOf(address(this)) >= amount,\n            \"Insufficient liquidity available\"\n        );\n        asset.safeTransfer(msg.sender, amount);\n    }\n\n    function transferUnderlyingTo(address _target, uint256 _amount)\n        public\n        override\n        onlyAdmin\n    {\n        asset.safeTransfer(_target, _amount);\n    }\n\n    function pushWithdraw(address _user, uint256 _amount) internal {\n        require(withdrawals[_user][block.timestamp] == 0, \"invalid withdraw\");\n        withdrawals[_user][block.timestamp] = _amount;\n        pendingTimestamp[_user].push(block.timestamp);\n        totalUnbonding += _amount;\n    }\n\n    function popWithdraw(address _user, uint256 _index)\n        internal\n        returns (uint256)\n    {\n        uint256[] storage times = pendingTimestamp[_user];\n        require(_index < times.length, \"invalid index\");\n        uint256 ts = times[_index];\n        require(block.timestamp - ts > cooldown, \"cool down error\");\n\n        uint256 last = times[times.length - 1];\n        times[_index] = last;\n        times.pop();\n\n        uint256 withdrawable = withdrawals[_user][ts];\n        delete withdrawals[_user][ts];\n        totalUnbonding -= withdrawable;\n        return withdrawable;\n    }\n\n    function unbonding(address _user)\n        public\n        view\n        override\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint256[] memory times = pendingTimestamp[_user];\n        uint256[] memory amounts = new uint256[](times.length);\n\n        for (uint256 i = 0; i < times.length; i++) {\n            amounts[i] = withdrawals[_user][times[i]];\n        }\n\n        return (times, amounts);\n    }\n}\n"
    },
    "contracts/component/facets/LiquidityFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\nimport {WadRayMath} from \"../../libraries/math/WadRayMath.sol\";\nimport {IVToken} from \"../../interfaces/IVToken.sol\";\nimport {JuniorDepositToken} from \"../../tokenization/JuniorDepositToken.sol\";\nimport {SeniorDepositToken} from \"../../tokenization/SeniorDepositToken.sol\";\nimport {LibAppStorage, AppStorage, Storage, Tranche, ReserveData, BorrowState, ReserveConfigurationMap} from \"../../libraries/LibAppStorage.sol\";\nimport {ReserveConfiguration} from \"../../libraries/configuration/ReserveConfiguration.sol\";\nimport {LibLiquidity} from \"../../libraries/LibLiquidity.sol\";\nimport {PeripheryPayments} from \"../../libraries/utils/PeripheryPayments.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LiquidityFacet is Storage, PeripheryPayments {\n    using LibLiquidity for ReserveData;\n    using ReserveConfiguration for ReserveConfigurationMap;\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event ReserveInitialized(\n        address indexed _asset,\n        address _juniorDepositTokenAddress,\n        address _seniorDepositTokenAddress,\n        address _interestRateStrategyAddress,\n        uint256 _optimalIncomeRatio\n    );\n    event ReserveActivated(address indexed _asset);\n    event Deposit(\n        address indexed asset,\n        address indexed user,\n        Tranche indexed tranche,\n        uint256 amount\n    );\n    event Withdraw(\n        address indexed asset,\n        address indexed user,\n        Tranche indexed tranche,\n        uint256 amount\n    );\n\n    /* ----------------------------- admin interface ---------------------------- */\n\n    function initReserve(\n        address _asset,\n        address _juniorDepositTokenAddress,\n        address _seniorDepositTokenAddress,\n        address _interestRateStrategyAddress,\n        address _loanStrategyAddress,\n        uint256 _optimalIncomeRatio\n    ) external onlyAdmin {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        ReserveData storage reserveData = LibLiquidity.getReserveData(_asset);\n        require(reserveData.initialized == false, \"cannot initialize twice\");\n        reserveData.init(\n            _juniorDepositTokenAddress,\n            _seniorDepositTokenAddress,\n            _interestRateStrategyAddress,\n            _loanStrategyAddress,\n            _optimalIncomeRatio\n        );\n        s._reserveList[s._reservesCount] = _asset;\n        s._reservesCount++;\n        emit ReserveInitialized(\n            _asset,\n            _juniorDepositTokenAddress,\n            _seniorDepositTokenAddress,\n            _interestRateStrategyAddress,\n            _optimalIncomeRatio\n        );\n    }\n\n    function activateReserve(address _asset) external onlyAdmin {\n        require(Address.isContract(_asset), Errors.LM_NOT_CONTRACT);\n        ReserveConfigurationMap memory config = LibLiquidity.getConfiguration(\n            _asset\n        );\n        config.setActive(true);\n        s._reserves[_asset].configuration.data = config.data;\n        emit ReserveActivated(_asset);\n    }\n\n    /* ----------------------------- user interface ----------------------------- */\n\n    function deposit(\n        address _asset,\n        Tranche _tranche,\n        uint256 _amount,\n        address _user\n    ) external {\n        ReserveData memory reserve = s._reserves[_asset];\n        BorrowState memory borrowState = s._borrowState[_asset];\n        uint256 totalDebt = borrowState.totalDebt.add(\n            borrowState.totalInterest\n        );\n        uint256 avgBorrowRate = borrowState.avgBorrowRate;\n        LibLiquidity.updateStateOnDeposit(\n            _asset,\n            _tranche,\n            _amount,\n            totalDebt,\n            avgBorrowRate\n        );\n\n        IVToken vToken = _tranche == Tranche.JUNIOR\n            ? IVToken(reserve.juniorDepositTokenAddress)\n            : IVToken(reserve.seniorDepositTokenAddress);\n        // transfer the underlying tokens to liquidity manager, then do deposit.\n        pullToken(vToken.asset(), _amount, _user, address(this));\n        vToken.deposit(_amount, _user);\n        emit Deposit(_asset, _user, _tranche, _amount);\n    }\n\n    function withdraw(\n        address _asset,\n        Tranche _tranche,\n        uint256 _amount,\n        address payable _user\n    ) external {\n        ReserveData memory reserve = s._reserves[_asset];\n        IVToken vToken = Tranche.JUNIOR == _tranche\n            ? IVToken(reserve.juniorDepositTokenAddress)\n            : IVToken(reserve.seniorDepositTokenAddress);\n        uint256 userBalance = vToken.maxWithdraw(_user);\n        uint256 amountToWithdraw = _amount;\n        if (_amount == type(uint256).max) {\n            amountToWithdraw = userBalance;\n        }\n        console.log(\"amount to withdraw: %s\", amountToWithdraw);\n        BorrowState memory borrowState = s._borrowState[_asset];\n        uint256 totalDebt = borrowState.totalDebt.add(\n            borrowState.totalInterest\n        );\n        console.log(\"total debt: %s\", totalDebt);\n        uint256 avgBorrowRate = borrowState.avgBorrowRate;\n        console.log(\"avg borrow rate: %s\", borrowState.avgBorrowRate);\n        IVToken(vToken).withdraw(_amount, _user, _user);\n        console.log(\"withdrew\");\n        LibLiquidity.updateStateOnWithdraw(\n            _asset,\n            _tranche,\n            amountToWithdraw,\n            totalDebt,\n            avgBorrowRate\n        );\n\n        emit Withdraw(_asset, _user, _tranche, _amount);\n    }\n\n    /* ---------------------------------- views --------------------------------- */\n\n    function balance(\n        address _reserve,\n        address _user,\n        Tranche _tranche\n    ) public view returns (uint256) {\n        return LibLiquidity.balance(_reserve, _user, _tranche);\n    }\n\n    function liquidityRate(address _asset, Tranche _tranche)\n        public\n        view\n        returns (uint256)\n    {\n        return LibLiquidity.getLiquidityRate(_asset, _tranche);\n    }\n\n    function unbonding(\n        address _reserve,\n        address _user,\n        Tranche _tranche\n    ) public view returns (uint256) {\n        return LibLiquidity.unbonding(_reserve, _user, _tranche);\n    }\n\n    function utilizationRate(address _reserve) external view returns (uint256) {\n        ReserveData memory reserve = LibLiquidity.getReserveData(_reserve);\n        BorrowState storage borrowState = s._borrowState[_reserve];\n        uint256 totalDebt = borrowState.totalDebt.add(\n            borrowState.totalInterest\n        );\n\n        uint256 totalPendingWithdrawal = IVToken(\n            reserve.seniorDepositTokenAddress\n        ).totalUnbonding();\n\n        uint256 availableLiquidity = IERC20(_reserve).balanceOf(\n            reserve.seniorDepositTokenAddress\n        ) - totalPendingWithdrawal;\n\n        return\n            totalDebt == 0\n                ? 0\n                : totalDebt.rayDiv(availableLiquidity.add(totalDebt));\n    }\n\n    function getReserveFlags(address _reserve)\n        external\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        return LibLiquidity.getFlags(_reserve);\n    }\n}\n"
    },
    "contracts/tokenization/JuniorDepositToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {BaseDepositToken} from \"./base/BaseDepositToken.sol\";\n\ncontract JuniorDepositToken is BaseDepositToken {\n    using SafeMath for uint256;\n\n    constructor(\n        address _voyager,\n        ERC20 _underlyingAsset,\n        string memory _name,\n        string memory _symbol\n    ) BaseDepositToken(_voyager, _underlyingAsset, _name, _symbol) {}\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this)) - totalUnbonding;\n    }\n}\n"
    },
    "contracts/libraries/utils/PeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.9;\n\nimport {ERC20, SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/// @title Depositor\n/// @author Voyage Finance\n/// @notice Forwards calls to ERC-4626 compliant Vaults, but with the actual depositor appended to the encoded call data.\n/// @dev This does not work if the receiving contract does not implement ERC-4626!\nabstract contract PeripheryPayments {\n    using SafeTransferLib for *;\n\n    function pullToken(\n        ERC20 token,\n        uint256 amount,\n        address from,\n        address recipient\n    ) public payable {\n        token.safeTransferFrom(from, recipient, amount);\n    }\n\n    function approve(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) public payable {\n        token.safeApprove(to, amount);\n    }\n}\n"
    },
    "contracts/diamond/InitDiamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {AppStorage, ACL, ADDRESS_RESOLVER} from \"../libraries/LibAppStorage.sol\";\nimport {LibDiamond} from \"../diamond/libraries/LibDiamond.sol\";\nimport {IDiamondLoupe} from \"../diamond/interfaces/IDiamondLoupe.sol\";\nimport {IDiamondCut} from \"../diamond/interfaces/IDiamondCut.sol\";\nimport {IERC173} from \"../diamond/interfaces/IERC173.sol\";\nimport {IERC165} from \"../diamond/interfaces/IERC165.sol\";\n\ncontract InitDiamond {\n    AppStorage internal s;\n\n    struct Args {\n        address addressResolver;\n    }\n\n    function init(Args memory _args) external {\n        // initialise diamond level stuff\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // initialise app storage stuff\n        s._addresses[ADDRESS_RESOLVER] = _args.addressResolver;\n        s._paused = false;\n    }\n}\n"
    },
    "contracts/libraries/acl/ExtCallACL.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Proxyable} from \"../proxy/Proxyable.sol\";\nimport {IExtCallACL} from \"./IExtCallACL.sol\";\nimport {Voyager} from \"../../component/Voyager.sol\";\n\ncontract ExtCallACL is Proxyable, IExtCallACL {\n    mapping(address => bool) public whitelistedAddress;\n    mapping(bytes32 => bool) public whitelistedFunctions;\n\n    constructor(address payable _proxy, address payable _voyage)\n        public\n        Proxyable(_proxy)\n    {\n        voyager = Voyager(_voyage);\n    }\n\n    function whitelistAddress(address[] calldata _address) external onlyProxy {\n        uint256 arrayLength = _address.length;\n        for (uint256 i = 0; i < arrayLength; i++) {\n            whitelistedAddress[_address[i]] = true;\n        }\n    }\n\n    function blockAddress(address[] calldata _address) external onlyProxy {\n        uint256 arrayLength = _address.length;\n        for (uint256 i = 0; i < arrayLength; i++) {\n            delete whitelistedAddress[_address[i]];\n        }\n    }\n\n    function isWhitelistedAddress(address _address)\n        external\n        view\n        returns (bool)\n    {\n        return whitelistedAddress[_address];\n    }\n\n    function whitelistFunction(bytes32[] calldata _func) external onlyProxy {\n        uint256 arrayLength = _func.length;\n        for (uint256 i = 0; i < arrayLength; i++) {\n            whitelistedFunctions[_func[i]] = true;\n        }\n    }\n\n    function blockFunction(bytes32[] calldata _func) external onlyProxy {\n        uint256 arrayLength = _func.length;\n        for (uint256 i = 0; i < arrayLength; i++) {\n            delete whitelistedFunctions[_func[i]];\n        }\n    }\n\n    function isWhitelistedFunction(bytes32 _func) external view returns (bool) {\n        return whitelistedFunctions[_func];\n    }\n}\n"
    },
    "contracts/libraries/proxy/Proxyable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Proxy} from \"./Proxy.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IVoyagerComponent} from \"../../interfaces/IVoyagerComponent.sol\";\n\nabstract contract Proxyable is Ownable, IVoyagerComponent {\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\n    address public messageSender;\n\n    modifier onlyProxy() {\n        _onlyProxy();\n        _;\n    }\n\n    modifier optionalProxy_onlyOwner() {\n        _optionalProxy_onlyOwner();\n        _;\n    }\n\n    event ProxyUpdated(address proxyAddress);\n\n    constructor(address payable _proxy) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner() != address(0), \"Owner must be set\");\n\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function _onlyProxy() private view {\n        require(msg.sender == address(proxy), \"Only the proxy can call\");\n    }\n\n    function setProxy(address payable _proxy) external onlyOwner {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setMessageSender(address sender) external onlyProxy {\n        messageSender = sender;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _optionalProxy_onlyOwner() private {\n        if (msg.sender != address(proxy) && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner(), \"Owner only function\");\n    }\n}\n"
    },
    "contracts/libraries/acl/IExtCallACL.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IExtCallACL {\n    function whitelistAddress(address[] calldata _address) external;\n\n    function blockAddress(address[] calldata _address) external;\n\n    function isWhitelistedAddress(address _address)\n        external\n        view\n        returns (bool);\n\n    function whitelistFunction(bytes32[] calldata _func) external;\n\n    function blockFunction(bytes32[] calldata _func) external;\n\n    function isWhitelistedFunction(bytes32 _func) external view returns (bool);\n}\n"
    },
    "contracts/libraries/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Proxyable} from \"./Proxyable.sol\";\nimport {IACLManager} from \"../../interfaces/IACLManager.sol\";\n\ncontract Proxy is Ownable {\n    Proxyable public target;\n\n    event TargetUpdated(Proxyable newTarget);\n\n    modifier onlyTarget() {\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        _onlyAuthorized();\n        _;\n    }\n\n    function setTarget(Proxyable _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function _emit(\n        bytes calldata callData,\n        uint256 numTopics,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3,\n        bytes32 topic4\n    ) external onlyTarget {\n        uint256 size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n            case 0 {\n                log0(add(_callData, 32), size)\n            }\n            case 1 {\n                log1(add(_callData, 32), size, topic1)\n            }\n            case 2 {\n                log2(add(_callData, 32), size, topic1, topic2)\n            }\n            case 3 {\n                log3(add(_callData, 32), size, topic1, topic2, topic3)\n            }\n            case 4 {\n                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n            }\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n    fallback() external payable onlyAuthorized {\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\n        target.setMessageSender(msg.sender);\n\n        assembly {\n            let free_ptr := mload(0x40)\n            calldatacopy(free_ptr, 0, calldatasize())\n\n            /* We must explicitly forward ether to the underlying contract as well. */\n            let result := call(\n                gas(),\n                sload(target.slot),\n                callvalue(),\n                free_ptr,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(free_ptr, 0, returndatasize())\n\n            if iszero(result) {\n                revert(free_ptr, returndatasize())\n            }\n            return(free_ptr, returndatasize())\n        }\n    }\n\n    function _onlyAuthorized() public {\n        address voyage = address(target.voyager());\n        IACLManager aclManager = IACLManager(\n            target.voyager().addressResolver().getAclManager()\n        );\n        require(\n            msg.sender == target.voyager().addressResolver().getVoyage() ||\n                aclManager.isLiquidityManager(msg.sender) ||\n                aclManager.isLoanManager(msg.sender),\n            \"Voyager or admin only function\"\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IVoyagerComponent.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Voyager} from \"../component/Voyager.sol\";\n\nabstract contract IVoyagerComponent {\n    Voyager public voyager;\n\n    function getPriceOracleAddress() internal view returns (address) {\n        return address(0);\n    }\n}\n"
    },
    "contracts/libraries/acl/ExtCallACLProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Proxy} from \"../proxy/Proxy.sol\";\nimport {IExtCallACL} from \"./IExtCallACL.sol\";\n\ncontract ExtCallACLProxy is Proxy {\n    function isWhitelistedAddress(address _address) public view returns (bool) {\n        return IExtCallACL(address(target)).isWhitelistedAddress(_address);\n    }\n\n    function isWhitelistedFunction(bytes32 _func) public view returns (bool) {\n        return IExtCallACL(address(target)).isWhitelistedFunction(_func);\n    }\n}\n"
    },
    "contracts/component/infra/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {IPriceOracle} from \"../../interfaces/IPriceOracle.sol\";\nimport {Voyager} from \"../Voyager.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {WadRayMath} from \"../../libraries/math/WadRayMath.sol\";\nimport {IACLManager} from \"../../interfaces/IACLManager.sol\";\n\ncontract PriceOracle is IPriceOracle {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    struct CumulativePrice {\n        uint256 priceCumulativeLast;\n        uint256 blockTimestampLast;\n        uint256 priceAverage;\n    }\n\n    struct PriceData {\n        uint256 priceCumulative;\n        uint256 blockTimestamp;\n    }\n\n    modifier onlyAdmin() {\n        _requireCallerAdmin();\n        _;\n    }\n\n    mapping(address => CumulativePrice) prices;\n    mapping(address => PriceData) ticket;\n\n    Voyager voyager;\n\n    constructor(address payable _voyager) {\n        voyager = Voyager(_voyager);\n    }\n\n    function getAssetPrice(address _asset) external view returns (uint256) {\n        return prices[_asset].priceAverage;\n    }\n\n    function updateAssetPrice(address _asset) external onlyAdmin {\n        _updateAssetPrice(_asset);\n    }\n\n    function updateAssetPrices(address[] calldata _assets) external onlyAdmin {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _updateAssetPrice(_assets[i]);\n        }\n    }\n\n    function updateCumulative(address _asset, uint256 _price)\n        external\n        onlyAdmin\n    {\n        _updateCumulative(_asset, _price);\n    }\n\n    function updateCumulativeBatch(\n        address[] calldata _assets,\n        uint256[] calldata _prices\n    ) external onlyAdmin {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _updateCumulative(_assets[i], _prices[i]);\n        }\n    }\n\n    function currentCumulativePrice(address _asset)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        PriceData storage pd = ticket[_asset];\n        return (pd.priceCumulative, pd.blockTimestamp);\n    }\n\n    function _updateAssetPrice(address _asset) internal {\n        CumulativePrice storage cp = prices[_asset];\n        // period check\n        (\n            uint256 priceCumulative,\n            uint256 blockTimeStamp\n        ) = currentCumulativePrice(_asset);\n        uint256 timeElapsed = blockTimeStamp - cp.blockTimestampLast;\n        cp.priceAverage = priceCumulative.sub(cp.priceCumulativeLast).div(\n            timeElapsed\n        );\n        cp.priceCumulativeLast = priceCumulative;\n        cp.blockTimestampLast = blockTimeStamp;\n    }\n\n    function _updateCumulative(address _asset, uint256 _price) internal {\n        PriceData storage pd = ticket[_asset];\n        uint256 timeElapsed = block.timestamp.sub(pd.blockTimestamp);\n        pd.priceCumulative = pd.priceCumulative.add(_price.mul(timeElapsed));\n        pd.blockTimestamp = block.timestamp;\n    }\n\n    function _requireCallerAdmin() internal {\n        IACLManager aclManager = IACLManager(\n            voyager.addressResolver().getAclManager()\n        );\n        require(aclManager.isOracleManager(msg.sender), \"Not oracle admin\");\n    }\n}\n"
    },
    "contracts/libraries/financial/LibFinancial.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\n\nlibrary LibFinancial {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant TYEAR = 31536000;\n    uint256 internal constant TMOTH = 2592000;\n\n    /**\n     * @dev Function to compute the payment against loan principal plus interest\n     * The payment is computed by solving the equation:\n     *  fv + pv*(1 + rate)**nper + pmt*(1 + rate*when(0))/rate*((1 + rate)**nper - 1) == 0\n     * @param rate The interest rate per period, in Ray\n     * @param nper Number of compounding periods\n     * @param pv Present value (amount borrowed)\n     * @return The fixed periodic payment, in wad\n     **/\n    function pmt(\n        uint256 rate,\n        uint256 nper,\n        uint256 pv\n    ) public view returns (uint256, bool) {\n        uint256 temp = rate.add(RAY).rayPow(nper);\n        uint256 masked_rate = rate;\n        uint256 fact = nper;\n        if (rate == 0) {\n            masked_rate = RAY;\n        } else {\n            fact = temp.sub(RAY).rayDiv(masked_rate);\n        }\n\n        uint256 pvRay = pv.wadToRay();\n        return (pvRay.rayMul(temp).rayDiv(fact).rayToWad(), false);\n    }\n\n    /**\n     * @dev Function to compute the future value\n     * @param rate The interest rate\n     * @param nper Number of compounding periods\n     * @param pmt Payment\n     * @param pv Present value\n     * @return The future value, in wad\n     **/\n    function fv(\n        uint256 rate,\n        uint256 nper,\n        uint256 pmt,\n        bool pmtsign,\n        uint256 pv,\n        bool pvsign\n    ) public view returns (uint256) {\n        uint256 temp = rate.add(RAY).rayPow(nper);\n        uint256 pvRay = pv.wadToRay();\n        uint256 pmtRay = pmt.wadToRay();\n        uint256 parta = temp.rayMul(pvRay);\n        uint256 partb = pmtRay.rayDiv(rate).rayMul(temp.sub(RAY));\n        uint256 fv = 0;\n        if (pvsign && !pmtsign) {\n            fv = parta.sub(partb);\n        } else if (!pvsign && pmtsign) {\n            fv = partb.sub(parta);\n        } else {\n            fv = parta.add(partb);\n        }\n        return fv.rayToWad();\n    }\n\n    /**\n     * @dev Function to compute the interest portion of a payment\n     * @param rate The interest rate\n     * @param per The payment period to calculate the interest amount\n     * @param nper Number of compounding periods\n     * @param pv Present value\n     * @return The interest portion of payment, in wad\n     **/\n    function ipmt(\n        uint256 rate,\n        uint256 per,\n        uint256 nper,\n        uint256 pv\n    ) public view returns (uint256) {\n        (uint256 totalPmt, bool pmtsign) = pmt(rate, nper, pv);\n        uint256 fvRay = fv(rate, per - 1, totalPmt, pmtsign, pv, true)\n            .wadToRay();\n        return fvRay.rayMul(rate).rayDiv(rate.add(RAY)).rayToWad();\n    }\n\n    /**\n     * @dev Function to compute the payment against load principal\n     * @param rate The interest rate\n     * @param per The payment period to calculate the interest amount\n     * @param nper Number of compounding periods\n     * @param pv Present value\n     * @return The payment, in wad\n     **/\n    function ppmt(\n        uint256 rate,\n        uint256 per,\n        uint256 nper,\n        uint256 pv\n    ) public view returns (uint256) {\n        (uint256 totalPmt, bool sign) = pmt(rate, nper, pv);\n        return totalPmt.sub(ipmt(rate, per, nper, pv));\n    }\n\n    /**\n     * @dev Function to compute the adjusted equivalent nominal borrow rate\n     * @param rate The interest rate\n     * @param epoch Payment period\n     **/\n    function adjustedAPR(uint256 rate, uint256 epoch)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 temp = rate.div(TYEAR).add(RAY).rayPow(epoch);\n        uint256 epy = TYEAR.rayDiv(epoch);\n        return temp.sub(RAY).rayMul(epy);\n    }\n}\n"
    },
    "contracts/libraries/CoreLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {WadRayMath} from \"./math/WadRayMath.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary CoreLibrary {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    enum Tranche {\n        JUNIOR,\n        SENIOR\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: Liq. bonus\n        //bit 16-23: Decimals\n        //bit 24: Reserve is active\n        //bit 25: reserve is frozen\n        //bit 26: borrowing is enabled\n        //bit 27-30: reserved\n        //bit 31-46: reserve factor\n        //bit 47-62: lock up period in seconds\n        uint256 data;\n    }\n\n    struct ReserveData {\n        ReserveConfigurationMap config;\n        // for calculating overall interested accumulated\n        // then split it into two indexs base on two allocations\n        uint256 currentOverallLiquidityRate;\n        // Expressed in ray\n        uint256 currentSeniorIncomeAllocation;\n        // Expressed in ray\n        uint256 currentJuniorIncomeAllocation;\n        uint256 totalBorrows;\n        uint256 currentBorrowRate;\n        // Expressed in ray\n        uint256 securityRequirement;\n        //the decimals of the reserve asset\n        uint256 decimals;\n        address interestRateStrategyAddress;\n        address jdTokenAddress;\n        address sdTokenAddress;\n        uint40 lastUpdateTimestamp;\n    }\n\n    // use a mapping mapping(address => Deposit[]) to track amount that can be withdrawn\n    // not sure if this should in the vToken contract\n    struct Deposit {\n        Tranche tranche;\n        uint256 startDate;\n        uint256 lockFor;\n        uint256 amount;\n    }\n\n    function init(\n        ReserveData storage _self,\n        address _jdTokenAddress,\n        address _sdTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress,\n        uint256 _securityRequirement\n    ) external {\n        require(\n            _self.jdTokenAddress == address(0),\n            \"Reserve has already been initialized\"\n        );\n        _self.jdTokenAddress = _jdTokenAddress;\n        _self.sdTokenAddress = _sdTokenAddress;\n        _self.decimals = _decimals;\n\n        _self.securityRequirement = _securityRequirement;\n        _self.interestRateStrategyAddress = _interestRateStrategyAddress;\n    }\n\n    /**\n     * @dev returns the total borrows on the reserve\n     * @param _reserve the reserve object\n     * @return the total borrows (stable + variable)\n     **/\n    function getTotalBorrows(CoreLibrary.ReserveData storage _reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        return _reserve.totalBorrows;\n    }\n}\n"
    },
    "contracts/component/liquidity/DefaultReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IVToken} from \"../../interfaces/IVToken.sol\";\nimport {WadRayMath} from \"../../libraries/math/WadRayMath.sol\";\nimport {IReserveInterestRateStrategy} from \"../../interfaces/IReserveInterestRateStrategy.sol\";\n\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n    /**\n     * this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates\n     * Expressed in RAY\n     **/\n    uint256 public immutable OPTIMAL_UTILIZATION_RATE;\n\n    // Base interest rate set by governance. Expressed in ray\n    uint256 internal immutable baseBorrowRate;\n\n    // Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 internal immutable stableRateSlope1;\n\n    // Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 internal immutable stableRateSlope2;\n\n    constructor(\n        uint256 _optimalUtilizationRate,\n        uint256 _stableRateSlope1,\n        uint256 _stableRateSlope2,\n        uint256 _baseBorrowRate\n    ) public {\n        OPTIMAL_UTILIZATION_RATE = _optimalUtilizationRate;\n        baseBorrowRate = _baseBorrowRate;\n        stableRateSlope1 = _stableRateSlope1;\n        stableRateSlope2 = _stableRateSlope2;\n    }\n\n    struct CalcInterestRatesLocalVars {\n        uint256 totalDebt;\n        uint256 currentStableBorrowRate;\n        uint256 currentLiquidityRate;\n        uint256 utilizationRate;\n    }\n\n    /**\n     * @dev Calculates the interest rates depending on the reserve's state and configuration\n     * @param reserve The address of the reserve\n     * @param seniorDepositTokenAddress The address of senior deposit token\n     * @param liquidityAdded The liquidity added during the operation\n     * @param liquidityTaken The liquidity taken during the operation\n     * @param totalStableDebt The total borrowed from the reserve a stable rate\n     * @param averageBorrowRate The current average borrow rate\n     **/\n    function calculateInterestRates(\n        address reserve,\n        address seniorDepositTokenAddress,\n        uint256 liquidityAdded,\n        uint256 liquidityTaken,\n        uint256 totalStableDebt,\n        uint256 averageBorrowRate\n    ) external view returns (uint256, uint256) {\n        uint256 totalPendingWithdrawal = IVToken(seniorDepositTokenAddress)\n            .totalUnbonding();\n\n        uint256 availableLiquidity = IERC20(reserve).balanceOf(\n            seniorDepositTokenAddress\n        ) - totalPendingWithdrawal;\n\n        availableLiquidity = availableLiquidity.add(liquidityAdded).sub(\n            liquidityTaken\n        );\n        return\n            calculateInterestRates(\n                reserve,\n                availableLiquidity,\n                totalStableDebt,\n                averageBorrowRate\n            );\n    }\n\n    /**\n     * @dev Calculates the interest rates depending on the reserve's state and configurations.\n     * @param reserve The address of the reserve\n     * @param availableLiquidity The liquidity available in the corresponding aToken\n     * @param totalStableDebt The total borrowed from the reserve a stable rate\n     * @param averageBorrowRate The current average borrow rate\n     * @return The liquidity rate, the stable borrow rate\n     **/\n    function calculateInterestRates(\n        address reserve,\n        uint256 availableLiquidity,\n        uint256 totalStableDebt,\n        uint256 averageBorrowRate\n    ) public view returns (uint256, uint256) {\n        CalcInterestRatesLocalVars memory vars;\n\n        vars.totalDebt = totalStableDebt;\n        vars.currentStableBorrowRate = baseBorrowRate;\n        vars.currentLiquidityRate = 0;\n\n        vars.utilizationRate = vars.totalDebt == 0\n            ? 0\n            : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\n\n        if (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) {\n            vars.currentStableBorrowRate = vars\n                .currentStableBorrowRate\n                .add(stableRateSlope1)\n                .add(\n                    stableRateSlope2\n                        .rayMul(\n                            vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE)\n                        )\n                        .rayDiv(WadRayMath.Ray().sub(OPTIMAL_UTILIZATION_RATE))\n                );\n        } else {\n            vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(\n                stableRateSlope1.rayMul(vars.utilizationRate).rayDiv(\n                    OPTIMAL_UTILIZATION_RATE\n                )\n            );\n        }\n\n        vars.currentLiquidityRate = averageBorrowRate.rayMul(\n            vars.utilizationRate\n        );\n        return (vars.currentLiquidityRate, vars.currentStableBorrowRate);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/component/facets/SecurityFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Storage} from \"../../libraries/LibAppStorage.sol\";\n\ncontract SecurityFacet is Storage {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    function paused() public view returns (bool) {\n        return s._paused;\n    }\n\n    function pause() public onlyAdmin {\n        s._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    function unpause() public onlyAdmin {\n        s._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/mock/Tus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Tus is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"Treasure Under Sea\", \"TUS\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"
    },
    "contracts/libraries/state/State.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract State is Ownable {\n    mapping(address => bool) public associatedContracts;\n\n    constructor(address _associatedContract) {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner() != address(0), \"Owner must be set\");\n\n        associatedContracts[_associatedContract] = true;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    event AssociatedContractUpdated(address associatedContract);\n\n    modifier onlyAssociatedContract() {\n        require(\n            associatedContracts[msg.sender],\n            \"Only the associated contract can perform this action\"\n        );\n        _;\n    }\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract)\n        external\n        onlyOwner\n    {\n        associatedContracts[_associatedContract] = true;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n}\n"
    },
    "contracts/component/infra/ACLManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IACLManager} from \"../../interfaces/IACLManager.sol\";\n\ncontract ACLManager is AccessControl, IACLManager {\n    bytes32 public constant VOYAGER_ADMIN_ROLE = keccak256(\"VOYAGER_ADMIN\");\n\n    bytes32 public constant LIQUIDITY_MANAGER_CONTRACT_ROLE =\n        keccak256(\"LIQUIDITY_MANAGER_CONTRACT\");\n\n    bytes32 public constant LIQUIDITY_MANAGER_ADMIN_ROLE =\n        keccak256(\"LIQUIDITY_MANAGER_ADMIN\");\n\n    bytes32 public constant VAULT_MANAGER_ADMIN_ROLE =\n        keccak256(\"VAULT_MANAGER_ADMIN\");\n\n    bytes32 public constant VAULT_MANAGER_CONTRACT_ROLE =\n        keccak256(\"VAULT_MANAGER_CONTRACT\");\n\n    bytes32 public constant LOAN_MANAGER_ADMIN_ROLE =\n        keccak256(\"LOAN_MANAGER_ADMIN\");\n\n    bytes32 public constant LOAN_MANAGER_CONTRACT_ROLE =\n        keccak256(\"LOAN_MANAGER_CONTRACT\");\n\n    bytes32 public constant VAULT_CONFIGURATOR =\n        keccak256(\"VAULT_CONFIGURATOR\");\n\n    bytes32 public constant VOYAGER_CONTRACT_ROLE =\n        keccak256(\"VOYAGER_CONTRACT\");\n\n    bytes32 public constant ORACLE_MANAGER_ROLE = keccak256(\"ORACLE_MANAGER\");\n\n    constructor(address _aclAdmin) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _aclAdmin);\n    }\n\n    function grantLiquidityManagerContract(address _admin) external {\n        grantRole(LIQUIDITY_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function isLiquidityManagerContract(address _admin)\n        external\n        view\n        returns (bool)\n    {\n        return hasRole(LIQUIDITY_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function grantLiquidityManager(address _admin) external {\n        grantRole(LIQUIDITY_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function isLiquidityManager(address _admin) external view returns (bool) {\n        return hasRole(LIQUIDITY_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function grantLoanManagerContract(address _admin) external {\n        grantRole(LOAN_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function isLoanManagerContract(address _admin)\n        external\n        view\n        returns (bool)\n    {\n        return hasRole(LOAN_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function grantLoanManager(address _admin) external {\n        grantRole(LOAN_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function isLoanManager(address _admin) external view returns (bool) {\n        return hasRole(LOAN_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function grantVaultManager(address _admin) external {\n        grantRole(VAULT_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function isVaultManager(address _admin) external view returns (bool) {\n        return hasRole(VAULT_MANAGER_ADMIN_ROLE, _admin);\n    }\n\n    function grantVaultManagerContract(address _admin) external {\n        grantRole(VAULT_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function isVaultManagerContract(address _admin)\n        external\n        view\n        returns (bool)\n    {\n        return hasRole(VAULT_MANAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function grantPoolManager(address _admin) external {\n        grantRole(VOYAGER_ADMIN_ROLE, _admin);\n    }\n\n    function isProtocolManager(address _admin) external view returns (bool) {\n        return hasRole(VOYAGER_ADMIN_ROLE, _admin);\n    }\n\n    function grantVaultConfigurator(address _amin) external {\n        grantRole(VAULT_CONFIGURATOR, _amin);\n    }\n\n    function isVaultConfigurator(address _admin) external view returns (bool) {\n        return hasRole(VAULT_CONFIGURATOR, _admin);\n    }\n\n    function grantVoyagerContract(address _admin) external {\n        grantRole(VOYAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function isVoyagerContract(address _admin) external view returns (bool) {\n        return hasRole(VOYAGER_CONTRACT_ROLE, _admin);\n    }\n\n    function grantOracleManager(address _admin) external {\n        grantRole(ORACLE_MANAGER_ROLE, _admin);\n    }\n\n    function isOracleManager(address _admin) external view returns (bool) {\n        return hasRole(ORACLE_MANAGER_ROLE, _admin);\n    }\n}\n"
    },
    "contracts/component/loan/DefaultLoanStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\nimport {ILoanStrategy} from \"../../interfaces/ILoanStrategy.sol\";\n\ncontract DefaultLoanStrategy is ILoanStrategy {\n    uint256 public immutable term;\n\n    uint256 public immutable epoch;\n\n    uint256 public immutable grace;\n\n    // express in ray\n    uint256 public immutable liquidationBonus;\n\n    // express in ray\n    uint256 public immutable marginRequirement;\n\n    constructor(\n        uint256 _term,\n        uint256 _epoch,\n        uint256 _grace,\n        uint256 _liquidationBonus,\n        uint256 _marginRequirement\n    ) public {\n        term = _term;\n        epoch = _epoch;\n        grace = _grace;\n        liquidationBonus = _liquidationBonus;\n        marginRequirement = _marginRequirement;\n    }\n\n    function getTerm() external view returns (uint256) {\n        return term;\n    }\n\n    function getEpoch() external view returns (uint256) {\n        return epoch;\n    }\n\n    function getGrace() external view returns (uint256) {\n        return grace;\n    }\n\n    function getLiquidateBonus() external view returns (uint256) {\n        return liquidationBonus;\n    }\n\n    function getMarginRequirement() external view returns (uint256) {\n        return marginRequirement;\n    }\n\n    function getLiquidationParams()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (grace, liquidationBonus, marginRequirement);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}