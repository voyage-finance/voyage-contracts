{
  "address": "0x60D4D14777063d7372BfFC82519cD652c5fC46CE",
  "abi": [
    {
      "inputs": [],
      "name": "InsufficientCreditLimit",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientLiquidity",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidDebt",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFloorPrice",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidLiquidate",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidPrincipal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidValueTransfered",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "PRBMathUD60x18__LogInputTooSmall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Unauthorised",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_vault",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_currency",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_loanId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_principal",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_interest",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_apr",
          "type": "uint256"
        }
      ],
      "name": "Borrow",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "collection",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "collaterals",
          "type": "uint256[]"
        }
      ],
      "name": "CollateralTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_liquidator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_vault",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_drowDownId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_repaymentId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_debt",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_fromJuniorTranche",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amountToWriteDown",
          "type": "uint256"
        }
      ],
      "name": "Liquidate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_vault",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_currency",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_loanId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_repaymentId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isFinal",
          "type": "bool"
        }
      ],
      "name": "Repayment",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "TEN_THOUSANDS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address payable",
          "name": "_vault",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_marketplace",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "buyNow",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vault",
          "type": "address"
        }
      ],
      "name": "getVaultDebt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        }
      ],
      "name": "interestBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vault",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_loanId",
          "type": "uint256"
        }
      ],
      "name": "liquidate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "previewBuyNowParams",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "collection",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "marketplace",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalPrincipal",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalInterest",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalDebt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outstandingPrincipal",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outstandingInterest",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outstandingDebt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fv",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "term",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "epoch",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nper",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "downpayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityRate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowRate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "availableLiquidity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalPending",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "loanId",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interest",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "pmt",
                  "type": "uint256"
                }
              ],
              "internalType": "struct PMT",
              "name": "pmt",
              "type": "tuple"
            }
          ],
          "internalType": "struct LoanFacet.ExecuteBuyNowParams",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        }
      ],
      "name": "principalBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_collection",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_loan",
          "type": "uint256"
        },
        {
          "internalType": "address payable",
          "name": "_vault",
          "type": "address"
        }
      ],
      "name": "repay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc976a06d254e08cba2ad69f8eaa8628857aa76e6b176b2e847edc62c5284b05f",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x7bB17c9401110D05ec39894334cC9d7721E90688",
    "contractAddress": null,
    "transactionIndex": 8,
    "gasUsed": "3730118",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8ea7f9dab06d79597461254b9eac96f9ca50ed5c6982a76c7b2ec95d44f80be4",
    "transactionHash": "0xc976a06d254e08cba2ad69f8eaa8628857aa76e6b176b2e847edc62c5284b05f",
    "logs": [],
    "blockNumber": 11206285,
    "cumulativeGasUsed": "4807432",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "c9e2852726c34147f2de6a7208824664",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InsufficientCreditLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDebt\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFloorPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLiquidate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrincipal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidValueTransfered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PRBMathUD60x18__LogInputTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorised\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_principal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_interest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_apr\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"collaterals\",\"type\":\"uint256[]\"}],\"name\":\"CollateralTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_drowDownId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_repaymentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromJuniorTranche\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountToWriteDown\",\"type\":\"uint256\"}],\"name\":\"Liquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_repaymentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"name\":\"Repayment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TEN_THOUSANDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketplace\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"buyNow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"getVaultDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"interestBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"previewBuyNowParams\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalPrincipal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outstandingPrincipal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outstandingInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outstandingDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"downpayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pmt\",\"type\":\"uint256\"}],\"internalType\":\"struct PMT\",\"name\":\"pmt\",\"type\":\"tuple\"}],\"internalType\":\"struct LoanFacet.ExecuteBuyNowParams\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"principalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loan\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"interestBalance(address)\":{\"params\":{\"_collection\":\"the address of the underlying nft collection.\"},\"returns\":{\"_0\":\"The total outstanding interest owed to depositors.\"}},\"principalBalance(address)\":{\"params\":{\"_collection\":\"the address of the underlying nft collection.\"},\"returns\":{\"_0\":\"The total outstanding principal owed to depositors.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"interestBalance(address)\":{\"notice\":\"Returns the total outstanding interest debt for a particular underlying asset pool\"},\"principalBalance(address)\":{\"notice\":\"Returns the total outstanding principal debt for a particular underlying asset pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/voyage/facets/LoanFacet.sol\":\"LoanFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7454006cccb737612b00104d2f606d728e2818b778e7e55542f063c614ce46ba\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0xb71b875e7f1b8ad082eb6ff83bca4bfa7d050476cc98fd39295826b654edfb46\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/cryptography/draft-EIP712Upgradeable.sol\\\";\\nimport \\\"../../../utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"../../../utils/CountersUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n *\\n * @custom:storage-size 51\\n */\\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    /**\\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\\n     * to reserve a slot.\\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\\n        __EIP712_init_unchained(name, \\\"1\\\");\\n    }\\n\\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view virtual override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n     *\\n     * _Available since v4.1._\\n     */\\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\\n        current = nonce.current();\\n        nonce.increment();\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x564385ebed633694decce3e13d687f3ac7e8eaef64f7a504bfb3f03ad210601f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xcc70d8e2281fb3ff69e8ab242500f10142cd0a7fa8dd9e45882be270d4d09024\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0x798741e231b22b81e2dd2eddaaf8832dee4baf5cd8e2dbaa5c1dd12a1c053c4d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x398d3323c1932a5986bf36be7c57593e121e69d5db5b6574b4ee0d031443de37\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x6602a65e0277f31f45cad4c7a15b024fd182f2f0e01eaa1954103b0d57848a27\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSAUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n *\\n * @custom:storage-size 52\\n */\\nabstract contract EIP712Upgradeable is Initializable {\\n    /* solhint-disable var-name-mixedcase */\\n    bytes32 private _HASHED_NAME;\\n    bytes32 private _HASHED_VERSION;\\n    bytes32 private constant _TYPE_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\\n        __EIP712_init_unchained(name, version);\\n    }\\n\\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev The hash of the name parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\\n        return _HASHED_NAME;\\n    }\\n\\n    /**\\n     * @dev The hash of the version parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\\n        return _HASHED_VERSION;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xaf5a96100f421d61693605349511e43221d3c2e47d4b3efa87af2b936e2567fc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x0705a4b1b86d7b0bd8432118f226ba139c44b9dcaba0a6eafba2dd7d0639c544\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xabf3f59bc0e5423eae45e459dbe92e7052c6983628d39008590edc852a62f94a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor(address beacon, bytes memory data) payable {\\n        _upgradeBeaconToAndCall(beacon, data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address) {\\n        return _getBeacon();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_getBeacon()).implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        _upgradeBeaconToAndCall(beacon, data, false);\\n    }\\n}\\n\",\"keccak256\":\"0x85439e74ab467b6a23d45d32bdc9506cbc3760320289afd605f11638c4138e95\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../../access/Ownable.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\\n * implementation contract, which is where they will delegate all function calls.\\n *\\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\\n */\\ncontract UpgradeableBeacon is IBeacon, Ownable {\\n    address private _implementation;\\n\\n    /**\\n     * @dev Emitted when the implementation returned by the beacon is changed.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\\n     * beacon.\\n     */\\n    constructor(address implementation_) {\\n        _setImplementation(implementation_);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function implementation() public view virtual override returns (address) {\\n        return _implementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the beacon to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * Requirements:\\n     *\\n     * - msg.sender must be the owner of the contract.\\n     * - `newImplementation` must be a contract.\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation contract address for this beacon\\n     *\\n     * Requirements:\\n     *\\n     * - `newImplementation` must be a contract.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableBeacon: implementation is not a contract\\\");\\n        _implementation = newImplementation;\\n    }\\n}\\n\",\"keccak256\":\"0x6ec71aef5659f3f74011169948d2fcda8c6599be5bb38f986380a8737f96cc0f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2a21b14ff90012878752f230d3ffd5c3405e5938d06c97a7d89c0a64561d0d66\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0x0849d93b16c9940beb286a7864ed02724b248b93e0d80ef6355af5ef15c64773\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x0e9621f60b2faabe65549f7ed0f24e8853a45c1b7990d47e8160e523683f3935\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x032807210d1d7d218963d7355d62e021a84bf1b3339f4f50be2f63b53cccaf29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xed6a749c5373af398105ce6ee3ac4763aa450ea7285d268c85d9eeca809cdb1f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd6153ce99bcdcce22b124f755e72553295be6abcd63804cfdffceb188b8bef10\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5c50c54bf02740ebd122ff06832546cb5fa84486d52695a9ccfd11666e0c81d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\",\"keccak256\":\"0x91f5761576f1ff3ede392ea1205bb88d6eed520fdafdabb97da5c3518f8ad5c0\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x0240f7703cff32a61ee3e9fbb339e09a944260432a9ef37debf3692b1a6c8049\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x96ab2a92fbac88a704270b039691afb363c5a1ef1170fb0c955043e4da84b987\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xa28a1515702793c6b56b97272f75e05890fd82aa2e7ec47b41d4d56a81023f69\",\"license\":\"AGPL-3.0-only\"},\"contracts/shared/diamond/facets/DiamondCutFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\nimport \\\"../libraries/LibDiamond.sol\\\";\\n\\ncontract DiamondCutFacet is IDiamondCut {\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\\n    }\\n}\\n\",\"keccak256\":\"0x1ad930b2fb7a485ea9dc992bffe25b7f9ed400accf7eb19e06d0761457b7228d\",\"license\":\"MIT\"},\"contracts/shared/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x70cec56344b453ec59bcecd3541f711b4f439b5b7e35cc10306b2e82eaa399da\",\"license\":\"MIT\"},\"contracts/shared/diamond/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0x5b20558ac0a152f84527227fa50db6f113dd2241992cb8aa9b1a7dbd193c277f\",\"license\":\"MIT\"},\"contracts/shared/diamond/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\npragma experimental ABIEncoderV2;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79ecd45ef37ffd464dd3a612cd046e1b3ec6aed5efd767141c651e539bdee988\",\"license\":\"MIT\"},\"contracts/shared/diamond/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x6fae3084e63b6d8cca55d964865dc45e0c2abf2d0eb8fcd9a3fe7428441bf06a\",\"license\":\"MIT\"},\"contracts/shared/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport {IERC165} from \\\"../interfaces/IERC165.sol\\\";\\nimport {IERC173} from \\\"../interfaces/IERC173.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(\\n            msg.sender == diamondStorage().contractOwner,\\n            \\\"LibDiamond: Must be contract owner\\\"\\n        );\\n    }\\n\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] _diamondCut,\\n        address _init,\\n        bytes _calldata\\n    );\\n\\n    /// @notice Adds default diamond facets\\n    /// @dev This is always called in the Diamond constructor.\\n    /// @param _diamondCutFacet - address of DiamondCutFacet\\n    /// @param _diamondLoupeFacet - address of the DiamondLoupeFacet\\n    /// @param _ownershipFacet - address of the OwnershipFacet\\n    function addDiamondFunctions(\\n        address _diamondCutFacet,\\n        address _diamondLoupeFacet,\\n        address _ownershipFacet\\n    ) internal {\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](3);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n        cut[0] = IDiamondCut.FacetCut({\\n            facetAddress: _diamondCutFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        functionSelectors = new bytes4[](5);\\n        functionSelectors[0] = IDiamondLoupe.facets.selector;\\n        functionSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\\n        functionSelectors[3] = IDiamondLoupe.facetAddress.selector;\\n        functionSelectors[4] = IERC165.supportsInterface.selector;\\n        cut[1] = IDiamondCut.FacetCut({\\n            facetAddress: _diamondLoupeFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        functionSelectors = new bytes4[](2);\\n        functionSelectors[0] = IERC173.transferOwnership.selector;\\n        functionSelectors[1] = IERC173.owner.selector;\\n        cut[2] = IDiamondCut.FacetCut({\\n            facetAddress: _ownershipFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        diamondCut(cut, address(0), \\\"\\\");\\n    }\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (\\n            uint256 facetIndex;\\n            facetIndex < _diamondCut.length;\\n            facetIndex++\\n        ) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        // uint16 selectorCount = uint16(diamondStorage().selectors.length);\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        );\\n        uint16 selectorPosition = uint16(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            enforceHasContractCode(\\n                _facetAddress,\\n                \\\"LibDiamondCut: New facet has no code\\\"\\n            );\\n            ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition = uint16(ds.facetAddresses.length);\\n            ds.facetAddresses.push(_facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress == address(0),\\n                \\\"LibDiamondCut: Can't add function that already exists\\\"\\n            );\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\n                selector\\n            );\\n            ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress = _facetAddress;\\n            ds\\n                .selectorToFacetAndPosition[selector]\\n                .functionSelectorPosition = selectorPosition;\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        );\\n        uint16 selectorPosition = uint16(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            enforceHasContractCode(\\n                _facetAddress,\\n                \\\"LibDiamondCut: New facet has no code\\\"\\n            );\\n            ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition = uint16(ds.facetAddresses.length);\\n            ds.facetAddresses.push(_facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress != _facetAddress,\\n                \\\"LibDiamondCut: Can't replace function with same function\\\"\\n            );\\n            removeFunction(oldFacetAddress, selector);\\n            // add function\\n            ds\\n                .selectorToFacetAndPosition[selector]\\n                .functionSelectorPosition = selectorPosition;\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\n                selector\\n            );\\n            ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress = _facetAddress;\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(\\n            _facetAddress == address(0),\\n            \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n        );\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            removeFunction(oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n        );\\n        // an immutable function is a function defined directly in a diamond\\n        require(\\n            _facetAddress != address(this),\\n            \\\"LibDiamondCut: Can't remove immutable function\\\"\\n        );\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds\\n            .facetFunctionSelectors[_facetAddress]\\n            .functionSelectors\\n            .length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n                    selectorPosition\\n                ] = lastSelector;\\n            ds\\n                .selectorToFacetAndPosition[lastSelector]\\n                .functionSelectorPosition = uint16(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[\\n                    lastFacetAddressPosition\\n                ];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds\\n                    .facetFunctionSelectors[lastFacetAddress]\\n                    .facetAddressPosition = uint16(facetAddressPosition);\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata)\\n        internal\\n    {\\n        if (_init == address(0)) {\\n            require(\\n                _calldata.length == 0,\\n                \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\n            );\\n        } else {\\n            require(\\n                _calldata.length > 0,\\n                \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\n            );\\n            if (_init != address(this)) {\\n                enforceHasContractCode(\\n                    _init,\\n                    \\\"LibDiamondCut: _init address has no code\\\"\\n                );\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(\\n        address _contract,\\n        string memory _errorMessage\\n    ) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x76c53a3a50ee1b30d116263e1847c80b52f6705f7436d37ba91b0ddcb97657ff\",\"license\":\"MIT\"},\"contracts/shared/facets/PaymentsFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {PeripheryPayments} from \\\"../util/PeripheryPayments.sol\\\";\\nimport {Multicall} from \\\"../util/Multicall.sol\\\";\\nimport {SelfPermit} from \\\"../util/SelfPermit.sol\\\";\\nimport {LibAppStorage} from \\\"../../voyage/libraries/LibAppStorage.sol\\\";\\nimport {SafeTransferLib} from \\\"../libraries/SafeTransferLib.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract PaymentsFacet is PeripheryPayments, Multicall, SelfPermit {\\n    using SafeERC20 for IERC20;\\n\\n    function unwrapWETH9(uint256 amountMinimum, address recipient)\\n        public\\n        payable\\n    {\\n        uint256 balanceWETH9 = LibAppStorage.ds().WETH9.balanceOf(\\n            address(this)\\n        );\\n        require(balanceWETH9 >= amountMinimum, \\\"Insufficient WETH9\\\");\\n\\n        if (balanceWETH9 > 0) {\\n            LibAppStorage.ds().WETH9.withdraw(balanceWETH9);\\n            SafeTransferLib.safeTransferETH(recipient, balanceWETH9);\\n        }\\n    }\\n\\n    function wrapWETH9() public payable {\\n        if (address(this).balance > 0)\\n            LibAppStorage.ds().WETH9.deposit{value: address(this).balance}(); // wrap everything\\n    }\\n\\n    function sweepToken(\\n        IERC20 token,\\n        uint256 amountMinimum,\\n        address recipient\\n    ) public payable {\\n        uint256 balanceToken = token.balanceOf(address(this));\\n        require(balanceToken >= amountMinimum, \\\"Insufficient token\\\");\\n\\n        if (balanceToken > 0) {\\n            token.safeTransfer(recipient, balanceToken);\\n        }\\n    }\\n\\n    function refundETH() external payable {\\n        if (address(this).balance > 0) {\\n            SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\\n        }\\n    }\\n}\\n\\nabstract contract IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable virtual;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external virtual;\\n}\\n\",\"keccak256\":\"0x40bcdf10b257d68182a70f2372505f8682f2ff7bf5b247ba24b2f6ee18e67863\",\"license\":\"MIT\"},\"contracts/shared/interfaces/IERC20PermitAllowed.sol\":{\"content\":\"// forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/external/IERC20PermitAllowed.sol\\n\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.9;\\n\\n/// @title Interface for permit\\n/// @notice Interface used by DAI/CHAI for permit\\ninterface IERC20PermitAllowed {\\n    /// @notice Approve the spender to spend some tokens via the holder signature\\n    /// @dev This is the permit interface used by DAI and CHAI\\n    /// @param holder The address of the token holder, the token owner\\n    /// @param spender The address of the token spender\\n    /// @param nonce The holder's nonce, increases at each call to permit\\n    /// @param expiry The timestamp at which the permit is no longer valid\\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0x75199ac09b8a0315f5bb8a4380df57a8443ef496443ab546d017ea6100b699bc\",\"license\":\"GPL-2.0-or-later\"},\"contracts/shared/interfaces/IERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport {IERC20PermitUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\\\";\\n\\n// https://github.dev/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/b392c249e2c72434c438e0e495af1bacbc6cfd4f/contracts/interfaces/IERC4626Upgradeable.sol#L21\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n *\\n * _Available since v4.7._\\n */\\ninterface IERC4626 is\\n    IERC20Upgradeable,\\n    IERC20MetadataUpgradeable,\\n    IERC20PermitUpgradeable\\n{\\n    event Deposit(\\n        address indexed caller,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (IERC20Metadata assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \\u201cmanaged\\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n     * \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets)\\n        external\\n        view\\n        returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n     * \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares)\\n        external\\n        view\\n        returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver)\\n        external\\n        view\\n        returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets)\\n        external\\n        view\\n        returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver)\\n        external\\n        returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver)\\n        external\\n        view\\n        returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver)\\n        external\\n        returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner)\\n        external\\n        view\\n        returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets)\\n        external\\n        view\\n        returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares)\\n        external\\n        view\\n        returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets);\\n}\\n\",\"keccak256\":\"0x4ac6b252c94f945b2cc258e8f6f37a8e1f55a6a16cb4bb59bf2ce7ae620fa3fd\",\"license\":\"MIT\"},\"contracts/shared/interfaces/IMulticall.sol\":{\"content\":\"// forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/IMulticall.sol\\n\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.9;\\n\\n/// @title Multicall interface\\n/// @notice Enables calling multiple methods in a single call to the contract\\ninterface IMulticall {\\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\\n    /// @param data The encoded function data for each of the calls to make to this contract\\n    /// @return results The results from each of the calls passed in via data\\n    function multicall(bytes[] calldata data)\\n        external\\n        payable\\n        returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x8437eb20058eb64e08677e6ee16f3299c3d080235a99526374c984687762b69b\",\"license\":\"GPL-2.0-or-later\"},\"contracts/shared/interfaces/ISelfPermit.sol\":{\"content\":\"// forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISelfPermit.sol\\n\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.9;\\n\\n/// @title Self Permit\\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\\ninterface ISelfPermit {\\n    /// @notice Permits this contract to spend a given token from `msg.sender`\\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\\n    /// @param token The address of the token spent\\n    /// @param value The amount that can be spent of token\\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function selfPermit(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable;\\n\\n    /// @notice Permits this contract to spend a given token from `msg.sender`\\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\\n    /// @param token The address of the token spent\\n    /// @param value The amount that can be spent of token\\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function selfPermitIfNecessary(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable;\\n\\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\\n    /// @param token The address of the token spent\\n    /// @param nonce The current nonce of the owner\\n    /// @param expiry The timestamp at which the permit is no longer valid\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function selfPermitAllowed(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable;\\n\\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\\n    /// @param token The address of the token spent\\n    /// @param nonce The current nonce of the owner\\n    /// @param expiry The timestamp at which the permit is no longer valid\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function selfPermitAllowedIfNecessary(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x935d7c033290c44921175dd13c8dddf8e51057492e665c379058d7bf3ca67125\",\"license\":\"GPL-2.0-or-later\"},\"contracts/shared/interfaces/IWETH9.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nabstract contract IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable virtual;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external virtual;\\n}\\n\",\"keccak256\":\"0xb152cb59ad8329047c5fcfa6d46ca42bcce4a4b5ad2bf58bc1a0aeedff31e509\",\"license\":\"MIT\"},\"contracts/shared/libraries/LogarithmMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\n/// import from https://github.com/paulrberg/prb-math\\nlibrary LogarithmMath {\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log2(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = mostSignificantBit(x / SCALE);\\n\\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255 and SCALE is 1e18.\\n            result = n * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    error PRBMathUD60x18__LogInputTooSmall(uint256);\\n}\\n\",\"keccak256\":\"0x253ab2b6f0731ce0072f9d27c8f5d2c6a9766256dff3ab4438c8b415b90f309c\",\"license\":\"GPL-3.0\"},\"contracts/shared/libraries/PercentageMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title PercentageMath library\\n * @author Aave\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n **/\\nlibrary PercentageMath {\\n    // Maximum percentage factor (100.00%)\\n    uint256 internal constant PERCENTAGE_FACTOR = 1e4;\\n\\n    // Half percentage factor (50.00%)\\n    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\\n\\n    /**\\n     * @notice Executes a percentage multiplication\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return result value percentmul percentage\\n     **/\\n    function percentMul(uint256 value, uint256 percentage)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\\n        assembly {\\n            if iszero(\\n                or(\\n                    iszero(percentage),\\n                    iszero(\\n                        gt(\\n                            value,\\n                            div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)\\n                        )\\n                    )\\n                )\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            result := div(\\n                add(mul(value, percentage), HALF_PERCENTAGE_FACTOR),\\n                PERCENTAGE_FACTOR\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice Executes a percentage division\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return result value percentdiv percentage\\n     **/\\n    function percentDiv(uint256 value, uint256 percentage)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\\n        assembly {\\n            if or(\\n                iszero(percentage),\\n                iszero(\\n                    iszero(\\n                        gt(\\n                            value,\\n                            div(\\n                                sub(not(0), div(percentage, 2)),\\n                                PERCENTAGE_FACTOR\\n                            )\\n                        )\\n                    )\\n                )\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            result := div(\\n                add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)),\\n                percentage\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7a4336b20a181683c7e4754615409aea63f6b44a806b2d3d59b7aea4cc5cda57\",\"license\":\"GPL-3.0\"},\"contracts/shared/libraries/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\nETH OPERATIONS\\n//////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\nERC20 OPERATIONS\\n//////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x650ece776cbd21442a5b34775dfe0cd8b76f505ef5e072b198c3e35709b791d7\",\"license\":\"AGPL-3.0-only\"},\"contracts/shared/libraries/WadRayMath.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\n/******************\\n@title WadRayMath library\\n@author Aave\\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n */\\n\\nlibrary WadRayMath {\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant halfWAD = WAD / 2;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant halfRAY = RAY / 2;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    function Ray() public pure returns (uint256) {\\n        return RAY;\\n    }\\n\\n    function ray() internal pure returns (uint256) {\\n        return RAY;\\n    }\\n\\n    function wad() internal pure returns (uint256) {\\n        return WAD;\\n    }\\n\\n    function halfRay() internal pure returns (uint256) {\\n        return halfRAY;\\n    }\\n\\n    function halfWad() internal pure returns (uint256) {\\n        return halfWAD;\\n    }\\n\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (halfWAD + a * b) / WAD;\\n    }\\n\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 halfB = b / 2;\\n\\n        return (halfB + a * WAD) / b;\\n    }\\n\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (halfRAY + a * b) / RAY;\\n    }\\n\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 halfB = b / 2;\\n\\n        return (halfB + a * RAY) / b;\\n    }\\n\\n    function rayToWad(uint256 a) internal pure returns (uint256) {\\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\\n\\n        return (halfRatio + a) / WAD_RAY_RATIO;\\n    }\\n\\n    function wadToRay(uint256 a) internal pure returns (uint256) {\\n        return a * WAD_RAY_RATIO;\\n    }\\n\\n    // @dev calculates base^exp. The code uses the ModExp precompile\\n    // @return base^exp, in ray\\n    //solium-disable-next-line\\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rayMul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rayMul(z, x);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa58dbc7c0c21dc1bcaf58a6ae989fdf097a8c0ed7c66bd88cc3a29c1a21d1830\"},\"contracts/shared/tokenization/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ERC20PermitUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\\\";\\nimport {FixedPointMathLib} from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {IERC4626} from \\\"../interfaces/IERC4626.sol\\\";\\n\\nabstract contract ERC4626 is Initializable, ERC20PermitUpgradeable, IERC4626 {\\n    using SafeERC20 for IERC20Metadata;\\n    using FixedPointMathLib for uint256;\\n\\n    IERC20Metadata public asset;\\n\\n    /**\\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\\n     */\\n    function __ERC4626_init(IERC20Metadata _asset) internal onlyInitializing {\\n        __ERC4626_init_unchained(_asset);\\n    }\\n\\n    function __ERC4626_init_unchained(IERC20Metadata _asset)\\n        internal\\n        onlyInitializing\\n    {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver)\\n        public\\n        virtual\\n        returns (uint256 shares)\\n    {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver)\\n        public\\n        virtual\\n        returns (uint256 assets)\\n    {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            _spendAllowance(owner, msg.sender, shares);\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            _spendAllowance(owner, msg.sender, shares);\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf(owner));\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf(owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\",\"keccak256\":\"0x5f247251c57c1112b9ac73a48570439da0df661c277552b6a8b94d98a84ff28d\",\"license\":\"GPL-3.0\"},\"contracts/shared/util/Multicall.sol\":{\"content\":\"// forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol\\n\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.9;\\n\\nimport \\\"../interfaces/IMulticall.sol\\\";\\n\\n/// @title Multicall\\n/// @notice Enables calling multiple methods in a single call to the contract\\nabstract contract Multicall is IMulticall {\\n    /// @inheritdoc IMulticall\\n    function multicall(bytes[] calldata data)\\n        public\\n        payable\\n        override\\n        returns (bytes[] memory results)\\n    {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(\\n                data[i]\\n            );\\n\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7ea37766655ad050a0beca38b517a425be1f52bc165985891edcfcb46e0e7c77\",\"license\":\"GPL-2.0-or-later\"},\"contracts/shared/util/PeripheryPayments.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/// @title Depositor\\n/// @author Voyage Finance\\n/// @notice Forwards calls to ERC-4626 compliant Vaults, but with the actual depositor appended to the encoded call data.\\n/// @dev This does not work if the receiving contract does not implement ERC-4626!\\nabstract contract PeripheryPayments {\\n    using SafeERC20 for IERC20;\\n\\n    function pullToken(\\n        IERC20 token,\\n        uint256 amount,\\n        address from,\\n        address recipient\\n    ) public payable {\\n        token.safeTransferFrom(from, recipient, amount);\\n    }\\n\\n    function approve(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) public payable {\\n        token.safeApprove(to, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x6693bca3a626f4c685bb1c8d9a5812a248c45232e601f9fe1fac80bfd4379a1c\",\"license\":\"AGPL-3.0-only\"},\"contracts/shared/util/SelfPermit.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.9;\\n\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/ISelfPermit.sol\\\";\\nimport \\\"../interfaces/IERC20PermitAllowed.sol\\\";\\n\\n/// @title Self Permit\\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\\n/// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function\\n/// that requires an approval in a single transaction.\\nabstract contract SelfPermit is ISelfPermit {\\n    /// @inheritdoc ISelfPermit\\n    function selfPermit(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public payable override {\\n        IERC20Permit(token).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    /// @inheritdoc ISelfPermit\\n    function selfPermitIfNecessary(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable override {\\n        if (IERC20(token).allowance(msg.sender, address(this)) < value)\\n            selfPermit(token, value, deadline, v, r, s);\\n    }\\n\\n    /// @inheritdoc ISelfPermit\\n    function selfPermitAllowed(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public payable override {\\n        IERC20PermitAllowed(token).permit(\\n            msg.sender,\\n            address(this),\\n            nonce,\\n            expiry,\\n            true,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    /// @inheritdoc ISelfPermit\\n    function selfPermitAllowedIfNecessary(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable override {\\n        if (\\n            IERC20(token).allowance(msg.sender, address(this)) <\\n            type(uint256).max\\n        ) selfPermitAllowed(token, nonce, expiry, v, r, s);\\n    }\\n}\\n\",\"keccak256\":\"0x456e000cc02654d5e0df6b67960aa8a9c92b4f960ffa5d852e021ece7995bf20\",\"license\":\"AGPL-3.0-only\"},\"contracts/vault/SubVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {IVault} from \\\"./Vault.sol\\\";\\n\\ninterface ISubvault {\\n    function initialize(address _parent, address _owner) external;\\n\\n    function updateOwner(address _newOwner) external;\\n\\n    function callExternal(address target, bytes calldata data)\\n        external\\n        returns (bytes memory);\\n}\\n\\ncontract SubVault is Initializable, ISubvault, IERC721Receiver {\\n    struct SubVaultStorageV1 {\\n        address owner;\\n        address parent;\\n    }\\n\\n    // only `parent` should be able to call\\n    modifier authorised() {\\n        require(msg.sender == diamondStorage().parent, \\\"SubVault: only parent\\\");\\n        _;\\n    }\\n\\n    function initialize(address _owner, address _parent) external initializer {\\n        diamondStorage().owner = _owner;\\n        diamondStorage().parent = _parent;\\n    }\\n\\n    function callExternal(address target, bytes calldata data)\\n        external\\n        authorised\\n        returns (bytes memory)\\n    {\\n        (bool success, bytes memory ret) = target.call(data);\\n        require(success);\\n        return ret;\\n    }\\n\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4 ret) {\\n        if (\\n            !IVault(diamondStorage().parent).collectionInitialized(msg.sender)\\n        ) {\\n            revert InvalidSenderAddress();\\n        }\\n        IVault(diamondStorage().parent).onERC721Transferred(\\n            msg.sender,\\n            tokenId,\\n            from,\\n            address(this)\\n        );\\n    }\\n\\n    function updateOwner(address _newOwner) external authorised {\\n        diamondStorage().owner = _newOwner;\\n    }\\n\\n    function getOwner() public view returns (address) {\\n        return diamondStorage().owner;\\n    }\\n\\n    /************************************** Internal Functions **************************************/\\n\\n    // Returns the struct from a specified position in contract storage\\n    // ds is short for DiamondStorage\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (SubVaultStorageV1 storage ds)\\n    {\\n        // Specifies a random position in contract storage\\n        // This can be done with a keccak256 hash of a unique string as is\\n        // done here or other schemes can be used such as this:\\n        // bytes32 storagePosition = keccak256(abi.encodePacked(ERC1155.interfaceId, ERC1155.name, address(this)));\\n        bytes32 storagePosition = keccak256(\\n            \\\"finance.voyage.subvault.v1.storage\\\"\\n        );\\n        // Set the position of our struct in contract storage\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n}\\n\\n/* --------------------------------- errors -------------------------------- */\\nerror InvalidSenderAddress();\\n\",\"keccak256\":\"0x037b057969f0a046d5fbf6f47a2d00031a6083aefb6a93d2c56adb13ce9e32eb\",\"license\":\"GPL-3.0\"},\"contracts/vault/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {IERC1271} from \\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\";\\nimport {VaultFacet} from \\\"../voyage/facets/VaultFacet.sol\\\";\\nimport {SecurityFacet} from \\\"../voyage/facets/SecurityFacet.sol\\\";\\nimport {IWETH9} from \\\"../shared/interfaces/IWETH9.sol\\\";\\nimport {ISubvault} from \\\"./SubVault.sol\\\";\\n\\nstruct VaultStorageV1 {\\n    address voyage;\\n    address user;\\n    address paymaster;\\n    address weth;\\n    // subvault array, for retrieval by DataProviderFacet and client-side enumeration\\n    address[] subvaults;\\n    // mapping of subvault to owner\\n    mapping(address => address) subvaultOwnerIndex;\\n    // mapping of owner to subvault\\n    mapping(address => address) ownerSubvaultIndex;\\n    // mapping of subvault => paused status\\n    mapping(address => bool) subvaultStatusIndex;\\n    mapping(address => uint256[]) tokenSet;\\n    // mapping of erc721 address to mapping of tokenId to custody information\\n    // to save storage space, only store this data if the token is transferred out of the Vault (i.e., to a Subvault or external contract)\\n    mapping(address => mapping(uint256 => CustodyData)) custodyIndex;\\n}\\n\\nstruct CustodyData {\\n    // the \\\"owner\\\" of the token -- must be Vault or a Subvault.\\n    address owner;\\n    // the current holder of the token, e.g., battle game.\\n    address custodian;\\n}\\n\\nlibrary LibVaultStorage {\\n    // Returns the struct from a specified position in contract storage\\n    // ds is short for DiamondStorage\\n    function ds() internal pure returns (VaultStorageV1 storage ds) {\\n        // Set the position of our struct in contract storage\\n        bytes32 storagePosition = keccak256(\\\"diamond.storage.vault.voyage\\\");\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n}\\n\\ninterface IVault {\\n    event GasRefunded(\\n        address _paymaster,\\n        address _dst,\\n        uint256 _amount,\\n        uint256 _shortfall,\\n        bytes _result\\n    );\\n\\n    function initialize(\\n        address _voyage,\\n        address _user,\\n        address _paymaster,\\n        address _weth\\n    ) external;\\n\\n    function exec(bytes calldata _data) external;\\n\\n    function refundGas(uint256 _amount, address _dst) external;\\n\\n    function onERC721Transferred(\\n        address _collection,\\n        uint256 _tokenId,\\n        address _src,\\n        address _dst\\n    ) external;\\n\\n    function collectionInitialized(address _collection)\\n        external\\n        view\\n        returns (bool);\\n}\\n\\ncontract Vault is Initializable, IERC1271, IVault {\\n    bytes internal constant EMPTY_BYTES = \\\"\\\";\\n\\n    modifier onlyPaymaster() {\\n        require(_isPaymaster(msg.sender), \\\"Only paymaster allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuthorised() {\\n        SecurityFacet sf = SecurityFacet(LibVaultStorage.ds().voyage);\\n        require(\\n            sf.isAuthorised(msg.sender, address(this), msg.sig),\\n            \\\"unauthorised\\\"\\n        );\\n        _;\\n    }\\n\\n    function initialize(\\n        address _voyage,\\n        address _user,\\n        address _paymaster,\\n        address _weth\\n    ) public initializer {\\n        LibVaultStorage.ds().voyage = _voyage;\\n        LibVaultStorage.ds().user = _user;\\n        LibVaultStorage.ds().paymaster = _paymaster;\\n        LibVaultStorage.ds().weth = _weth;\\n    }\\n\\n    function exec(bytes calldata _data) external onlyAuthorised {\\n        (address target, bytes memory data) = abi.decode(\\n            _data,\\n            (address, bytes)\\n        );\\n        (bool success, bytes memory ret) = target.call(data);\\n        if (!success) {\\n            revert();\\n        }\\n    }\\n\\n    function refundGas(uint256 _amount, address _dst) external onlyPaymaster {\\n        uint256 amountRefundable = _amount;\\n        uint256 ethBal = address(this).balance;\\n        // we need to unwrap some WETH in this case.\\n        if (ethBal < _amount) {\\n            IWETH9 weth9 = IWETH9(LibVaultStorage.ds().weth);\\n            uint256 balanceWETH9 = weth9.balanceOf(address(this));\\n            uint256 toUnwrap = _amount - ethBal;\\n            // this should not happen, but if it does, we should take what we can instead of reverting\\n            if (toUnwrap > balanceWETH9) {\\n                weth9.withdraw(balanceWETH9);\\n                amountRefundable = amountRefundable - toUnwrap - balanceWETH9;\\n            } else {\\n                weth9.withdraw(toUnwrap);\\n            }\\n        }\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory result) = _dst.call{\\n            value: amountRefundable\\n        }(EMPTY_BYTES);\\n        if (!success) {\\n            revert GasRefundFailed(_dst);\\n        }\\n        emit GasRefunded(\\n            LibVaultStorage.ds().paymaster,\\n            _dst,\\n            amountRefundable,\\n            _amount - amountRefundable,\\n            result\\n        );\\n    }\\n\\n    function callSubVault(\\n        address _subvault,\\n        address _target,\\n        bytes calldata _data\\n    ) external onlyAuthorised {\\n        SecurityFacet sf = SecurityFacet(LibVaultStorage.ds().voyage);\\n        if (\\n            !sf.isAuthorised(\\n                msg.sender,\\n                _subvault,\\n                ISubvault(address(0)).callExternal.selector\\n            )\\n        ) {\\n            revert UnAuthorised();\\n        }\\n\\n        ISubvault(_subvault).callExternal(_target, _data);\\n    }\\n\\n    function collectionInitialized(address _collection)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        VaultFacet vf = VaultFacet(LibVaultStorage.ds().voyage);\\n        return vf.collectionInitialized(_collection);\\n    }\\n\\n    /// @notice Update subvault's owner\\n    /// @param _subvault The address of the subvaault\\n    /// @param _newOwner The address of the new owner\\n    function updateSubvaultOwner(address _subvault, address _newOwner)\\n        external\\n        onlyAuthorised\\n    {\\n        address oldOwner = LibVaultStorage.ds().subvaultOwnerIndex[_subvault];\\n        if (oldOwner == address(0)) {\\n            revert InvalidSubvaultAddress(_subvault);\\n        }\\n        ISubvault(_subvault).updateOwner(_newOwner);\\n        LibVaultStorage.ds().subvaultOwnerIndex[_subvault] = _newOwner;\\n        LibVaultStorage.ds().ownerSubvaultIndex[_newOwner] = _subvault;\\n        delete LibVaultStorage.ds().ownerSubvaultIndex[oldOwner];\\n    }\\n\\n    /// @notice Pause sub vault\\n    /// @param _subvault The address of the subvault\\n    function pauseSubvault(address _subvault) external {\\n        if (LibVaultStorage.ds().subvaultOwnerIndex[_subvault] == address(0)) {\\n            revert InvalidSubvaultAddress(_subvault);\\n        }\\n        LibVaultStorage.ds().subvaultStatusIndex[_subvault] = true;\\n    }\\n\\n    /// @notice Uppause the sub vault\\n    /// @param _subvault The address of the subvault\\n    function unpauseSubvault(address _subvault) external {\\n        if (LibVaultStorage.ds().subvaultOwnerIndex[_subvault] == address(0)) {\\n            revert InvalidSubvaultAddress(_subvault);\\n        }\\n        LibVaultStorage.ds().subvaultStatusIndex[_subvault] = false;\\n    }\\n\\n    function onERC721Transferred(\\n        address _collection,\\n        uint256 _tokenId,\\n        address _src,\\n        address _dst\\n    ) external {\\n        if (\\n            msg.sender != address(this) &&\\n            LibVaultStorage.ds().subvaultOwnerIndex[msg.sender] == address(0)\\n        ) {\\n            revert InvalidTransfer(\\\"invalid sender\\\");\\n        }\\n        if (\\n            LibVaultStorage.ds().custodyIndex[_collection][_tokenId].owner !=\\n            address(0)\\n        ) {\\n            revert InvalidTransfer(\\\"invalid token id\\\");\\n        }\\n        LibVaultStorage.ds().custodyIndex[_collection][_tokenId].owner = _src;\\n        LibVaultStorage.ds().tokenSet[_collection].push(_tokenId);\\n    }\\n\\n    /// @notice Called by erc721 contract or sub vaults\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4 ret) {\\n        VaultFacet vf = VaultFacet(LibVaultStorage.ds().voyage);\\n        // todo\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /// @notice Should return whether the signature provided is valid for the provided data\\n    /// @param hash      Hash of the data to be signed\\n    /// @param signature Signature byte array associated with _data\\n    function isValidSignature(bytes32 hash, bytes memory signature)\\n        external\\n        view\\n        returns (bytes4 magicValue)\\n    {\\n        address sender = recoverSigner(hash, signature);\\n        if (LibVaultStorage.ds().user == sender) {\\n            return 0x1626ba7e;\\n        }\\n        return 0xffffffff;\\n    }\\n\\n    /// @notice Recover the signer of hash, assuming it's an EOA account\\n    /// @dev Only for EthSign signatures\\n    /// @param _hash       Hash of message that was signed\\n    /// @param _signature  Signature encoded as (bytes32 r, bytes32 s, uint8 v)\\n    function recoverSigner(bytes32 _hash, bytes memory _signature)\\n        internal\\n        pure\\n        returns (address signer)\\n    {\\n        require(\\n            _signature.length == 65,\\n            \\\"SignatureValidator#recoverSigner: invalid signature length\\\"\\n        );\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            r := mload(add(_signature, 32))\\n            s := mload(add(_signature, 64))\\n            v := byte(0, mload(add(_signature, 96)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (282): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        //\\n        // Source OpenZeppelin\\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n\\n        if (\\n            uint256(s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) {\\n            revert(\\n                \\\"SignatureValidator#recoverSigner: invalid signature 's' value\\\"\\n            );\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert(\\n                \\\"SignatureValidator#recoverSigner: invalid signature 'v' value\\\"\\n            );\\n        }\\n\\n        // Recover ECDSA signer\\n        signer = ecrecover(\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        // Prevent signer from being 0x0\\n        require(\\n            signer != address(0x0),\\n            \\\"SignatureValidator#recoverSigner: INVALID_SIGNER\\\"\\n        );\\n\\n        return signer;\\n    }\\n\\n    receive() external payable {}\\n\\n    /// @notice Get sub vault address of a specific user\\n    /// @param _owner The address of the user\\n    function getSubvaultOf(address _owner) public view returns (address) {\\n        return LibVaultStorage.ds().ownerSubvaultIndex[_owner];\\n    }\\n\\n    /// @notice Get sub vault's address\\n    /// @param _subvault The address of the subvault\\n    function getSubvaultStatus(address _subvault) public view returns (bool) {\\n        return LibVaultStorage.ds().subvaultStatusIndex[_subvault];\\n    }\\n\\n    /// @notice Get token status\\n    /// @param _collection The address of the ERC721 contract\\n    /// @param _tokenId Token id\\n    function getTokenStatus(address _collection, uint256 _tokenId)\\n        public\\n        view\\n        returns (CustodyData memory)\\n    {\\n        return LibVaultStorage.ds().custodyIndex[_collection][_tokenId];\\n    }\\n\\n    /// @notice Get token list owned by this vault\\n    /// @param _collection The address of the ERC721 contract\\n    function getTokensOwned(address _collection)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return LibVaultStorage.ds().tokenSet[_collection];\\n    }\\n\\n    function _isPaymaster(address _src) internal view returns (bool) {\\n        return _src == LibVaultStorage.ds().paymaster;\\n    }\\n\\n    error GasRefundFailed(address _paymaster);\\n    error UnAuthorised();\\n    error InvalidSubvaultAddress(address subvault);\\n    error InvalidTransfer(string reason);\\n}\\n\",\"keccak256\":\"0x68b57f314573819ae42e33dd4357002dc87717a5aa7dd6912a7bcac51b759010\",\"license\":\"GPL-3.0\"},\"contracts/voyage/auth/DSAuth.sol\":{\"content\":\"// SPDX-License-Identifier: GNU-3\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// lifted from: https://github.com/dapphub/ds-auth/blob/a51e7caa1f03eeffed66d67f3b38605e0f1f881d/src/auth.sol\\n\\npragma solidity ^0.8.9;\\n\\ninterface DSAuthority {\\n    function canCall(\\n        address src,\\n        address dst,\\n        bytes4 sig\\n    ) external view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority(address indexed authority);\\n    event LogSetOwner(address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority public authority;\\n    address public owner;\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_) public auth {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_) public auth {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"ds-auth-unauthorized\\\");\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(address(0))) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeb069264548df428fc3c0489dd970632c1a0b85a8a26bbf7a5b0c01f00d88b75\",\"license\":\"GNU-3\"},\"contracts/voyage/auth/DSGuard.sol\":{\"content\":\"// guard.sol -- simple whitelist implementation of DSAuthority\\n\\n// Copyright (C) 2017  DappHub, LLC\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// lifted from: https://github.com/dapphub/ds-guard/blob/af05632249f98bf3942b9482c5bf69e8bd45284e/src/guard.sol\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\ncontract DSGuardEvents {\\n    event LogPermit(\\n        bytes32 indexed src,\\n        bytes32 indexed dst,\\n        bytes32 indexed sig\\n    );\\n\\n    event LogForbid(\\n        bytes32 indexed src,\\n        bytes32 indexed dst,\\n        bytes32 indexed sig\\n    );\\n}\\n\\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\\n    bytes32 public constant ANY = bytes32(type(uint256).max);\\n\\n    mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => bool))) acl;\\n\\n    function canCall(\\n        address src_,\\n        address dst_,\\n        bytes4 sig\\n    ) public view returns (bool) {\\n        bytes32 src = bytes32(bytes20(src_));\\n        bytes32 dst = bytes32(bytes20(dst_));\\n\\n        return\\n            acl[src][dst][sig] ||\\n            acl[src][dst][ANY] ||\\n            acl[src][ANY][sig] ||\\n            acl[src][ANY][ANY] ||\\n            acl[ANY][dst][sig] ||\\n            acl[ANY][dst][ANY] ||\\n            acl[ANY][ANY][sig] ||\\n            acl[ANY][ANY][ANY];\\n    }\\n\\n    function permit(\\n        bytes32 src,\\n        bytes32 dst,\\n        bytes32 sig\\n    ) public auth {\\n        acl[src][dst][sig] = true;\\n        emit LogPermit(src, dst, sig);\\n    }\\n\\n    function forbid(\\n        bytes32 src,\\n        bytes32 dst,\\n        bytes32 sig\\n    ) public auth {\\n        acl[src][dst][sig] = false;\\n        emit LogForbid(src, dst, sig);\\n    }\\n\\n    function permit(\\n        address src,\\n        address dst,\\n        bytes32 sig\\n    ) public {\\n        permit(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\\n    }\\n\\n    function forbid(\\n        address src,\\n        address dst,\\n        bytes32 sig\\n    ) public {\\n        forbid(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\\n    }\\n}\\n\\ncontract DSGuardFactory {\\n    mapping(address => bool) public isGuard;\\n\\n    function newGuard() public returns (DSGuard guard) {\\n        guard = new DSGuard();\\n        guard.setOwner(msg.sender);\\n        isGuard[address(guard)] = true;\\n    }\\n}\\n\",\"keccak256\":\"0x1c08eb21a713823b838ceed6275d138a6e62fd425094d3d089980697cd94264a\"},\"contracts/voyage/auth/DSRoles.sol\":{\"content\":\"// roles.sol - roled based authentication\\n\\n// Copyright (C) 2017  DappHub, LLC\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// forked from: https://github.com/dapphub/ds-roles/blob/53d56949c0f98c9b5909df9c0d95025b67f3bb75/src/roles.sol\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\ncontract DSRoles is DSAuth, DSAuthority {\\n    mapping(address => bool) _root_users;\\n    mapping(address => bytes32) _user_roles;\\n    mapping(address => mapping(bytes4 => bytes32)) _capability_roles;\\n    mapping(address => mapping(bytes4 => bool)) _public_capabilities;\\n\\n    function getUserRoles(address who) public view returns (bytes32) {\\n        return _user_roles[who];\\n    }\\n\\n    function getCapabilityRoles(address code, bytes4 sig)\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return _capability_roles[code][sig];\\n    }\\n\\n    function isUserRoot(address who) public view returns (bool) {\\n        return _root_users[who];\\n    }\\n\\n    function isCapabilityPublic(address code, bytes4 sig)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _public_capabilities[code][sig];\\n    }\\n\\n    function hasUserRole(address who, uint8 role) public view returns (bool) {\\n        bytes32 roles = getUserRoles(who);\\n        bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\\n        return bytes32(0) != roles & shifted;\\n    }\\n\\n    function canCall(\\n        address caller,\\n        address code,\\n        bytes4 sig\\n    ) public view returns (bool) {\\n        if (isUserRoot(caller) || isCapabilityPublic(code, sig)) {\\n            return true;\\n        } else {\\n            bytes32 has_roles = getUserRoles(caller);\\n            bytes32 needs_one_of = getCapabilityRoles(code, sig);\\n            return bytes32(0) != has_roles & needs_one_of;\\n        }\\n    }\\n\\n    function BITNOT(bytes32 input) internal pure returns (bytes32 output) {\\n        return (input ^ bytes32(type(uint256).max));\\n    }\\n\\n    function setRootUser(address who, bool enabled) public auth {\\n        _root_users[who] = enabled;\\n    }\\n\\n    function setUserRole(\\n        address who,\\n        uint8 role,\\n        bool enabled\\n    ) public auth {\\n        bytes32 last_roles = _user_roles[who];\\n        bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\\n        if (enabled) {\\n            _user_roles[who] = last_roles | shifted;\\n        } else {\\n            _user_roles[who] = last_roles & BITNOT(shifted);\\n        }\\n    }\\n\\n    function setPublicCapability(\\n        address code,\\n        bytes4 sig,\\n        bool enabled\\n    ) public auth {\\n        _public_capabilities[code][sig] = enabled;\\n    }\\n\\n    function setRoleCapability(\\n        uint8 role,\\n        address code,\\n        bytes4 sig,\\n        bool enabled\\n    ) public auth {\\n        bytes32 last_roles = _capability_roles[code][sig];\\n        bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\\n        if (enabled) {\\n            _capability_roles[code][sig] = last_roles | shifted;\\n        } else {\\n            _capability_roles[code][sig] = last_roles & BITNOT(shifted);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x854b2fe5dcb2ab5277a1a1c3a2f97367c4c00f8076f746a88cfbde1eb43b2f15\"},\"contracts/voyage/facets/DiamondVersionFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {Snapshot} from \\\"../interfaces/IDiamondVersionFacet.sol\\\";\\nimport {AppStorage, Storage, LibAppStorage} from \\\"../libraries/LibAppStorage.sol\\\";\\nimport {IDiamondLoupe} from \\\"../../shared/diamond/interfaces/IDiamondLoupe.sol\\\";\\nimport {IDiamondCut} from \\\"../../shared/diamond/interfaces/IDiamondCut.sol\\\";\\nimport {DiamondCutFacet} from \\\"../../shared/diamond/facets/DiamondCutFacet.sol\\\";\\n\\ncontract DiamondVersionFacet is Storage {\\n    // increments `version` and stores snapshot in _snapshotMap\\n    // these must be computed offchain, and called by protocol admin (including init args encoding)\\n    function registerUpgrade(\\n        address init,\\n        bytes memory initArgs,\\n        IDiamondLoupe.Facet[] memory facets\\n    ) public authorised {\\n        LibAppStorage.ds().currentVersion += 1;\\n        uint256 version = LibAppStorage.ds().currentVersion;\\n        LibAppStorage.ds().snapshotMap[version].init = init;\\n        LibAppStorage.ds().snapshotMap[version].initArgs = initArgs;\\n        for (uint256 i = 0; i < facets.length; ) {\\n            LibAppStorage.ds().snapshotMap[version].facets.push(facets[i]);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function getUpgrade(address _vault)\\n        public\\n        returns (IDiamondCut.FacetCut[] memory)\\n    {\\n        IDiamondCut.FacetCut[] storage facetCuts = LibAppStorage\\n            .ds()\\n            .upgradeParam\\n            .facetCuts[msg.sender];\\n        Snapshot memory snapshot = LibAppStorage.ds().snapshotMap[\\n            LibAppStorage.ds().currentVersion\\n        ];\\n        IDiamondLoupe loupe = IDiamondLoupe(_vault);\\n        IDiamondLoupe.Facet[] memory currentFacets = loupe.facets();\\n\\n        mapping(bytes4 => address)\\n            storage existingSelectorFacetMap = LibAppStorage\\n                .ds()\\n                .upgradeParam\\n                .existingSelectorFacetMap[msg.sender];\\n        bytes4[] storage existingSelectors = LibAppStorage\\n            .ds()\\n            .upgradeParam\\n            .existingSelectors[msg.sender];\\n\\n        mapping(bytes4 => bool) storage newSelectorSet = LibAppStorage\\n            .ds()\\n            .upgradeParam\\n            .newSelectorSet[msg.sender];\\n        bytes4[] storage newSelectors = LibAppStorage\\n            .ds()\\n            .upgradeParam\\n            .newSelectors[msg.sender];\\n\\n        for (uint256 i = 0; i < currentFacets.length; ) {\\n            IDiamondLoupe.Facet memory facet = currentFacets[i];\\n            for (uint256 j = 0; j < facet.functionSelectors.length; ) {\\n                bytes4 selector = facet.functionSelectors[j];\\n                newSelectors.push(selector);\\n                existingSelectorFacetMap[selector] = facet.facetAddress;\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // at this point, we have to compute which facets to add/replace/delete\\n        // the logic is identical to the deployment script in voyager_001.ts\\n        // first, compute the selectors to add or replace\\n        for (uint256 i = 0; i < snapshot.facets.length; ) {\\n            IDiamondLoupe.Facet memory candidateFacet = snapshot.facets[i];\\n            for (uint256 j = 0; j < candidateFacet.functionSelectors.length; ) {\\n                bytes4 selector = candidateFacet.functionSelectors[j];\\n                // add it to newSelectorSet\\n                newSelectorSet[selector] = true;\\n                address currentHostFacetAddress = existingSelectorFacetMap[\\n                    selector\\n                ];\\n                if (currentHostFacetAddress != address(0)) {\\n                    if (\\n                        currentHostFacetAddress != candidateFacet.facetAddress\\n                    ) {\\n                        LibAppStorage\\n                            .ds()\\n                            .upgradeParam\\n                            .selectorsReplaced[i]\\n                            .push(selector);\\n                    }\\n                } else {\\n                    LibAppStorage.ds().upgradeParam.selectorsAdded[i].push(\\n                        selector\\n                    );\\n                }\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            if (LibAppStorage.ds().upgradeParam.selectorsAdded[i].length > 0) {\\n                IDiamondCut.FacetCut memory facetCut;\\n                facetCut.functionSelectors = LibAppStorage\\n                    .ds()\\n                    .upgradeParam\\n                    .selectorsAdded[i];\\n                facetCut.facetAddress = candidateFacet.facetAddress;\\n                facetCut.action = IDiamondCut.FacetCutAction.Add;\\n\\n                facetCuts[\\n                    LibAppStorage.ds().upgradeParam.facetCutSize[msg.sender]\\n                ] = facetCut;\\n                LibAppStorage.ds().upgradeParam.facetCutSize[msg.sender]++;\\n\\n                // clean storage right away\\n                delete LibAppStorage.ds().upgradeParam.selectorsAdded[i];\\n            }\\n\\n            if (\\n                LibAppStorage.ds().upgradeParam.selectorsReplaced[i].length > 0\\n            ) {\\n                IDiamondCut.FacetCut memory facetCut;\\n                facetCut.functionSelectors = LibAppStorage\\n                    .ds()\\n                    .upgradeParam\\n                    .selectorsReplaced[i];\\n                facetCut.facetAddress = candidateFacet.facetAddress;\\n                facetCut.action = IDiamondCut.FacetCutAction.Replace;\\n\\n                facetCuts[\\n                    LibAppStorage.ds().upgradeParam.facetCutSize[msg.sender]\\n                ] = facetCut;\\n                LibAppStorage.ds().upgradeParam.facetCutSize[msg.sender]++;\\n\\n                // clean storage right away\\n                delete LibAppStorage.ds().upgradeParam.selectorsReplaced[i];\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // now just get the XOR of existing and new selectors to find the removed set\\n        for (uint256 i = 0; i < existingSelectors.length; ) {\\n            if (!newSelectorSet[existingSelectors[i]]) {\\n                LibAppStorage.ds().upgradeParam.selectorsRemoved[i].push(\\n                    existingSelectors[i]\\n                );\\n            }\\n\\n            if (\\n                LibAppStorage.ds().upgradeParam.selectorsRemoved[i].length > 0\\n            ) {\\n                IDiamondCut.FacetCut memory facetCut;\\n                facetCut.functionSelectors = LibAppStorage\\n                    .ds()\\n                    .upgradeParam\\n                    .selectorsRemoved[i];\\n                facetCut.facetAddress = address(0);\\n                facetCut.action = IDiamondCut.FacetCutAction.Remove;\\n\\n                facetCuts[\\n                    LibAppStorage.ds().upgradeParam.facetCutSize[msg.sender]\\n                ] = facetCut;\\n                LibAppStorage.ds().upgradeParam.facetCutSize[msg.sender]++;\\n\\n                // clean storage right away\\n                delete LibAppStorage.ds().upgradeParam.selectorsRemoved[i];\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        IDiamondCut.FacetCut[] memory ret = new IDiamondCut.FacetCut[](\\n            LibAppStorage.ds().upgradeParam.facetCutSize[msg.sender]\\n        );\\n        for (\\n            uint256 i = 0;\\n            i < LibAppStorage.ds().upgradeParam.facetCutSize[msg.sender];\\n\\n        ) {\\n            ret[i] = facetCuts[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        LibAppStorage.cleanUpgradeParam();\\n\\n        return ret;\\n    }\\n\\n    function currentVersion() public view returns (uint256, bytes32) {\\n        uint256 version = LibAppStorage.ds().currentVersion;\\n        Snapshot memory snapshot = LibAppStorage.ds().snapshotMap[version];\\n        return (version, computeSnapshotChecksum(snapshot));\\n    }\\n\\n    function isUpToDate(uint256 _version) public view returns (bool) {\\n        return _version == LibAppStorage.ds().currentVersion;\\n    }\\n}\\n\",\"keccak256\":\"0xa6be48394c7de5ae89d33e29289be629b3fcd49bdf92c95ece15065515964997\",\"license\":\"MIT\"},\"contracts/voyage/facets/LoanFacet.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {ERC4626} from \\\"@rari-capital/solmate/src/mixins/ERC4626.sol\\\";\\nimport {LibLiquidity} from \\\"../libraries/LibLiquidity.sol\\\";\\nimport {LibLoan} from \\\"../libraries/LibLoan.sol\\\";\\nimport {LibVault} from \\\"../libraries/LibVault.sol\\\";\\nimport {IReserveInterestRateStrategy} from \\\"../interfaces/IReserveInterestRateStrategy.sol\\\";\\nimport {IVToken} from \\\"../interfaces/IVToken.sol\\\";\\nimport {IPriceOracle} from \\\"../interfaces/IPriceOracle.sol\\\";\\nimport {LibAppStorage, AppStorage, Storage, BorrowData, BorrowState, Loan, ReserveConfigurationMap, ReserveData, PMT} from \\\"../libraries/LibAppStorage.sol\\\";\\nimport {LibReserveConfiguration} from \\\"../libraries/LibReserveConfiguration.sol\\\";\\nimport {WadRayMath} from \\\"../../shared/libraries/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../../shared/libraries/PercentageMath.sol\\\";\\nimport {PaymentsFacet} from \\\"../../shared/facets/PaymentsFacet.sol\\\";\\nimport {SafeTransferLib} from \\\"../../shared/libraries/SafeTransferLib.sol\\\";\\nimport {IVault} from \\\"../../vault/Vault.sol\\\";\\nimport {MarketplaceAdapterFacet} from \\\"./MarketplaceAdapterFacet.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract LoanFacet is Storage {\\n    using WadRayMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using PercentageMath for uint256;\\n    using LibReserveConfiguration for ReserveConfigurationMap;\\n\\n    uint256 public immutable TEN_THOUSANDS = 10000;\\n\\n    struct ExecuteBuyNowParams {\\n        address collection;\\n        address marketplace;\\n        uint256 tokenId;\\n        address vault;\\n        uint256 totalPrincipal;\\n        uint256 totalInterest;\\n        uint256 totalDebt;\\n        uint256 outstandingPrincipal;\\n        uint256 outstandingInterest;\\n        uint256 outstandingDebt;\\n        uint256 fv;\\n        uint256 timestamp;\\n        uint256 term;\\n        uint256 epoch;\\n        uint256 nper;\\n        uint256 downpayment;\\n        uint256 liquidityRate;\\n        uint256 borrowRate;\\n        uint256 availableLiquidity;\\n        uint256 totalBalance;\\n        uint256 totalPending;\\n        uint256 loanId;\\n        PMT pmt;\\n    }\\n\\n    struct ExecuteLiquidateParams {\\n        address collection;\\n        address currency;\\n        address vault;\\n        uint256 loanId;\\n        uint256 repaymentId;\\n        uint256 principal;\\n        uint256 interest;\\n        uint256 totalDebt;\\n        uint256 remaningDebt;\\n        uint256 discount;\\n        uint256 discountedFloorPrice;\\n        uint256 amountNeedExtra;\\n        uint256 juniorTrancheAmount;\\n        uint256 receivedAmount;\\n        address liquidator;\\n        uint256 floorPrice;\\n        uint256 floorPriceTime;\\n        uint256 gracePeriod;\\n        uint256 liquidationBonus;\\n        uint256 marginRequirement;\\n        uint256 writeDownAmount;\\n        uint256 totalAssetFromJuniorTranche;\\n        bool isFinal;\\n    }\\n\\n    struct ExecuteRepayParams {\\n        uint256 principal;\\n        uint256 interest;\\n        uint256 total;\\n        uint256 totalDebt;\\n    }\\n\\n    event Borrow(\\n        address indexed _vault,\\n        address indexed _collection,\\n        address indexed _currency,\\n        uint256 _loanId,\\n        uint256 _principal,\\n        uint256 _interest,\\n        uint256 _apr\\n    );\\n\\n    event Repayment(\\n        address indexed _user,\\n        address indexed _vault,\\n        address indexed _collection,\\n        address _currency,\\n        uint256 _loanId,\\n        uint256 _repaymentId,\\n        uint256 _amount,\\n        bool isFinal\\n    );\\n\\n    event Liquidate(\\n        address indexed _liquidator,\\n        address indexed _vault,\\n        address indexed _collection,\\n        uint256 _drowDownId,\\n        uint256 _repaymentId,\\n        uint256 _debt,\\n        uint256 _fromJuniorTranche,\\n        uint256 _amountToWriteDown\\n    );\\n\\n    event CollateralTransferred(\\n        address collection,\\n        address from,\\n        address to,\\n        uint256[] collaterals\\n    );\\n\\n    function previewBuyNowParams(address _collection, uint256 _amount)\\n        public\\n        view\\n        returns (ExecuteBuyNowParams memory)\\n    {\\n        ExecuteBuyNowParams memory executeBorrowParams;\\n        ReserveData memory reserveData = LibLiquidity.getReserveData(\\n            _collection\\n        );\\n        ReserveConfigurationMap memory reserveConf = LibReserveConfiguration\\n            .getConfiguration(_collection);\\n\\n        (executeBorrowParams.epoch, executeBorrowParams.term) = reserveConf\\n            .getBorrowParams();\\n\\n        BorrowState storage borrowState = LibLoan.getBorrowState(\\n            _collection,\\n            reserveData.currency\\n        );\\n\\n        (\\n            executeBorrowParams.liquidityRate,\\n            executeBorrowParams.borrowRate\\n        ) = IReserveInterestRateStrategy(\\n            reserveData.interestRateStrategyAddress\\n        ).calculateInterestRates(\\n                reserveData.currency,\\n                reserveData.seniorDepositTokenAddress,\\n                0,\\n                _amount,\\n                borrowState.totalDebt,\\n                borrowState.avgBorrowRate\\n            );\\n\\n        return executeBorrowParams;\\n    }\\n\\n    function buyNow(\\n        address _collection,\\n        uint256 _tokenId,\\n        address payable _vault,\\n        address _marketplace,\\n        bytes calldata _data\\n    ) external payable whenNotPaused {\\n        ExecuteBuyNowParams memory params;\\n        params.collection = _collection;\\n        params.tokenId = _tokenId;\\n        params.vault = _vault;\\n        params.marketplace = _marketplace;\\n\\n        ReserveData memory reserveData = LibLiquidity.getReserveData(\\n            params.collection\\n        );\\n\\n        BorrowState storage borrowState = LibLoan.getBorrowState(\\n            params.collection,\\n            reserveData.currency\\n        );\\n\\n        // 0. check if the user owns the vault\\n        if (LibVault.getVaultAddress(_msgSender()) != params.vault) {\\n            revert Unauthorised();\\n        }\\n\\n        // 1. get price for params.tokenId  and floor price pv\\n        params.totalPrincipal = MarketplaceAdapterFacet(address(this))\\n            .extractAssetPrice(_marketplace, _data);\\n        (params.fv, params.timestamp) = IPriceOracle(reserveData.priceOracle)\\n            .getTwap(params.collection);\\n\\n        if (params.fv == 0) {\\n            revert InvalidFloorPrice();\\n        }\\n\\n        if (params.fv < params.totalPrincipal) {\\n            revert InvalidPrincipal();\\n        }\\n\\n        // 2. get borrow params and borrow rate\\n        ReserveConfigurationMap memory reserveConf = LibReserveConfiguration\\n            .getConfiguration(params.collection);\\n        (params.epoch, params.term) = reserveConf.getBorrowParams();\\n        params.nper = params.term / params.epoch;\\n\\n        (\\n            params.liquidityRate,\\n            params.borrowRate\\n        ) = IReserveInterestRateStrategy(\\n            reserveData.interestRateStrategyAddress\\n        ).calculateInterestRates(\\n                reserveData.currency,\\n                reserveData.seniorDepositTokenAddress,\\n                0,\\n                params.outstandingPrincipal,\\n                borrowState.totalDebt,\\n                borrowState.avgBorrowRate\\n            );\\n\\n        // 3. insert debt, get total interest and PMT\\n        (params.loanId, params.pmt, params.totalInterest) = LibLoan.insertDebt(\\n            params.collection,\\n            reserveData.currency,\\n            params.tokenId,\\n            params.vault,\\n            params.totalPrincipal,\\n            params.term,\\n            params.epoch,\\n            params.borrowRate\\n        );\\n\\n        // 4. calculate downpayment and outstanding principal, interest and debt\\n        params.downpayment = params.pmt.pmt;\\n        params.outstandingPrincipal =\\n            params.totalPrincipal -\\n            params.pmt.principal;\\n        params.outstandingInterest = params.totalInterest - params.pmt.interest;\\n        params.outstandingDebt =\\n            params.outstandingPrincipal +\\n            params.outstandingInterest;\\n\\n        // 5. check credit limit against with outstanding debt\\n        uint256 availableCreditLimit = LibVault.getCreditLimit(\\n            params.vault,\\n            params.collection,\\n            reserveData.currency,\\n            params.fv\\n        );\\n        if (availableCreditLimit < params.outstandingDebt) {\\n            revert InsufficientCreditLimit();\\n        }\\n\\n        // 6. check if pool liquidity against with outstanding principal\\n        params.totalPending = IVToken(reserveData.seniorDepositTokenAddress)\\n            .totalUnbonding();\\n        params.totalBalance = IERC20(reserveData.currency).balanceOf(\\n            reserveData.seniorDepositTokenAddress\\n        );\\n        console.log(\\\"currency: \\\", reserveData.currency);\\n        console.log(\\n            \\\"senior deposit tokenAddress: \\\",\\n            reserveData.seniorDepositTokenAddress\\n        );\\n        console.log(\\\"balance: \\\", params.totalBalance);\\n        if (params.totalBalance > params.totalPending) {\\n            params.availableLiquidity =\\n                params.totalBalance -\\n                params.totalPending;\\n        }\\n\\n        if (params.availableLiquidity < params.outstandingPrincipal) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        // 7.1 receive downpayment\\n        if (params.downpayment > msg.value) {\\n            IERC20(reserveData.currency).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                (params.downpayment - msg.value)\\n            );\\n        } else {\\n            if (params.downpayment != msg.value) {\\n                revert InvalidValueTransfered();\\n            }\\n        }\\n\\n        // 7.2 protocol fee\\n        uint256 protocolFee = params.totalPrincipal.percentMul(\\n            LibAppStorage.ds().protocolFee.cutRatio\\n        );\\n        IERC20(reserveData.currency).safeTransferFrom(\\n            msg.sender,\\n            LibAppStorage.ds().protocolFee.treasuryAddress,\\n            protocolFee\\n        );\\n\\n        // 8.1 transfer money to this\\n        IVToken(reserveData.seniorDepositTokenAddress).transferUnderlyingTo(\\n            address(this),\\n            params.outstandingPrincipal\\n        );\\n\\n        // 8.2 unwrap weth\\n        PaymentsFacet(address(this)).unwrapWETH9(\\n            params.outstandingPrincipal,\\n            address(this)\\n        );\\n\\n        SafeTransferLib.safeTransferETH(params.vault, params.totalPrincipal);\\n\\n        // 9. purchase nft\\n        (params.pmt.principal, params.pmt.interest) = LibLoan.getPMT(\\n            params.collection,\\n            reserveData.currency,\\n            params.vault,\\n            params.loanId\\n        );\\n        MarketplaceAdapterFacet(address(this)).purchase(\\n            params.marketplace,\\n            params.vault,\\n            _data\\n        );\\n\\n        // 10. first payment\\n        LibLoan.repay(\\n            params.collection,\\n            reserveData.currency,\\n            params.vault,\\n            params.loanId\\n        );\\n\\n        // 11. distribute interest\\n        LibLoan.distributeInterest(\\n            reserveData,\\n            params.pmt.interest,\\n            _msgSender()\\n        );\\n\\n        emit Borrow(\\n            params.vault,\\n            params.collection,\\n            reserveData.currency,\\n            params.loanId,\\n            params.totalPrincipal,\\n            params.totalInterest,\\n            params.borrowRate\\n        );\\n    }\\n\\n    function repay(\\n        address _collection,\\n        uint256 _loan,\\n        address payable _vault\\n    ) external whenNotPaused {\\n        ExecuteRepayParams memory params;\\n        ReserveData memory reserveData = LibLiquidity.getReserveData(\\n            _collection\\n        );\\n\\n        // 0. check if the user owns the vault\\n        if (LibVault.getVaultAddress(_msgSender()) != _vault) {\\n            revert Unauthorised();\\n        }\\n\\n        // 1. check draw down to get principal and interest\\n        (params.principal, params.interest) = LibLoan.getPMT(\\n            _collection,\\n            reserveData.currency,\\n            _vault,\\n            _loan\\n        );\\n        if (params.principal + params.interest == 0) {\\n            revert InvalidDebt();\\n        }\\n\\n        params.total = params.principal + params.interest;\\n\\n        // 2. update repay data\\n        (uint256 repaymentId, bool isFinal) = LibLoan.repay(\\n            _collection,\\n            reserveData.currency,\\n            _vault,\\n            _loan\\n        );\\n\\n        // 3. distribute interest\\n        LibLoan.distributeInterest(reserveData, params.interest, _msgSender());\\n\\n        IERC20(reserveData.currency).safeTransferFrom(\\n            _msgSender(),\\n            reserveData.seniorDepositTokenAddress,\\n            params.principal\\n        );\\n\\n        emit Repayment(\\n            _msgSender(),\\n            _vault,\\n            _collection,\\n            reserveData.currency,\\n            _loan,\\n            repaymentId,\\n            params.total,\\n            isFinal\\n        );\\n    }\\n\\n    function liquidate(\\n        address _collection,\\n        address _vault,\\n        uint256 _loanId\\n    ) external whenNotPaused {\\n        ExecuteLiquidateParams memory param;\\n        param.collection = _collection;\\n        ReserveData memory reserveData = LibLiquidity.getReserveData(\\n            param.collection\\n        );\\n        param.currency = reserveData.currency;\\n        ReserveConfigurationMap memory reserveConf = LibReserveConfiguration\\n            .getConfiguration(param.collection);\\n\\n        // 1. prepare basic info and some strategy parameters\\n        param.vault = _vault;\\n        param.loanId = _loanId;\\n        param.liquidator = _msgSender();\\n        (param.liquidationBonus, param.gracePeriod) = reserveConf\\n            .getLiquidationParams();\\n\\n        LibLoan.LoanDetail memory loanDetail = LibLoan.getLoanDetail(\\n            param.collection,\\n            param.currency,\\n            param.vault,\\n            param.loanId\\n        );\\n\\n        // 2. check if the debt is qualified to be liquidated\\n        if (\\n            block.timestamp <= loanDetail.nextPaymentDue ||\\n            block.timestamp - loanDetail.nextPaymentDue <=\\n            param.gracePeriod * LibLoan.SECOND_PER_DAY\\n        ) {\\n            revert InvalidLiquidate();\\n        }\\n\\n        // 3 get floor price from oracle contract\\n        IPriceOracle priceOracle = IPriceOracle(reserveData.priceOracle);\\n        (param.floorPrice, param.floorPriceTime) = priceOracle.getTwap(\\n            param.collection\\n        );\\n\\n        if (param.floorPrice == 0) {\\n            revert InvalidFloorPrice();\\n        }\\n\\n        // 3 get pmt info\\n        (param.principal, param.interest) = LibLoan.getPMT(\\n            param.collection,\\n            param.currency,\\n            param.vault,\\n            param.loanId\\n        );\\n        param.totalDebt = param.principal;\\n        param.remaningDebt = param.totalDebt;\\n        param.discount = getDiscount(param.floorPrice, param.liquidationBonus);\\n        param.discountedFloorPrice = param.floorPrice - param.discount;\\n\\n        // 4 transfer all nfts to liquidator\\n        uint256[] memory collaterals = LibLoan.releaseLien(\\n            param.collection,\\n            param.currency,\\n            param.vault,\\n            param.loanId\\n        );\\n\\n        uint256 discountedFloorPriceInTotal = param.discountedFloorPrice *\\n            collaterals.length;\\n        IERC20(param.currency).safeTransferFrom(\\n            param.liquidator,\\n            address(this),\\n            discountedFloorPriceInTotal\\n        );\\n        param.receivedAmount += discountedFloorPriceInTotal;\\n\\n        for (uint256 i = 0; i < collaterals.length; i++) {\\n            bytes4 selector = IERC721(param.collection).transferFrom.selector;\\n            bytes memory data = abi.encodePacked(\\n                selector,\\n                abi.encode(param.vault, param.liquidator, collaterals[i])\\n            );\\n            bytes memory encodedData = abi.encode(param.collection, data);\\n            IVault(_vault).exec(encodedData);\\n        }\\n\\n        emit CollateralTransferred(\\n            param.collection,\\n            param.vault,\\n            param.liquidator,\\n            collaterals\\n        );\\n\\n        if (param.totalDebt > discountedFloorPriceInTotal) {\\n            param.remaningDebt = param.totalDebt - discountedFloorPriceInTotal;\\n        } else {\\n            uint256 refundAmount = discountedFloorPriceInTotal -\\n                param.totalDebt;\\n            IERC20(param.currency).transfer(param.vault, refundAmount);\\n            param.receivedAmount -= refundAmount;\\n        }\\n\\n        // 5. transfer from junior tranche if there is still remaning debt\\n        if (param.remaningDebt > 0) {\\n            param.totalAssetFromJuniorTranche = ERC4626(\\n                reserveData.juniorDepositTokenAddress\\n            ).totalAssets();\\n\\n            if (param.totalAssetFromJuniorTranche >= param.remaningDebt) {\\n                IVToken(reserveData.juniorDepositTokenAddress)\\n                    .transferUnderlyingTo(address(this), param.remaningDebt);\\n                param.juniorTrancheAmount = param.remaningDebt;\\n                param.receivedAmount += param.remaningDebt;\\n            } else {\\n                IVToken(reserveData.juniorDepositTokenAddress)\\n                    .transferUnderlyingTo(\\n                        address(this),\\n                        param.totalAssetFromJuniorTranche\\n                    );\\n                param.juniorTrancheAmount = param.totalAssetFromJuniorTranche;\\n                param.receivedAmount += param.totalAssetFromJuniorTranche;\\n                param.writeDownAmount =\\n                    param.remaningDebt -\\n                    param.totalAssetFromJuniorTranche;\\n            }\\n        }\\n\\n        // 6. record repay info\\n        (param.repaymentId, param.isFinal) = LibLoan.repay(\\n            param.collection,\\n            param.currency,\\n            param.vault,\\n            param.loanId\\n        );\\n\\n        emit Repayment(\\n            _msgSender(),\\n            param.vault,\\n            param.collection,\\n            param.currency,\\n            param.loanId,\\n            param.repaymentId,\\n            param.totalDebt,\\n            param.isFinal\\n        );\\n\\n        // 7. transfer to senior deposit token\\n        IERC20(param.currency).safeTransfer(\\n            reserveData.seniorDepositTokenAddress,\\n            param.receivedAmount\\n        );\\n\\n        emit Liquidate(\\n            _msgSender(),\\n            _vault,\\n            param.currency,\\n            param.loanId,\\n            param.repaymentId,\\n            param.totalDebt,\\n            param.juniorTrancheAmount,\\n            param.writeDownAmount\\n        );\\n    }\\n\\n    function getVaultDebt(address _collection, address _vault)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        ReserveData memory reserveData = LibLiquidity.getReserveData(\\n            _collection\\n        );\\n        return LibVault.getVaultDebt(_collection, reserveData.currency, _vault);\\n    }\\n\\n    /// @notice Returns the total outstanding principal debt for a particular underlying asset pool\\n    /// @param _collection the address of the underlying nft collection.\\n    /// @return The total outstanding principal owed to depositors.\\n    function principalBalance(address _collection)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        ReserveData memory reserveData = LibLiquidity.getReserveData(\\n            _collection\\n        );\\n        BorrowState storage borrowState = LibLoan.getBorrowState(\\n            _collection,\\n            reserveData.currency\\n        );\\n        return borrowState.totalDebt;\\n    }\\n\\n    /// @notice Returns the total outstanding interest debt for a particular underlying asset pool\\n    /// @param _collection the address of the underlying nft collection.\\n    /// @return The total outstanding interest owed to depositors.\\n    function interestBalance(address _collection)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        ReserveData memory reserveData = LibLiquidity.getReserveData(\\n            _collection\\n        );\\n        BorrowState storage borrowState = LibLoan.getBorrowState(\\n            _collection,\\n            reserveData.currency\\n        );\\n        return borrowState.totalInterest;\\n    }\\n\\n    function getDiscount(uint256 _value, uint256 _liquidationBonus)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 withBonus = _value.percentMul(_liquidationBonus);\\n        return withBonus - _value;\\n    }\\n}\\n\\n/* --------------------------------- errors -------------------------------- */\\nerror Unauthorised();\\nerror InsufficientLiquidity();\\nerror InsufficientCreditLimit();\\nerror InvalidDebt();\\nerror InvalidLiquidate();\\nerror InvalidFloorPrice();\\nerror InvalidPrincipal();\\nerror InvalidValueTransfered();\\n\",\"keccak256\":\"0x26be587dab7a4d264c20b12a0464130bdd4722cf0c64310655631d47e05ce0ac\",\"license\":\"GPL-3.0\"},\"contracts/voyage/facets/MarketplaceAdapterFacet.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {IVault} from \\\"../../vault/Vault.sol\\\";\\nimport {IMarketPlaceAdapter} from \\\"../interfaces/IMarketPlaceAdapter.sol\\\";\\nimport {Storage, LibAppStorage} from \\\"../libraries/LibAppStorage.sol\\\";\\n\\ncontract MarketplaceAdapterFacet is Storage {\\n    event MarketplaceAdapterUpdated(\\n        address indexed _marketplace,\\n        address _strategy\\n    );\\n\\n    function purchase(\\n        address _marketplace,\\n        address _vault,\\n        bytes calldata _data\\n    ) external {\\n        if (msg.sender != address(this)) {\\n            revert InvalidCaller();\\n        }\\n        address adapterAddr = LibAppStorage\\n            .ds()\\n            .marketPlaceData[_marketplace]\\n            .adapterAddr;\\n        bytes memory data = IMarketPlaceAdapter(adapterAddr).execute(_data);\\n        bytes memory encodedData = abi.encode(_marketplace, data);\\n        IVault(_vault).exec(encodedData);\\n    }\\n\\n    function extractAssetPrice(address _marketplace, bytes calldata _data)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        address adapterAddr = LibAppStorage\\n            .ds()\\n            .marketPlaceData[_marketplace]\\n            .adapterAddr;\\n\\n        return IMarketPlaceAdapter(adapterAddr).extractAssetPrice(_data);\\n    }\\n\\n    function updateMarketPlaceData(address _marketplace, address _strategy)\\n        external\\n        authorised\\n    {\\n        LibAppStorage\\n            .ds()\\n            .marketPlaceData[_marketplace]\\n            .adapterAddr = _strategy;\\n        emit MarketplaceAdapterUpdated(_marketplace, _strategy);\\n    }\\n\\n    error InvalidCaller();\\n}\\n\",\"keccak256\":\"0x026e690e472a6d2d5eab527743b8ea5378cece0307176ab8232c739fcb7fa64a\",\"license\":\"GPL-3.0\"},\"contracts/voyage/facets/SecurityFacet.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport {Storage, Authorisation, LibAppStorage} from \\\"../libraries/LibAppStorage.sol\\\";\\nimport {LibSecurity} from \\\"../libraries/LibSecurity.sol\\\";\\nimport {VaultFacet} from \\\"./VaultFacet.sol\\\";\\n\\ncontract SecurityFacet is Storage {\\n    using LibSecurity for Authorisation;\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    function paused() public view returns (bool) {\\n        return LibAppStorage.ds()._paused;\\n    }\\n\\n    function pause() public authorised {\\n        LibAppStorage.ds()._paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    function unpause() public authorised {\\n        LibAppStorage.ds()._paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    function grantRole(\\n        address user,\\n        uint8 role,\\n        bool enabled\\n    ) public authorised {\\n        LibSecurity.grantRole(LibAppStorage.ds().auth, user, role, enabled);\\n    }\\n\\n    function grantRolePermission(\\n        uint8 role,\\n        address target,\\n        bytes4 sig\\n    ) public authorised {\\n        LibSecurity.grantRolePermission(\\n            LibAppStorage.ds().auth,\\n            role,\\n            target,\\n            sig\\n        );\\n    }\\n\\n    function revokeRolePermission(\\n        uint8 role,\\n        address target,\\n        bytes4 sig\\n    ) public authorised {\\n        LibSecurity.revokeRolePermission(\\n            LibAppStorage.ds().auth,\\n            role,\\n            target,\\n            sig\\n        );\\n    }\\n\\n    function grantPermission(\\n        address src,\\n        address dst,\\n        bytes4 sig\\n    ) public authorised {\\n        LibSecurity.grantPermission(LibAppStorage.ds().auth, src, dst, sig);\\n    }\\n\\n    function revokePermission(\\n        address src,\\n        address dst,\\n        bytes4 sig\\n    ) public authorised {\\n        LibSecurity.revokePermission(LibAppStorage.ds().auth, src, dst, sig);\\n    }\\n\\n    function isAuthorisedInbound(address src, bytes4 sig)\\n        public\\n        returns (bool)\\n    {\\n        return\\n            LibSecurity.isAuthorisedInbound(LibAppStorage.ds().auth, src, sig);\\n    }\\n\\n    function isAuthorisedOutbound(address dst, bytes4 sig)\\n        public\\n        returns (bool)\\n    {\\n        return\\n            LibSecurity.isAuthorisedOutbound(LibAppStorage.ds().auth, dst, sig);\\n    }\\n\\n    function isAuthorised(\\n        address src,\\n        address dst,\\n        bytes4 sig\\n    ) public returns (bool) {\\n        return LibSecurity.isAuthorised(LibAppStorage.ds().auth, src, dst, sig);\\n    }\\n\\n    function isTrustedForwarder(address _forwarder) public view returns (bool) {\\n        return LibSecurity.isTrustedForwarder(_forwarder);\\n    }\\n}\\n\",\"keccak256\":\"0x707a24ea7a51b505658e786810804d26d3d75d2945c7e195a6cb2f27a9e04b3a\",\"license\":\"GPL-3.0\"},\"contracts/voyage/facets/VaultFacet.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {UpgradeableBeacon} from \\\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {BeaconProxy} from \\\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\\\";\\nimport {LibAppStorage, AppStorage, Storage, VaultConfig, NFTInfo, DiamondFacet, ReserveConfigurationMap} from \\\"../libraries/LibAppStorage.sol\\\";\\nimport {LibVault} from \\\"../libraries/LibVault.sol\\\";\\nimport {LibSecurity} from \\\"../libraries/LibSecurity.sol\\\";\\nimport {LibReserveConfiguration} from \\\"../libraries/LibReserveConfiguration.sol\\\";\\nimport {IVault} from \\\"../../vault/Vault.sol\\\";\\nimport {IDiamondVersionFacet, Snapshot} from \\\"../interfaces/IDiamondVersionFacet.sol\\\";\\nimport {IDiamondCut} from \\\"../../shared/diamond/interfaces/IDiamondCut.sol\\\";\\nimport {DiamondCutFacet} from \\\"../../shared/diamond/facets/DiamondCutFacet.sol\\\";\\nimport {DiamondVersionFacet} from \\\"./DiamondVersionFacet.sol\\\";\\n\\ncontract VaultFacet is Storage, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using LibReserveConfiguration for ReserveConfigurationMap;\\n    /* --------------------------------- events --------------------------------- */\\n    event VaultCreated(address _vault, address _owner, uint256 _numVaults);\\n    event VaultMarginCredited(\\n        address indexed _vault,\\n        address indexed _asset,\\n        address _sponsor,\\n        uint256 _amount\\n    );\\n    event VaultMarginRedeemed(\\n        address indexed _vault,\\n        address indexed _asset,\\n        address _sponsor,\\n        uint256 _amount\\n    );\\n\\n    /* ----------------------------- admin interface ---------------------------- */\\n    function createVault(address _user, bytes20 _salt) external authorised {\\n        bytes memory data = getEncodedVaultInitData(_user);\\n        bytes32 newsalt = newSalt(_salt, _user);\\n        address vaultBeaconProxy;\\n        bytes memory initCode = abi.encodePacked(\\n            type(BeaconProxy).creationCode,\\n            abi.encode(vaultBeacon(), data)\\n        );\\n        assembly {\\n            vaultBeaconProxy := create2(\\n                0,\\n                add(initCode, 0x20),\\n                mload(initCode),\\n                newsalt\\n            )\\n        }\\n        if (vaultBeaconProxy == address(0)) {\\n            revert FailedDeployVault();\\n        }\\n        uint256 numVaults = LibVault.recordVault(_user, vaultBeaconProxy);\\n        bytes4[] memory sigs = new bytes4[](1);\\n        sigs[0] = IVault(address(0)).exec.selector;\\n        LibSecurity.grantPermissions(\\n            LibAppStorage.ds().auth,\\n            address(this),\\n            vaultBeaconProxy,\\n            sigs\\n        );\\n        emit VaultCreated(vaultBeaconProxy, _user, numVaults);\\n    }\\n\\n    /* ---------------------- vault configuration interface --------------------- */\\n\\n    function setVaultBeacon(address _impl) external authorised {\\n        LibVault.setVaultBeacon(_impl);\\n    }\\n\\n    /* ---------------------- user interface --------------------- */\\n    function withdrawNFT(\\n        address _vault,\\n        address _collection,\\n        uint256 _tokenId\\n    ) external nonReentrant {\\n        if (LibVault.getVaultAddress(_msgSender()) != _vault) {\\n            revert InvalidVaultCall();\\n        }\\n        if (LibAppStorage.ds().nftIndex[_collection][_tokenId].isCollateral) {\\n            revert InvalidWithdrawal();\\n        }\\n        delete LibAppStorage.ds().nftIndex[_collection][_tokenId];\\n        bytes4 selector = IERC721(_collection).transferFrom.selector;\\n        bytes memory param = abi.encode(_vault, _msgSender(), _tokenId);\\n        bytes memory data = abi.encodePacked(selector, param);\\n        bytes memory encodedData = abi.encode(_collection, data);\\n        IVault(_vault).exec(encodedData);\\n    }\\n\\n    function transferReserve(\\n        address _vault,\\n        address _currency,\\n        address _to,\\n        uint256 _amount\\n    ) external nonReentrant {\\n        if (LibVault.getVaultAddress(_msgSender()) != _vault) {\\n            revert InvalidVaultCall();\\n        }\\n        bytes4 selector = IERC20(_currency).transferFrom.selector;\\n        bytes memory param = abi.encode(_vault, _to, _amount);\\n        bytes memory data = abi.encodePacked(selector, param);\\n        bytes memory encodedData = abi.encode(_currency, data);\\n        IVault(_vault).exec(encodedData);\\n    }\\n\\n    /* ---------------------- view functions --------------------- */\\n    function computeCounterfactualAddress(address _user, bytes20 _salt)\\n        external\\n        view\\n        returns (address)\\n    {\\n        bytes memory data = getEncodedVaultInitData(_user);\\n        bytes memory initCode = abi.encodePacked(\\n            type(BeaconProxy).creationCode,\\n            abi.encode(vaultBeacon(), data)\\n        );\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                bytes1(0xff),\\n                address(this),\\n                newSalt(_salt, _user),\\n                keccak256(initCode)\\n            )\\n        );\\n        return address(uint160(uint256(hash)));\\n    }\\n\\n    function collectionInitialized(address _collection)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return LibAppStorage.ds()._reserveData[_collection].initialized;\\n    }\\n\\n    function newSalt(bytes20 _salt, address _owner)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(keccak256(abi.encodePacked(_owner)), _salt)\\n            );\\n    }\\n\\n    function vaultBeacon() public view returns (address) {\\n        return LibVault.vaultBeacon();\\n    }\\n\\n    function subVaultBeacon() public view returns (address) {\\n        return LibVault.subVaultBeacon();\\n    }\\n\\n    function getVaultAddr(address _user) external view returns (address) {\\n        return LibVault.getVaultAddress(_user);\\n    }\\n\\n    function getEncodedVaultInitData(address _user)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        bytes memory data = abi.encodeWithSelector(\\n            IVault(address(0)).initialize.selector,\\n            address(this),\\n            _user,\\n            LibAppStorage.ds().paymaster,\\n            LibAppStorage.ds().WETH9\\n        );\\n        return data;\\n    }\\n}\\n\\n/* --------------------------------- errors -------------------------------- */\\nerror InvalidVaultCall();\\nerror FailedDeployVault();\\nerror InvalidWithdrawal();\\n\",\"keccak256\":\"0xb74b89f7e4d1f4dc930324c27b1fef7f65bf4bd296ba48dfcdd79cbccee4d80f\",\"license\":\"GPL-3.0\"},\"contracts/voyage/interfaces/IDiamondVersionFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IDiamondLoupe} from \\\"../../shared/diamond/interfaces/IDiamondLoupe.sol\\\";\\n\\nstruct Snapshot {\\n    IDiamondLoupe.Facet[] facets;\\n    address init; // address of InitDiamondVx\\n    bytes initArgs; // abi encoded args to pass to InitDiamondVX\\n}\\n\\ninterface IDiamondVersionFacet {\\n    // clone should create a fresh Vault with the facets recorded in `Snapshot` of current version\\n    function clone() external returns (address);\\n\\n    // increments `version` and stores snapshot in _snapshotMap\\n    // these must be computed offchain, and called by protocol admin (including init args encoding)\\n    function registerUpgrade(Snapshot memory _snapshot) external;\\n\\n    // return version number and snapshot hash\\n    function currentVersion() external view returns (uint256, bytes32);\\n\\n    function isUpToDate(uint256 _version) external view returns (bool);\\n\\n    // returns the current snapshot\\n    function getSnapshot() external view returns (Snapshot memory);\\n}\\n\",\"keccak256\":\"0x5c117b65f8ef55b62392d0afde91cf0711832ea41e00719d9fb48a3b608189cc\",\"license\":\"MIT\"},\"contracts/voyage/interfaces/IMarketPlaceAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\ninterface IMarketPlaceAdapter {\\n    function extractAssetPrice(bytes calldata _data)\\n        external\\n        pure\\n        returns (uint256);\\n\\n    function validate(bytes calldata _data) external view returns (bool);\\n\\n    function execute(bytes calldata _data) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x7b27405c7e5a65427d7ab54473e00feadacb03113770a2418bac3f48b8517520\",\"license\":\"GPL-3.0\"},\"contracts/voyage/interfaces/IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\ninterface IPriceOracle {\\n    function getTwap(address _asset) external view returns (uint256, uint256);\\n\\n    function updateTwap(address _asset, uint256 _priceAverage) external;\\n}\\n\",\"keccak256\":\"0x661ab66a9f15aaa2177bfcf52a626293315a2caf216e703531368494d1974d87\",\"license\":\"GPL-3.0\"},\"contracts/voyage/interfaces/IReserveInterestRateStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\n/**\\n@title IReserveInterestRateStrategyInterface interface\\n@notice Interface for the calculation of the interest rates.\\n*/\\n\\ninterface IReserveInterestRateStrategy {\\n    function calculateInterestRates(\\n        address reserve,\\n        uint256 availableLiquidity,\\n        uint256 totalStableDebt,\\n        uint256 averageBorrowRate\\n    ) external view returns (uint256, uint256);\\n\\n    function calculateInterestRates(\\n        address reserve,\\n        address liquidityEscrow,\\n        uint256 liquidityAdded,\\n        uint256 liquidityTaken,\\n        uint256 totalStableDebt,\\n        uint256 averageBorrowRate\\n    ) external view returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0xdef4da289a16168b03272c81a29078c7dc7b5df89b415d927471575277b1781b\",\"license\":\"GPL-3.0\"},\"contracts/voyage/interfaces/IVToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC4626} from \\\"../../shared/interfaces/IERC4626.sol\\\";\\n\\ninterface IVToken is IERC4626 {\\n    function transferUnderlyingTo(address _target, uint256 _amount) external;\\n\\n    function claim() external;\\n\\n    function unbonding(address _user) external view returns (uint256);\\n\\n    function totalUnbonding() external view returns (uint256);\\n\\n    function maximumClaimable(address _user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x2c3c43f6e29ced244760b904f0e52409e3434bfd2bbb9db801fa3a37b5e9f181\",\"license\":\"MIT\"},\"contracts/voyage/interfaces/IVaultFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\ninterface IVaultFactory {\\n    function createVault(\\n        address owner,\\n        address voyage,\\n        uint256 version,\\n        bytes32 checksum,\\n        bytes32 salt\\n    ) external returns (address);\\n}\\n\",\"keccak256\":\"0xf63dca9d9d7b27ab560a723d559df3339d7cfcc30cc3f9e6dd46a22009cef7a4\",\"license\":\"GPL-3.0\"},\"contracts/voyage/libraries/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {DSRoles} from \\\"../auth/DSRoles.sol\\\";\\nimport {DSGuard} from \\\"../auth/DSGuard.sol\\\";\\nimport {LibSecurity} from \\\"./LibSecurity.sol\\\";\\nimport {UpgradeableBeacon} from \\\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\\\";\\nimport {Snapshot} from \\\"../interfaces/IDiamondVersionFacet.sol\\\";\\nimport {IVaultFactory} from \\\"../interfaces/IVaultFactory.sol\\\";\\nimport {IDiamondCut} from \\\"../../shared/diamond/interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"../../shared/diamond/interfaces/IDiamondLoupe.sol\\\";\\nimport {DiamondCutFacet} from \\\"../../shared/diamond/facets/DiamondCutFacet.sol\\\";\\nimport {IWETH9} from \\\"../../shared/facets/PaymentsFacet.sol\\\";\\n\\nenum Tranche {\\n    JUNIOR,\\n    SENIOR\\n}\\n\\nstruct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    uint256 currentBorrowRate;\\n    //the decimals of the reserve asset\\n    uint256 decimals;\\n    address interestRateStrategyAddress;\\n    address juniorDepositTokenAddress;\\n    address seniorDepositTokenAddress;\\n    uint40 juniorLastUpdateTimestamp;\\n    uint40 seniorLastUpdateTimestamp;\\n    address currency;\\n    address priceOracle;\\n    bool initialized;\\n}\\n\\nstruct ReserveConfigurationMap {\\n    //bit 0-15: liquidation bonus (uint16)\\n    //bit 16-23: decimals (uint8)\\n    //bit 24: reserve is active\\n    //bit 25: reserve is frozen\\n    //bit 26: borrowing is enabled\\n    //bit 27: reserved\\n    //bit 28-63: min margin (uint36)\\n    //bit 64-99: max margin (uint36)\\n    //bit 100-115: margin requirement (uint16)\\n    //bit 116-131: income ratio (uint16)\\n    //bit 132-139: instalment interval (uint8)\\n    //bit 140-155: loan term (uint16)\\n    //bit 156-163: repayment grace period (uint8)\\n    //bit 164-255: unused\\n    uint256 data;\\n}\\n\\nstruct PMT {\\n    uint256 principal;\\n    uint256 interest;\\n    uint256 pmt;\\n}\\n\\nstruct RepaymentData {\\n    uint256 principal;\\n    uint256 interest;\\n    // principal + interest\\n    uint256 total;\\n    uint40 paidAt;\\n    bool isLiquidated;\\n}\\n\\nstruct Loan {\\n    uint256 principal;\\n    uint256 interest;\\n    // the total intended length of the loan in seconds - e.g., 90 days\\n    uint256 term;\\n    // the repayment interval - e.g., 30 days\\n    uint256 epoch;\\n    // number of instalments, term / epoch\\n    uint256 nper;\\n    // the amount to be repaid per instalment (principal + interest)\\n    PMT pmt;\\n    // the borrow rate of this loan\\n    uint256 apr;\\n    uint256 borrowAt;\\n    // next due data\\n    uint256 nextPaymentDue;\\n    // principal paid\\n    uint256 totalPrincipalPaid;\\n    // interest paid\\n    uint256 totalInterestPaid;\\n    RepaymentData[] repayments;\\n    // size pf repayments\\n    uint256 paidTimes;\\n    uint256[] collateral;\\n}\\n\\nstruct LoanList {\\n    uint256 head;\\n    uint256 tail;\\n}\\n\\nstruct BorrowData {\\n    uint256 paidLoanNumber;\\n    // next draw down number\\n    uint256 nextLoanNumber;\\n    uint256 totalPrincipal;\\n    uint256 totalInterest;\\n    uint256 mapSize;\\n    mapping(uint256 => Loan) loans;\\n}\\n\\nstruct BorrowState {\\n    uint256 totalDebt;\\n    uint256 totalInterest;\\n    uint256 avgBorrowRate;\\n    mapping(address => uint256) repaidTimes;\\n}\\n\\nstruct VaultConfig {\\n    address currency;\\n    uint256 minMargin;\\n    uint256 maxMargin;\\n    uint256 marginRequirement;\\n    bool overrideGlobal;\\n}\\n\\nstruct ProtocolFee {\\n    address treasuryAddress;\\n    uint256 cutRatio; // express in Ray\\n}\\n\\nstruct VaultData {\\n    uint256 totalDebt;\\n    LoanList loanList;\\n    uint256 totalMargin;\\n    uint256 withdrawableSecurityDeposit;\\n    uint256 creditLimit;\\n    uint256 spendableBalance;\\n    uint256 gav;\\n    uint256 ltv;\\n    uint256 healthFactor;\\n}\\n\\nstruct Authorisation {\\n    DSRoles rbac;\\n    DSGuard acl;\\n}\\n\\nstruct NFTInfo {\\n    bool isCollateral; // this determines whether the NFT can be transferred out of the Vault.\\n    address collection;\\n    uint256 tokenId;\\n    address currency; // record what currency was used to pay\\n    uint256 price; // price in ETH\\n}\\n\\nstruct ERC721AssetInfo {\\n    address marketplace;\\n    address erc20Addr;\\n}\\n\\nstruct UpgradeParam {\\n    mapping(address => mapping(bytes4 => address)) existingSelectorFacetMap;\\n    mapping(address => bytes4[]) existingSelectors;\\n    mapping(address => mapping(bytes4 => bool)) newSelectorSet;\\n    mapping(address => bytes4[]) newSelectors;\\n    mapping(address => IDiamondCut.FacetCut[]) facetCuts;\\n    mapping(address => uint256) facetCutSize;\\n    mapping(uint256 => bytes4[]) selectorsAdded;\\n    mapping(uint256 => bytes4[]) selectorsReplaced;\\n    mapping(uint256 => bytes4[]) selectorsRemoved;\\n}\\n\\nstruct DiamondFacet {\\n    address diamondCutFacet;\\n    address diamondLoupeFacet;\\n    address ownershipFacet;\\n}\\n\\nstruct MarketPlaceData {\\n    address adapterAddr;\\n}\\n\\nstruct AppStorage {\\n    /* -------------------------------- plumbing -------------------------------- */\\n    mapping(bytes32 => address) _addresses;\\n    /* -------------------------------- liquidity ------------------------------- */\\n    UpgradeableBeacon seniorDepositTokenBeacon;\\n    UpgradeableBeacon juniorDepositTokenBeacon;\\n    // mapping of collection address to reserve data\\n    mapping(address => ReserveData) _reserveData;\\n    // List of reserves as a map (reserveId => reserve)\\n    mapping(uint256 => address) _reserveList;\\n    uint16 _reservesCount;\\n    IWETH9 WETH9;\\n    /* ---------------------------------- debt ---------------------------------- */\\n    // collection => currency => vault => data\\n    mapping(address => mapping(address => mapping(address => BorrowData))) _borrowData;\\n    mapping(address => mapping(address => BorrowState)) _borrowState;\\n    bool _paused;\\n    /* ---------------------------------- vault --------------------------------- */\\n    UpgradeableBeacon subVaultBeacon;\\n    UpgradeableBeacon vaultBeacon;\\n    DiamondFacet diamondFacet;\\n    IVaultFactory vaultFactory;\\n    address[] vaults;\\n    // mapping of vault owner to vault instance address\\n    mapping(address => address) vaultMap;\\n    // marketplace address => marketplace type\\n    mapping(address => MarketPlaceData) marketPlaceData;\\n    // collection => tokenId => info\\n    mapping(address => mapping(uint256 => NFTInfo)) nftIndex;\\n    uint256 currentVersion;\\n    mapping(uint256 => Snapshot) snapshotMap;\\n    /* ---------------------------------- security --------------------------------- */\\n    Authorisation auth;\\n    address trustedForwarder; // GSN IERC2771 receiver\\n    address paymaster; // VoyagePaymaster address\\n    /* --------------------------------- protocol fee ------------------------------ */\\n    ProtocolFee protocolFee;\\n    /* ---------------------------------- helper --------------------------------- */\\n    // mapping of sender address to helper maps, need to clear after computing\\n    UpgradeParam upgradeParam;\\n}\\n\\nlibrary LibAppStorage {\\n    function ds() internal pure returns (AppStorage storage ds) {\\n        bytes32 storagePosition = keccak256(\\\"diamond.storage.voyage\\\");\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n\\n    function cleanUpgradeParam() internal {\\n        UpgradeParam storage s = ds().upgradeParam;\\n        for (uint256 i = 0; i < s.existingSelectors[msg.sender].length; ) {\\n            delete s.existingSelectorFacetMap[msg.sender][\\n                s.existingSelectors[msg.sender][i]\\n            ];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        delete s.existingSelectors[msg.sender];\\n\\n        for (uint256 i = 0; i < s.newSelectors[msg.sender].length; ) {\\n            delete s.newSelectorSet[msg.sender][s.newSelectors[msg.sender][i]];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        delete s.newSelectors[msg.sender];\\n\\n        delete s.facetCuts[msg.sender];\\n        delete s.facetCutSize[msg.sender];\\n    }\\n}\\n\\ncontract Storage {\\n    modifier whenPaused() {\\n        require(LibAppStorage.ds()._paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!LibAppStorage.ds()._paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier authorised() {\\n        require(auth(), \\\"call is not authorised\\\");\\n        _;\\n    }\\n\\n    function auth() internal view returns (bool) {\\n        return\\n            LibSecurity.isAuthorisedInbound(\\n                LibAppStorage.ds().auth,\\n                msg.sender,\\n                msg.sig\\n            );\\n    }\\n\\n    /**\\n     * return the sender of this call.\\n     * if the call came through our trusted forwarder, return the original sender.\\n     * otherwise, return `msg.sender`.\\n     * should be used in the contract anywhere instead of msg.sender\\n     */\\n    function _msgSender() internal view virtual returns (address ret) {\\n        if (\\n            msg.data.length >= 20 && LibSecurity.isTrustedForwarder(msg.sender)\\n        ) {\\n            // At this point we know that the sender is a trusted forwarder,\\n            // so we trust that the last bytes of msg.data are the verified sender address.\\n            // extract sender address from the end of msg.data\\n            assembly {\\n                ret := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            ret = msg.sender;\\n        }\\n    }\\n\\n    /**\\n     * return the msg.data of this call.\\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\\n     * of the msg.data - so this method will strip those 20 bytes off.\\n     * otherwise (if the call was made directly and not through the forwarder), return `msg.data`\\n     * should be used in the contract instead of msg.data, where this difference matters.\\n     */\\n    function _msgData() internal view virtual returns (bytes calldata ret) {\\n        if (\\n            msg.data.length >= 20 && LibSecurity.isTrustedForwarder(msg.sender)\\n        ) {\\n            return msg.data[0:msg.data.length - 20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n\\n    function computeSnapshotChecksum(Snapshot memory snapshot)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes memory data;\\n        for (uint256 i = 0; i < snapshot.facets.length; ) {\\n            IDiamondLoupe.Facet memory facet = snapshot.facets[i];\\n            data = bytes.concat(data, abi.encodePacked(facet.facetAddress));\\n            for (uint256 j = 0; j < facet.functionSelectors.length; j++) {\\n                data = bytes.concat(data, facet.functionSelectors[j]);\\n            }\\n            bytes32 facetCodeHash;\\n            address facetAddress = facet.facetAddress;\\n            assembly {\\n                facetCodeHash := extcodehash(facetAddress)\\n            }\\n            data = bytes.concat(data, facetCodeHash);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return keccak256(data);\\n    }\\n\\n    function diamondCut(address vault) internal {\\n        uint256 currentVersion = LibAppStorage.ds().currentVersion;\\n        Snapshot memory snapshot = LibAppStorage.ds().snapshotMap[\\n            currentVersion\\n        ];\\n        IDiamondCut.FacetCut[] memory facetCuts = new IDiamondCut.FacetCut[](\\n            snapshot.facets.length\\n        );\\n        for (uint256 i = 0; i < snapshot.facets.length; ) {\\n            address facetAddr = snapshot.facets[i].facetAddress;\\n            bytes4[] memory selectors = snapshot.facets[i].functionSelectors;\\n            facetCuts[i].facetAddress = facetAddr;\\n            facetCuts[i].functionSelectors = selectors;\\n            facetCuts[i].action = IDiamondCut.FacetCutAction.Add;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        DiamondCutFacet(vault).diamondCut(\\n            facetCuts,\\n            snapshot.init,\\n            snapshot.initArgs\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xbed49670e4564c3ee2cb83603b135871fd48d27ba8b1eda6e7e850e02b1dcae6\",\"license\":\"GPL-3.0\"},\"contracts/voyage/libraries/LibLiquidity.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {BeaconProxy} from \\\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\\\";\\nimport {LibReserveConfiguration} from \\\"./LibReserveConfiguration.sol\\\";\\nimport {IReserveInterestRateStrategy} from \\\"../interfaces/IReserveInterestRateStrategy.sol\\\";\\nimport {LibAppStorage, AppStorage, ReserveData, ReserveConfigurationMap, BorrowData, BorrowState, Tranche} from \\\"./LibAppStorage.sol\\\";\\nimport {IVToken} from \\\"../interfaces/IVToken.sol\\\";\\nimport {IWETH9} from \\\"../../shared/facets/PaymentsFacet.sol\\\";\\nimport {VToken} from \\\"../tokenization/VToken.sol\\\";\\nimport {WadRayMath} from \\\"../../shared/libraries/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../../shared/libraries/PercentageMath.sol\\\";\\n\\nlibrary LibLiquidity {\\n    using WadRayMath for uint256;\\n    using PercentageMath for uint256;\\n    using LibReserveConfiguration for ReserveConfigurationMap;\\n\\n    event ReserveDataUpdated(\\n        address indexed asset,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate\\n    );\\n\\n    struct DepositAndDebt {\\n        address currency;\\n        uint256 juniorDepositAmount;\\n        uint256 seniorDepositAmount;\\n        uint256 totalDebt;\\n        uint256 totalInterest;\\n        uint256 avgBorrowRate;\\n    }\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant UINT256_MAX = type(uint256).max;\\n\\n    /* --------------------------- reserve management --------------------------- */\\n    function init(\\n        ReserveData storage reserve,\\n        address _currency,\\n        address _interestRateStrategyAddress,\\n        address _priceOracle\\n    ) internal {\\n        require(\\n            reserve.seniorDepositTokenAddress == address(0) &&\\n                reserve.juniorDepositTokenAddress == address(0),\\n            \\\"deposit tokens already deployed\\\"\\n        );\\n        AppStorage storage s = LibAppStorage.ds();\\n        IERC20Metadata token = IERC20Metadata(_currency);\\n        ReserveConfigurationMap memory config = reserve.configuration;\\n        config.setDecimals(token.decimals());\\n        reserve.configuration = config;\\n        bytes memory data = abi.encodeWithSelector(\\n            VToken.initialize.selector,\\n            address(this),\\n            _currency\\n        );\\n        reserve.seniorDepositTokenAddress = deployBeaconProxy(\\n            address(s.seniorDepositTokenBeacon),\\n            data\\n        );\\n        token.approve(reserve.seniorDepositTokenAddress, UINT256_MAX);\\n        reserve.juniorDepositTokenAddress = deployBeaconProxy(\\n            address(s.juniorDepositTokenBeacon),\\n            data\\n        );\\n        token.approve(reserve.juniorDepositTokenAddress, UINT256_MAX);\\n        reserve.interestRateStrategyAddress = _interestRateStrategyAddress;\\n        reserve.initialized = true;\\n        reserve.priceOracle = _priceOracle;\\n        reserve.currency = _currency;\\n    }\\n\\n    function deployBeaconProxy(address _impl, bytes memory _data)\\n        internal\\n        returns (address)\\n    {\\n        return address(new BeaconProxy(_impl, _data));\\n    }\\n\\n    /* --------------------------- fee management --------------------------- */\\n    function updateProtocolFee(address _treasuryAddr, uint256 _cutRatio)\\n        internal\\n    {\\n        AppStorage storage s = LibAppStorage.ds();\\n        s.protocolFee.treasuryAddress = _treasuryAddr;\\n        s.protocolFee.cutRatio = _cutRatio;\\n    }\\n\\n    /* ------------------------ state mutation functions ------------------------ */\\n\\n    function updateWETH9(address _weth9) internal {\\n        AppStorage storage s = LibAppStorage.ds();\\n        s.WETH9 = IWETH9(_weth9);\\n    }\\n\\n    /* ----------------------------- view functions ----------------------------- */\\n    function getProtocolFee() internal view returns (address, uint256) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        return (s.protocolFee.treasuryAddress, s.protocolFee.cutRatio);\\n    }\\n\\n    function getReserveData(address _collection)\\n        internal\\n        view\\n        returns (ReserveData storage)\\n    {\\n        AppStorage storage s = LibAppStorage.ds();\\n        return s._reserveData[_collection];\\n    }\\n\\n    function getReserveList() internal view returns (address[] memory) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        address[] memory reserveList = new address[](s._reservesCount);\\n        for (uint256 i = 0; i < s._reservesCount; ) {\\n            reserveList[i] = s._reserveList[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return reserveList;\\n    }\\n\\n    function balance(\\n        address _collection,\\n        address _user,\\n        Tranche _tranche\\n    ) internal view returns (uint256) {\\n        ReserveData memory reserve = getReserveData(_collection);\\n        address vToken;\\n        if (Tranche.JUNIOR == _tranche) {\\n            vToken = reserve.juniorDepositTokenAddress;\\n        } else {\\n            vToken = reserve.seniorDepositTokenAddress;\\n        }\\n        return IVToken(vToken).maxWithdraw(_user);\\n    }\\n\\n    function unbonding(\\n        address _collection,\\n        address _user,\\n        Tranche _tranche\\n    ) internal view returns (uint256) {\\n        ReserveData memory reserve = getReserveData(_collection);\\n        address vToken;\\n        if (Tranche.JUNIOR == _tranche) {\\n            vToken = reserve.juniorDepositTokenAddress;\\n        } else {\\n            vToken = reserve.seniorDepositTokenAddress;\\n        }\\n        return IVToken(vToken).unbonding(_user);\\n    }\\n\\n    function getDepositAndDebt(address _collection)\\n        internal\\n        view\\n        returns (DepositAndDebt memory)\\n    {\\n        AppStorage storage s = LibAppStorage.ds();\\n        ReserveData storage reserve = s._reserveData[_collection];\\n        BorrowState storage borrowState = s._borrowState[_collection][\\n            reserve.currency\\n        ];\\n\\n        DepositAndDebt memory res;\\n        res.currency = reserve.currency;\\n        res.juniorDepositAmount = IVToken(reserve.juniorDepositTokenAddress)\\n            .totalAssets();\\n        res.seniorDepositAmount = IVToken(reserve.seniorDepositTokenAddress)\\n            .totalAssets();\\n        (res.totalDebt, res.totalInterest, res.avgBorrowRate) = (\\n            borrowState.totalDebt,\\n            borrowState.totalInterest,\\n            borrowState.avgBorrowRate\\n        );\\n        return res;\\n    }\\n\\n    function utilizationRate(address _collection)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        AppStorage storage s = LibAppStorage.ds();\\n        ReserveData memory reserve = getReserveData(_collection);\\n        BorrowState storage borrowState = s._borrowState[_collection][\\n            reserve.currency\\n        ];\\n        uint256 totalDebt = borrowState.totalDebt + borrowState.totalInterest;\\n\\n        uint256 totalPendingWithdrawal = IVToken(\\n            reserve.seniorDepositTokenAddress\\n        ).totalUnbonding();\\n\\n        uint256 availableLiquidity = IERC20Metadata(reserve.currency).balanceOf(\\n            reserve.seniorDepositTokenAddress\\n        ) - totalPendingWithdrawal;\\n\\n        return\\n            totalDebt == 0\\n                ? 0\\n                : totalDebt.rayDiv(availableLiquidity + totalDebt);\\n    }\\n}\\n\",\"keccak256\":\"0x7bce7927100bb10bdcbf4c9534ae87c5a12dcdf462b683e324b3ee859f0037bc\",\"license\":\"GPL-3.0\"},\"contracts/voyage/libraries/LibLoan.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {LibAppStorage, AppStorage, BorrowData, BorrowState, Loan, PMT, RepaymentData, ReserveData, RepaymentData, NFTInfo, ReserveConfigurationMap} from \\\"./LibAppStorage.sol\\\";\\nimport {LibLiquidity} from \\\"./LibLiquidity.sol\\\";\\nimport {LibReserveConfiguration} from \\\"./LibReserveConfiguration.sol\\\";\\nimport {WadRayMath} from \\\"../../shared/libraries/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../../shared/libraries/PercentageMath.sol\\\";\\n\\nlibrary LibLoan {\\n    using WadRayMath for uint256;\\n    using PercentageMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using LibReserveConfiguration for ReserveConfigurationMap;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant SECOND_PER_DAY = 1 days;\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n\\n    struct LoanDetail {\\n        uint256 principal;\\n        uint256 interest;\\n        uint256 term;\\n        uint256 epoch;\\n        uint256 nper;\\n        address reserve;\\n        PMT pmt;\\n        uint256 apr;\\n        uint256 borrowAt;\\n        uint256 nextPaymentDue;\\n        uint256 totalPrincipalPaid;\\n        uint256 totalInterestPaid;\\n        uint256 paidTimes;\\n    }\\n\\n    struct ExecuteDebtParam {\\n        address collection;\\n        address currency;\\n        uint256 tokenId;\\n        address vault;\\n        uint256 principal;\\n        uint256 interest;\\n        uint256 term;\\n        uint256 epoch;\\n        uint256 apr;\\n    }\\n\\n    /* ----------------------------- state mutations ---------------------------- */\\n\\n    function releaseLien(\\n        address _collection,\\n        address _currency,\\n        address _vault,\\n        uint256 _loanId\\n    ) internal returns (uint256[] memory ret) {\\n        BorrowData storage borrowData = getBorrowData(\\n            _collection,\\n            _currency,\\n            _vault\\n        );\\n\\n        Loan storage loan = borrowData.loans[_loanId];\\n        uint256[] storage collaterals = loan.collateral;\\n        ret = collaterals;\\n        for (uint256 i = 0; i < collaterals.length; i++) {\\n            delete LibAppStorage.ds().nftIndex[_collection][collaterals[i]];\\n        }\\n        delete borrowData.loans[_loanId];\\n        return ret;\\n    }\\n\\n    function insertDebt(\\n        address _collection,\\n        address _currency,\\n        uint256 _collateral,\\n        address _vault,\\n        uint256 _principal,\\n        uint256 _term,\\n        uint256 _epoch,\\n        uint256 _apr\\n    )\\n        internal\\n        returns (\\n            uint256 loanId,\\n            PMT memory pmt,\\n            uint256 totalInterest\\n        )\\n    {\\n        ExecuteDebtParam memory param;\\n        param.collection = _collection;\\n        param.currency = _currency;\\n        param.tokenId = _collateral;\\n        param.vault = _vault;\\n        param.principal = _principal;\\n        param.term = _term;\\n        param.epoch = _epoch;\\n        param.apr = _apr;\\n        BorrowState storage borrowState = getBorrowState(\\n            param.collection,\\n            param.currency\\n        );\\n        BorrowData storage borrowData = getBorrowData(\\n            param.collection,\\n            param.currency,\\n            param.vault\\n        );\\n        uint256 currentLoanNumber = borrowData.nextLoanNumber;\\n        Loan storage loan = borrowData.loans[currentLoanNumber];\\n        loan.principal = param.principal;\\n        loan.term = param.term;\\n        loan.epoch = param.epoch;\\n        loan.apr = param.apr;\\n        loan.nper = (_term * SECOND_PER_DAY) / (_epoch * SECOND_PER_DAY);\\n        loan.borrowAt = block.timestamp;\\n        uint256 periodsPerYear = SECONDS_PER_YEAR /\\n            (loan.epoch * SECOND_PER_DAY);\\n        uint256 effectiveInterestRate = (loan.apr * loan.nper) / periodsPerYear;\\n        loan.interest = loan.principal.rayMul(effectiveInterestRate);\\n\\n        PMT memory pmt;\\n        pmt.principal = loan.principal / loan.nper;\\n        pmt.interest = loan.interest / loan.nper;\\n        pmt.pmt = pmt.principal + pmt.interest;\\n        loan.pmt = pmt;\\n        loan.collateral.push(param.tokenId);\\n        NFTInfo memory nftInfo;\\n        nftInfo.collection = param.collection;\\n        nftInfo.tokenId = param.tokenId;\\n        nftInfo.currency = param.currency;\\n        nftInfo.price = param.principal;\\n        nftInfo.isCollateral = true;\\n        LibAppStorage.ds().nftIndex[param.collection][param.tokenId] = nftInfo;\\n        loan.nextPaymentDue =\\n            loan.borrowAt +\\n            (loan.paidTimes + 1) *\\n            loan.epoch *\\n            SECOND_PER_DAY;\\n\\n        borrowData.nextLoanNumber++;\\n        borrowData.mapSize++;\\n        borrowData.totalPrincipal = borrowData.totalPrincipal + _principal;\\n        borrowData.totalInterest = borrowData.totalInterest + loan.interest;\\n\\n        /// @dev most of the time, principal and totalDebt are denominated in wad\\n        /// we use ray operations as we are seeking avgBorrowRate, which is supposed to be epxressed in ray.\\n        /// in the vast majority of cases, as the underlying asset has 18 DPs, we end up just padding the LSBs with 0 to make avgBorrowRate a ray.\\n        ///  formula: ((debt * avgBorrowRate) + (principal*apr)) / (debt + principal)\\n        uint256 numer = (\\n            borrowState.totalDebt.rayMul(borrowState.avgBorrowRate)\\n        ) + (loan.principal.rayMul(loan.apr));\\n        uint256 denom = borrowState.totalDebt + loan.principal;\\n        borrowState.avgBorrowRate = numer.rayDiv(denom);\\n        borrowState.totalDebt = borrowState.totalDebt + loan.principal;\\n        borrowState.totalInterest = borrowState.totalInterest + loan.interest;\\n\\n        return (currentLoanNumber, pmt, loan.interest);\\n    }\\n\\n    function repay(\\n        address _collection,\\n        address _currency,\\n        address _vault,\\n        uint256 _loanNumber\\n    ) internal returns (uint256, bool) {\\n        ExecuteDebtParam memory param;\\n        param.collection = _collection;\\n        param.currency = _currency;\\n        param.vault = _vault;\\n        bool isFinal = false;\\n        BorrowData storage debtData = getBorrowData(\\n            param.collection,\\n            param.currency,\\n            param.vault\\n        );\\n        BorrowState storage borrowState = getBorrowState(\\n            param.collection,\\n            param.currency\\n        );\\n        Loan storage loan = debtData.loans[_loanNumber];\\n        loan.paidTimes += 1;\\n        if (loan.paidTimes == loan.nper) {\\n            uint256[] storage collaterals = loan.collateral;\\n            for (uint256 i = 0; i < collaterals.length; i++) {\\n                LibAppStorage\\n                .ds()\\n                .nftIndex[param.collection][collaterals[i]]\\n                    .isCollateral = false;\\n            }\\n            delete debtData.loans[_loanNumber];\\n            isFinal = true;\\n            borrowState.repaidTimes[param.vault] =\\n                borrowState.repaidTimes[param.vault] +\\n                1;\\n        } else {\\n            loan.totalPrincipalPaid =\\n                loan.totalPrincipalPaid +\\n                loan.pmt.principal;\\n            loan.totalInterestPaid = loan.totalInterestPaid + loan.pmt.interest;\\n            RepaymentData memory repayment;\\n            repayment.interest = loan.pmt.interest;\\n            repayment.principal = loan.pmt.principal;\\n            repayment.total = loan.pmt.principal + loan.pmt.interest;\\n            repayment.paidAt = uint40(block.timestamp);\\n            loan.repayments.push(repayment);\\n            // t, t+1, t+2\\n            loan.nextPaymentDue =\\n                loan.borrowAt +\\n                loan.paidTimes *\\n                loan.epoch *\\n                SECOND_PER_DAY;\\n        }\\n\\n        debtData.totalPrincipal = debtData.totalPrincipal - loan.pmt.principal;\\n        debtData.totalInterest = debtData.totalInterest - loan.pmt.interest;\\n        if (borrowState.totalDebt == loan.pmt.principal) {\\n            borrowState.avgBorrowRate = 0;\\n        } else {\\n            uint256 numer = borrowState.totalDebt.rayMul(\\n                borrowState.avgBorrowRate\\n            ) - loan.pmt.principal.rayMul(loan.apr);\\n            uint256 denom = borrowState.totalDebt - loan.pmt.principal;\\n            borrowState.avgBorrowRate = numer.rayDiv(denom);\\n        }\\n        borrowState.totalDebt = borrowState.totalDebt - loan.pmt.principal;\\n        borrowState.totalInterest = borrowState.totalInterest - param.interest;\\n\\n        return (\\n            loan.repayments.length == 0 ? 0 : loan.repayments.length - 1,\\n            isFinal\\n        );\\n    }\\n\\n    function distributeInterest(\\n        ReserveData memory reserveData,\\n        uint256 interest,\\n        address sender\\n    ) internal {\\n        uint256 incomeRatio = LibReserveConfiguration\\n            .getConfiguration(reserveData.currency)\\n            .getIncomeRatio();\\n        uint256 seniorInterest = interest.percentMul(incomeRatio);\\n        IERC20(reserveData.currency).safeTransferFrom(\\n            sender,\\n            reserveData.seniorDepositTokenAddress,\\n            seniorInterest\\n        );\\n\\n        IERC20(reserveData.currency).safeTransferFrom(\\n            sender,\\n            reserveData.juniorDepositTokenAddress,\\n            interest - seniorInterest\\n        );\\n    }\\n\\n    /* ----------------------------- view functions ----------------------------- */\\n\\n    function getBorrowState(address _collection, address _currency)\\n        internal\\n        view\\n        returns (BorrowState storage)\\n    {\\n        AppStorage storage s = LibAppStorage.ds();\\n        return s._borrowState[_collection][_currency];\\n    }\\n\\n    function getBorrowData(\\n        address _collection,\\n        address _currency,\\n        address _vault\\n    ) internal view returns (BorrowData storage) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        return s._borrowData[_collection][_currency][_vault];\\n    }\\n\\n    function getLoanDetail(\\n        address _collection,\\n        address _currency,\\n        address _vault,\\n        uint256 _loanId\\n    ) internal view returns (LoanDetail memory) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        BorrowData storage borrowData = s._borrowData[_collection][_currency][\\n            _vault\\n        ];\\n        Loan storage loan = borrowData.loans[_loanId];\\n        LoanDetail memory loanDetail;\\n        loanDetail.principal = loan.principal;\\n        loanDetail.interest = loan.interest;\\n        loanDetail.term = loan.term;\\n        loanDetail.epoch = loan.epoch;\\n        loanDetail.nper = loan.nper;\\n        loanDetail.pmt = loan.pmt;\\n        loanDetail.apr = loan.apr;\\n        loanDetail.borrowAt = loan.borrowAt;\\n        loanDetail.nextPaymentDue = loan.nextPaymentDue;\\n        loanDetail.totalInterestPaid = loan.totalInterestPaid;\\n        loanDetail.totalPrincipalPaid = loan.totalPrincipalPaid;\\n        loanDetail.paidTimes = loan.paidTimes;\\n        loanDetail.reserve = _currency;\\n        return loanDetail;\\n    }\\n\\n    function getRepayment(\\n        address _collection,\\n        address _currency,\\n        address _vault,\\n        uint256 _loanId\\n    ) internal view returns (RepaymentData[] memory) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        BorrowData storage borrowData = s._borrowData[_collection][_currency][\\n            _vault\\n        ];\\n        Loan storage loan = borrowData.loans[_loanId];\\n        return loan.repayments;\\n    }\\n\\n    function getLoanList(\\n        address _collection,\\n        address _currency,\\n        address _vault\\n    ) internal view returns (uint256, uint256) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        BorrowData storage borrowData = s._borrowData[_collection][_currency][\\n            _vault\\n        ];\\n        return (borrowData.paidLoanNumber, borrowData.nextLoanNumber);\\n    }\\n\\n    function getPMT(\\n        address _collection,\\n        address _currency,\\n        address _vault,\\n        uint256 _loan\\n    ) internal view returns (uint256, uint256) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        Loan storage loan = s._borrowData[_collection][_currency][_vault].loans[\\n            _loan\\n        ];\\n        return (loan.pmt.principal, loan.pmt.interest);\\n    }\\n}\\n\",\"keccak256\":\"0x2489d403d26af239043c45bdbc69c5ca723e5e62e4952d635bbad7cccb5559d2\",\"license\":\"GPL-3.0\"},\"contracts/voyage/libraries/LibReserveConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {ReserveData, ReserveConfigurationMap, AppStorage, LibAppStorage} from \\\"./LibAppStorage.sol\\\";\\n\\n/**\\n * @title ReserveConfiguration library\\n * @author Voyage\\n * @notice Implements the bitmap logic to handle the reserve configuration, inspired by Aave\\n **/\\nlibrary LibReserveConfiguration {\\n    uint256 constant internal LIQUIDATION_BONUS_MASK =  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n    uint256 constant internal DECIMAL_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFF; // prettier-ignore\\n    uint256 constant internal ACTIVE_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFF; // prettier-ignore\\n    uint256 constant internal FROZEN_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFF; // prettier-ignore\\n    uint256 constant internal BORROWING_ENABLE_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFF; // prettier-ignore\\n    uint256 constant internal INCOME_RATIO_MASK =       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant internal LOAN_INTERVAL_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant internal LOAN_TERM_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant internal GRACE_PERIOD_MASK =       0xFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n\\n    uint256 internal constant DECIMAL_MASK_BIT_POSITION = 16;\\n    uint256 internal constant ACTIVE_MASK_BIT_POSITION = 24;\\n    uint256 internal constant FROZEN_MASK_BIT_POSITION = 25;\\n    uint256 internal constant BORROWING_ENABLE_MASK_POSITION = 26;\\n    /// @dev bit 27 reserved\\n    uint256 internal constant INCOME_RATIO_MASK_BIT_POSITION = 116;\\n    uint256 internal constant LOAN_INTERVAL_MASK_BIT_POSITION = 132;\\n    uint256 internal constant LOAN_TERM_MASK_BIT_POSITION = 140;\\n    uint256 internal constant GRACE_PERIOD_MASK_BIT_POSITION = 156;\\n\\n    uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535; // percentage\\n    uint256 internal constant MAX_VALID_DECIMALS = 255;\\n    uint256 internal constant MAX_VALID_INCOME_RATIO = 10000; // percentage, max 100%/10000 bps\\n    uint256 internal constant MAX_VALID_LOAN_INTERVAL = 255; // days\\n    uint256 internal constant MAX_VALID_LOAN_TERM = 65535; // days\\n    uint256 internal constant MAX_VALID_GRACE_PERIOD = 255; // days\\n\\n    error InvalidLiquidationBonus();\\n    error InvalidDecimals();\\n    error InvalidIncomeRatio();\\n    error InvalidLoanInterval();\\n    error InvalidLoanTerm();\\n    error InvalidGracePeriod();\\n\\n    event LiquidationConfigurationUpdated(\\n        address indexed _asset,\\n        uint256 _liquidationBonus\\n    );\\n\\n    /* --------------------------- receiver functions --------------------------- */\\n\\n    /**\\n     * Gets the configuration flags of the reserve\\n     * @param self The reserve configuration\\n     * @return The state flags representing active, frozen, borrowing enabled\\n     **/\\n    function getFlags(ReserveConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (\\n            bool,\\n            bool,\\n            bool\\n        )\\n    {\\n        uint256 dataLocal = self.data;\\n\\n        return (\\n            (dataLocal & ~ACTIVE_MASK) != 0,\\n            (dataLocal & ~FROZEN_MASK) != 0,\\n            (dataLocal & ~BORROWING_ENABLE_MASK) != 0\\n        );\\n    }\\n\\n    function setLiquidationBonus(\\n        ReserveConfigurationMap memory self,\\n        uint256 liquidationBonus\\n    ) internal pure {\\n        if (liquidationBonus > MAX_VALID_LIQUIDATION_BONUS) {\\n            revert InvalidLiquidationBonus();\\n        }\\n        self.data = (self.data & LIQUIDATION_BONUS_MASK) | liquidationBonus;\\n    }\\n\\n    function getLiquidationBonus(ReserveConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self.data & ~LIQUIDATION_BONUS_MASK;\\n    }\\n\\n    function setDecimals(ReserveConfigurationMap memory self, uint256 _decimals)\\n        internal\\n        pure\\n    {\\n        if (_decimals > MAX_VALID_DECIMALS) {\\n            revert InvalidDecimals();\\n        }\\n        self.data =\\n            (self.data & DECIMAL_MASK) |\\n            (_decimals << DECIMAL_MASK_BIT_POSITION);\\n    }\\n\\n    function getDecimals(ReserveConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (self.data & ~DECIMAL_MASK) >> DECIMAL_MASK_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Gets the active state of the reserve\\n     * @param self The reserve configuration\\n     * @param active The active state\\n     **/\\n    function setActive(ReserveConfigurationMap memory self, bool active)\\n        internal\\n        pure\\n    {\\n        self.data =\\n            (self.data & ACTIVE_MASK) |\\n            (uint256(active ? 1 : 0) << ACTIVE_MASK_BIT_POSITION);\\n    }\\n\\n    function getActive(ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return (self.data & ~ACTIVE_MASK) != 0;\\n    }\\n\\n    function setIncomeRatio(ReserveConfigurationMap memory self, uint256 ratio)\\n        internal\\n        pure\\n    {\\n        if (ratio > MAX_VALID_INCOME_RATIO) {\\n            revert InvalidIncomeRatio();\\n        }\\n\\n        self.data =\\n            (self.data & INCOME_RATIO_MASK) |\\n            (ratio << INCOME_RATIO_MASK_BIT_POSITION);\\n    }\\n\\n    function getIncomeRatio(ReserveConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            (self.data & ~INCOME_RATIO_MASK) >> INCOME_RATIO_MASK_BIT_POSITION;\\n    }\\n\\n    function setLoanInterval(\\n        ReserveConfigurationMap memory self,\\n        uint256 interval\\n    ) internal pure {\\n        if (interval > MAX_VALID_LOAN_INTERVAL) {\\n            revert InvalidLoanInterval();\\n        }\\n        self.data =\\n            (self.data & LOAN_INTERVAL_MASK) |\\n            (interval << LOAN_INTERVAL_MASK_BIT_POSITION);\\n    }\\n\\n    function setLoanTerm(ReserveConfigurationMap memory self, uint256 term)\\n        internal\\n        pure\\n    {\\n        if (term > MAX_VALID_LOAN_TERM) {\\n            revert InvalidLoanTerm();\\n        }\\n        self.data =\\n            (self.data & LOAN_TERM_MASK) |\\n            (term << LOAN_TERM_MASK_BIT_POSITION);\\n    }\\n\\n    function setGracePeriod(\\n        ReserveConfigurationMap memory self,\\n        uint256 numDays\\n    ) internal pure {\\n        if (numDays > MAX_VALID_GRACE_PERIOD) {\\n            revert InvalidGracePeriod();\\n        }\\n        self.data =\\n            (self.data & GRACE_PERIOD_MASK) |\\n            (numDays << GRACE_PERIOD_MASK_BIT_POSITION);\\n    }\\n\\n    function getBorrowParams(ReserveConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (uint256, uint256)\\n    {\\n        uint256 localData = self.data;\\n        return (\\n            (localData & ~LOAN_INTERVAL_MASK) >>\\n                LOAN_INTERVAL_MASK_BIT_POSITION,\\n            (localData & ~LOAN_TERM_MASK) >> LOAN_TERM_MASK_BIT_POSITION\\n        );\\n    }\\n\\n    function getLiquidationParams(ReserveConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (uint256, uint256)\\n    {\\n        uint256 localData = self.data;\\n        return (\\n            (localData & ~LIQUIDATION_BONUS_MASK),\\n            (localData & ~GRACE_PERIOD_MASK) >> GRACE_PERIOD_MASK_BIT_POSITION\\n        );\\n    }\\n\\n    function getConfiguration(address _collection)\\n        internal\\n        view\\n        returns (ReserveConfigurationMap memory)\\n    {\\n        AppStorage storage s = LibAppStorage.ds();\\n        return s._reserveData[_collection].configuration;\\n    }\\n\\n    function saveConfiguration(\\n        address _collection,\\n        ReserveConfigurationMap memory _conf\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.ds();\\n        s._reserveData[_collection].configuration = _conf;\\n    }\\n}\\n\",\"keccak256\":\"0x2dea0822de7d25fd4a6f78d6004c6a039b12edcd791f2e52dc5d55f7d5ff6958\",\"license\":\"GPL-3.0\"},\"contracts/voyage/libraries/LibSecurity.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {LibAppStorage, AppStorage, Authorisation} from \\\"./LibAppStorage.sol\\\";\\n\\nlibrary LibSecurity {\\n    function isAuthorised(\\n        Authorisation storage auth,\\n        address src,\\n        address dst,\\n        bytes4 selector\\n    ) internal view returns (bool) {\\n        return\\n            auth.rbac.canCall(src, dst, selector) ||\\n            auth.acl.canCall(src, dst, selector);\\n    }\\n\\n    function isAuthorisedInbound(\\n        Authorisation storage auth,\\n        address src,\\n        bytes4 selector\\n    ) internal view returns (bool) {\\n        // s.security.acl/rbac is an instance ds-roles and implements DSAuthority interface\\n        return\\n            auth.rbac.canCall(src, address(this), selector) ||\\n            auth.acl.canCall(src, address(this), selector);\\n    }\\n\\n    function isAuthorisedOutbound(\\n        Authorisation storage auth,\\n        address dst,\\n        bytes4 selector\\n    ) internal view returns (bool) {\\n        // s.security.acl/rbac is an instance ds-guard and implements DSAuthority interface\\n        return\\n            auth.rbac.canCall(msg.sender, dst, selector) ||\\n            auth.acl.canCall(msg.sender, dst, selector);\\n    }\\n\\n    // role can be a enum, but cast to uint8 before calling grantRole\\n    function grantRole(\\n        Authorisation storage auth,\\n        address user,\\n        uint8 role,\\n        bool enabled\\n    ) internal {\\n        // grant role\\n        auth.rbac.setUserRole(user, role, enabled);\\n    }\\n\\n    function grantRolePermission(\\n        Authorisation storage auth,\\n        uint8 role,\\n        address target,\\n        bytes4 sig\\n    ) internal {\\n        // give a role a permission\\n        auth.rbac.setRoleCapability(role, target, sig, true);\\n    }\\n\\n    function revokeRolePermission(\\n        Authorisation storage auth,\\n        uint8 role,\\n        address target,\\n        bytes4 sig\\n    ) internal {\\n        // revoke a role permission\\n        auth.rbac.setRoleCapability(role, target, sig, false);\\n    }\\n\\n    function grantPermissions(\\n        Authorisation storage auth,\\n        address src,\\n        address dst,\\n        bytes4[] memory sig\\n    ) internal {\\n        for (uint256 i = 0; i < sig.length; i++) {\\n            grantPermission(auth, src, dst, sig[i]);\\n        }\\n    }\\n\\n    function grantPermission(\\n        Authorisation storage auth,\\n        address src,\\n        address dst,\\n        bytes4 sig\\n    ) internal {\\n        // allow src to call dst.sig\\n        auth.acl.permit(src, dst, sig);\\n    }\\n\\n    function revokePermission(\\n        Authorisation storage auth,\\n        address src,\\n        address dst,\\n        bytes4 sig\\n    ) internal {\\n        auth.acl.forbid(src, dst, sig);\\n    }\\n\\n    function getTrustedForwarder() internal view returns (address) {\\n        return LibAppStorage.ds().trustedForwarder;\\n    }\\n\\n    function setTrustedForwarder(address _forwarder) internal {\\n        LibAppStorage.ds().trustedForwarder = _forwarder;\\n    }\\n\\n    function isTrustedForwarder(address _forwarder)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return LibAppStorage.ds().trustedForwarder == _forwarder;\\n    }\\n}\\n\",\"keccak256\":\"0xe90107e670b8f4543de72033a19b46beadc761462f83e4d4331edbe654dffb0d\",\"license\":\"GPL-3.0\"},\"contracts/voyage/libraries/LibVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {BeaconProxy} from \\\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\\\";\\nimport {UpgradeableBeacon} from \\\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {LibAppStorage, AppStorage, BorrowData, VaultConfig, NFTInfo, DiamondFacet, ReserveConfigurationMap} from \\\"./LibAppStorage.sol\\\";\\nimport {LibReserveConfiguration} from \\\"./LibReserveConfiguration.sol\\\";\\nimport {WadRayMath} from \\\"../../shared/libraries/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../../shared/libraries/PercentageMath.sol\\\";\\nimport {LogarithmMath} from \\\"../../shared/libraries/LogarithmMath.sol\\\";\\n\\nlibrary LibVault {\\n    using WadRayMath for uint256;\\n    using PercentageMath for uint256;\\n    using LibReserveConfiguration for ReserveConfigurationMap;\\n\\n    function recordVault(address _owner, address _vault)\\n        internal\\n        returns (uint256)\\n    {\\n        AppStorage storage s = LibAppStorage.ds();\\n        require(s.vaultMap[_owner] == address(0), \\\"one vault per owner\\\");\\n        s.vaults.push(_vault);\\n        LibAppStorage.ds().vaultMap[_owner] = _vault;\\n        return (s.vaults.length);\\n    }\\n\\n    function setVaultBeacon(address _impl) internal {\\n        AppStorage storage s = LibAppStorage.ds();\\n        s.vaultBeacon = new UpgradeableBeacon(_impl);\\n    }\\n\\n    /* ----------------------------- view functions ----------------------------- */\\n    function vaultBeacon() internal view returns (address) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        return address(s.vaultBeacon);\\n    }\\n\\n    function subVaultBeacon() internal view returns (address) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        return address(s.subVaultBeacon);\\n    }\\n\\n    function getVaultAddress(address _owner) internal view returns (address) {\\n        return LibAppStorage.ds().vaultMap[_owner];\\n    }\\n\\n    function getVaultDebt(\\n        address _collection,\\n        address _currency,\\n        address _vault\\n    ) internal view returns (uint256, uint256) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        BorrowData storage borrowData = s._borrowData[_collection][_currency][\\n            _vault\\n        ];\\n        return (borrowData.totalPrincipal, borrowData.totalInterest);\\n    }\\n\\n    function getDiamondFacets() internal view returns (DiamondFacet memory) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        return s.diamondFacet;\\n    }\\n\\n    /**\\n     * @dev Get credit limit for a specific reserve\\n     * @param _vault vault address\\n     * @return _collection collection address\\n     **/\\n    function getCreditLimit(\\n        address _vault,\\n        address _collection,\\n        address _currency,\\n        uint256 _fv\\n    ) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.ds();\\n        uint256 rep = s._borrowState[_collection][_currency].repaidTimes[\\n            _vault\\n        ];\\n        uint256 scaledRep = (rep + 1) * 1e18;\\n        uint256 multiplier = LogarithmMath.log2(scaledRep) + 1;\\n        return _fv * multiplier;\\n    }\\n}\\n\",\"keccak256\":\"0x175ea10ebc7050ef463f48c19815700db15eadcb17e62c507e2601f7f28b4352\",\"license\":\"GPL-3.0\"},\"contracts/voyage/tokenization/VToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.9;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ERC4626, IERC4626} from \\\"../../shared/tokenization/ERC4626.sol\\\";\\nimport {IVToken} from \\\"../interfaces/IVToken.sol\\\";\\n\\nstruct Unbonding {\\n    uint256 shares;\\n    uint256 maxUnderlying;\\n}\\n\\nabstract contract VToken is Initializable, ERC4626, IVToken {\\n    using SafeERC20 for IERC20Metadata;\\n\\n    address internal voyage;\\n    mapping(address => Unbonding) public unbondings;\\n\\n    uint256 public totalUnbonding;\\n\\n    uint256 public cooldown = 7 days;\\n\\n    event Claim(address receiver, uint256 amount);\\n\\n    modifier onlyAdmin() {\\n        require(_msgSender() == voyage, \\\"Not admin\\\");\\n        _;\\n    }\\n\\n    function initialize(address _voyage, address _asset) public initializer {\\n        IERC20Metadata underlying = IERC20Metadata(_asset);\\n        voyage = _voyage;\\n        __ERC20_init(underlying.name(), underlying.symbol());\\n        __ERC20Permit_init(underlying.name());\\n        __ERC4626_init(underlying);\\n    }\\n\\n    function withdraw(\\n        uint256 _amount,\\n        address _receiver,\\n        address _owner\\n    ) public override(ERC4626, IERC4626) returns (uint256 shares) {\\n        shares = previewWithdraw(_amount); // No need to check for rounding error, previewWithdraw rounds up.\\n        if (msg.sender != _owner) {\\n            _spendAllowance(_owner, msg.sender, shares);\\n        }\\n\\n        beforeWithdraw(_amount, shares);\\n\\n        _burn(_owner, shares);\\n        pushWithdraw(_owner, shares);\\n\\n        emit Withdraw(msg.sender, _receiver, _owner, _amount, shares);\\n    }\\n\\n    function transferUnderlyingTo(address _target, uint256 _amount)\\n        public\\n        onlyAdmin\\n    {\\n        asset.safeTransfer(_target, _amount);\\n    }\\n\\n    function totalUnbondingAsset() public view returns (uint256) {\\n        return convertToAssets(totalUnbonding);\\n    }\\n\\n    function pushWithdraw(address _user, uint256 _shares) internal {\\n        unbondings[_user].shares += _shares;\\n        unbondings[_user].maxUnderlying += convertToAssets(_shares);\\n        totalUnbonding += _shares;\\n    }\\n\\n    function resetUnbondingPosition(address _user) internal {\\n        unbondings[_user].shares = 0;\\n        unbondings[_user].maxUnderlying = 0;\\n    }\\n\\n    function reduceUnbondingPosition(uint256 _shares, uint256 _asset) internal {\\n        if (_shares > unbondings[msg.sender].shares) {\\n            unbondings[msg.sender].shares == 0;\\n            unbondings[msg.sender].maxUnderlying = 0;\\n            return;\\n        }\\n        unbondings[msg.sender].maxUnderlying -= _asset;\\n        unbondings[msg.sender].shares -= _shares;\\n    }\\n\\n    function claim() external {\\n        uint256 maxClaimable = unbondings[msg.sender].maxUnderlying;\\n        uint256 availableLiquidity = asset.balanceOf(address(this));\\n        uint256 transferredShares;\\n        uint256 transferredAsset;\\n        if (availableLiquidity > maxClaimable) {\\n            transferredAsset = maxClaimable;\\n            transferredShares = unbondings[msg.sender].shares;\\n            resetUnbondingPosition(msg.sender);\\n        } else {\\n            transferredAsset = availableLiquidity;\\n            uint256 shares = convertToShares(availableLiquidity);\\n            reduceUnbondingPosition(shares, transferredAsset);\\n            transferredShares = shares;\\n        }\\n        totalUnbonding -= transferredShares;\\n        asset.safeTransfer(msg.sender, transferredAsset);\\n    }\\n\\n    function unbonding(address _user) external view returns (uint256) {\\n        return convertToAssets(unbondings[_user].shares);\\n    }\\n\\n    function maximumClaimable(address _user) external view returns (uint256) {\\n        uint256 underlyingUnbonding = unbondings[_user].maxUnderlying;\\n        uint256 underlyingNow = convertToAssets(unbondings[_user].shares);\\n        return\\n            underlyingUnbonding < underlyingNow\\n                ? underlyingUnbonding\\n                : underlyingNow;\\n    }\\n}\\n\\n/* --------------------------------- errors -------------------------------- */\\nerror InsufficientLiquidity();\\nerror InvalidIndex();\\nerror CollDownError();\\n\",\"keccak256\":\"0xe35c6d563ce9ad5af81d02ec373032b8aabee0a4c13adbfd9ff908e13a24534a\",\"license\":\"GPL-3.0\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405261271060805234801561001657600080fd5b5060805161429d610031600039600060d4015261429d6000f3fe60806040526004361061007b5760003560e01c8063bcd859e61161004e578063bcd859e61461013e578063cc8400481461016b578063e68fc0ee14610295578063f5fe1bb4146103c257600080fd5b806326c01303146100805780635ceae9c4146100a25780637a935d6e146100c25780638a0695fd14610109575b600080fd5b34801561008c57600080fd5b506100a061009b366004613c22565b6103d5565b005b3480156100ae57600080fd5b506100a06100bd366004613c63565b610f1b565b3480156100ce57600080fd5b506100f67f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b34801561011557600080fd5b50610129610124366004613ca5565b6112d7565b60408051928352602083019190915201610100565b34801561014a57600080fd5b5061015e610159366004613cde565b61141f565b6040516101009190613d0a565b34801561017757600080fd5b506100f6610186366004613e49565b6001600160a01b0390811660008181527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51966020908152604080832081516101808101835281546101608201908152815260018083015482860152600283015482850152600383015488166060830152600483015488166080830152600583015480891660a084015264ffffffffff600160a01b808304821660c0860152600160c81b9092041660e084015260068401548916610100840181905260079094015498891661012084015260ff9804979097161515610140909101529383527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a825280832093835292905220015490565b3480156102a157600080fd5b506100f66102b0366004613e49565b6001600160a01b0390811660008181527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519660209081526040808320815161018081018352815461016082019081528152600182015481850152600282015481840152600382015487166060820152600482015487166080820152600582015480881660a083015264ffffffffff600160a01b808304821660c0850152600160c81b9092041660e083015260068301548816610100830181905260079093015497881661012083015260ff9704969096161515610140909601959095529282527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a81528282209382529290925290205490565b6100a06103d0366004613e66565b6116ab565b7fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519b5460ff161561044c5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a207061757365640000000000000000000000000000000060448201526064015b60405180910390fd5b610523604051806102e0016040528060006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581525090565b6001600160a01b0384811680835260009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51966020818152604080842081516101808101835281546101608201908152815260018201548185015260028201548184015260038201548716606080830191909152600483015488166080830152600583015480891660a084015264ffffffffff600160a01b808304821660c0860152600160c81b9092041660e0840152600684015489166101008401819052600790940154808a1661012085015260ff9190041615156101408301528489019290925287518351808601855287905287168652938352938190208151928301825254825293871693850193909352908301849052906106416122d5565b6001600160a01b03166101c0840152805161ffff811690609c1c60ff16610220850152610240840152825160208401516040850151606086015160009361068b9390929091612346565b9050806101200151421115806106c35750620151808461022001516106b09190613f2f565b6101208201516106c09042613f4e565b11155b156106fa576040517f4283aca500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61012083015184516040517f3d47d2270000000000000000000000000000000000000000000000000000000081526001600160a01b03918216600482015290821690633d47d22790602401604080518083038186803b15801561075c57600080fd5b505afa158015610770573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107949190613f65565b6102008701526101e086018190526107d8576040517fbd84c8ab00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b845160208087015160408089015160608a01516001600160a01b0395861660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5199865283812094871681529385528284209590911683529383528082209382526005938401909252209081015460069091015460c087015260a0860181905260e086018190526101008601526101e085015161024086015161087d9190612493565b61012086018190526101e08601516108959190613f4e565b8561014001818152505060006108bd86600001518760200151886040015189606001516124b4565b9050600081518761014001516108d39190613f2f565b6101c088015160208901519192506108f6916001600160a01b03169030846126aa565b80876101a0018181516109099190613f89565b90525060005b8251811015610a625760006323b872dd60e01b90506000818a604001518b6101c0015187868151811061094457610944613fa1565b602002602001015160405160200161097d939291906001600160a01b039384168152919092166020820152604081019190915260600190565b60408051601f198184030181529082905261099b9291602001613fe3565b604051602081830303815290604052905060008a60000151826040516020016109c5929190614057565b60408051601f19818403018152908290527f55f8650100000000000000000000000000000000000000000000000000000000825291506001600160a01b038e16906355f8650190610a1a908490600401614079565b600060405180830381600087803b158015610a3457600080fd5b505af1158015610a48573d6000803e3d6000fd5b505050505050508080610a5a9061408c565b91505061090f565b507fd962e6df5bdd4ce87790a1227be78c10db04edf19dbf9499f903ad20e610896287600001518860400151896101c0015185604051610aa594939291906140a7565b60405180910390a1808760e001511115610ad457808760e00151610ac99190613f4e565b610100880152610ba6565b60008760e0015182610ae69190613f4e565b60208901516040808b015190517fa9059cbb0000000000000000000000000000000000000000000000000000000081526001600160a01b03918216600482015260248101849052929350169063a9059cbb90604401602060405180830381600087803b158015610b5557600080fd5b505af1158015610b69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8d9190614113565b5080886101a001818151610ba19190613f4e565b905250505b61010087015115610d7b5785608001516001600160a01b03166301e1d1146040518163ffffffff1660e01b815260040160206040518083038186803b158015610bee57600080fd5b505afa158015610c02573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c269190614135565b6102a0880181905261010088015111610cce576080860151610100880151604051634efecaa560e01b815230600482015260248101919091526001600160a01b0390911690634efecaa590604401600060405180830381600087803b158015610c8e57600080fd5b505af1158015610ca2573d6000803e3d6000fd5b5050505061010087015161018088018190526101a088018051610cc6908390613f89565b905250610d7b565b60808601516102a0880151604051634efecaa560e01b815230600482015260248101919091526001600160a01b0390911690634efecaa590604401600060405180830381600087803b158015610d2357600080fd5b505af1158015610d37573d6000803e3d6000fd5b505050506102a087015161018088018190526101a088018051610d5b908390613f89565b9052506102a0870151610100880151610d749190613f4e565b6102808801525b610d978760000151886020015189604001518a60600151612761565b15156102c08901526080880152865160408801516001600160a01b039182169116610dc06122d5565b6001600160a01b03167f55e5b05f9c04dc83acdd02d65dd9895ed44041625004ad61c4977959b40a4ed38a602001518b606001518c608001518d60e001518e6102c00151604051610e409594939291906001600160a01b039590951685526020850193909352604084019190915260608301521515608082015260a00190565b60405180910390a4610e738660a00151886101a0015189602001516001600160a01b0316612c4f9092919063ffffffff16565b86602001516001600160a01b0316896001600160a01b0316610e936122d5565b6001600160a01b03167fb0dbe18c6ffdf0da655dd690e77211d379205c497be44c64447c3f5f021b51678a606001518b608001518c60e001518d61018001518e6102800151604051610f07959493929190948552602085019390935260408401919091526060830152608082015260a00190565b60405180910390a450505050505050505050565b7fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519b5460ff1615610f8d5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606401610443565b610fb86040518060800160405280600081526020016000815260200160008152602001600081525090565b6001600160a01b03841660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51966020526040812060408051610180810182528254610160820190815281526001830154602082015260028301549181019190915260038201546001600160a01b039081166060830152600483015481166080830152600583015480821660a084015264ffffffffff600160a01b808304821660c0860152600160c81b9092041660e08401526006840154821661010084015260079093015480821661012084015260ff939004929092161515610140820152915083166110e66110a96122d5565b6001600160a01b0390811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51a260205260409020541690565b6001600160a01b031614611126576040517fd7a2ae6a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6101008101516001600160a01b0386811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5199602090815260408083209484168352938152838220928716825291825282812087825260059081018352929020918201546006909201549084018190528184526111a691613f89565b6111dc576040517fd49e030600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b602082015182516111ed9190613f89565b82604001818152505060008061120a878461010001518789612761565b9150915061122483856020015161121f6122d5565b612c9d565b61124d61122f6122d5565b60a085015186516101008701516001600160a01b03169291906126aa565b866001600160a01b0316856001600160a01b03166112696122d5565b61010086015160408089015181516001600160a01b039384168152602081018d9052918201889052606082015285151560808201529116907f55e5b05f9c04dc83acdd02d65dd9895ed44041625004ad61c4977959b40a4ed39060a00160405180910390a450505050505050565b6000806000611319856001600160a01b031660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51966020526040902090565b60408051610180810182528254610160820190815281526001830154602080830191909152600280850154838501526003808601546001600160a01b039081166060860152600487015481166080860152600587015480821660a087015264ffffffffff600160a01b808304821660c0890152600160c81b9092041660e087015260068801548216610100870181905260079098015480831661012088015260ff9190041615156101409095019490945299831660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5199835284812095815294825283852098909216845296909652902093840154939094015492949293505050565b611427613a02565b61142f613a02565b6001600160a01b03841660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5196602052604081206040805161018081018252825461016082019081528152600183015460208083019190915260028401548284015260038401546001600160a01b039081166060840152600485015481166080840152600585015480821660a085015264ffffffffff600160a01b808304821660c0870152600160c81b9092041660e08501526006860154821661010085015260079095015480821661012085015260ff9590049490941615156101408301528251808201845260009081905293891684527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5196815282842083519182019093529154825292508051608c81901c61ffff1661018086015260841c60ff166101a08501526101008301516001600160a01b0388811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a602090815260408083209390941682529190915290812091925090606084015161010085015160a0860151835460028501546040517f81c8c9720000000000000000000000000000000000000000000000000000000081526001600160a01b039485166004820152928416602484015260006044840152606483018c9052608483019190915260a482015292935016906381c8c9729060c401604080518083038186803b15801561165c57600080fd5b505afa158015611670573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116949190613f65565b610220860152610200850152509195945050505050565b7fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519b5460ff161561171d5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606401610443565b611725613a02565b6001600160a01b038781168083526040808401899052878316606080860191825288851660208088019190915260009485527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519681528385208451610180810186528154610160820190815281526001820154818401526002820154818701526003820154881693810193909352600481015487166080840152600581015480881660a085015264ffffffffff600160a01b808304821660c0870152600160c81b9092041660e085015260068201548816610100850181905260079092015480891661012086015260ff9190041615156101408401528751871686527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a8252848620908652905291909220915190921661185f6110a96122d5565b6001600160a01b03161461189f576040517fd7a2ae6a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040517fff40e1b4000000000000000000000000000000000000000000000000000000008152309063ff40e1b4906118df90899089908990600401614179565b60206040518083038186803b1580156118f757600080fd5b505afa15801561190b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061192f9190614135565b608084015261012082015183516040517f3d47d2270000000000000000000000000000000000000000000000000000000081526001600160a01b039182166004820152911690633d47d22790602401604080518083038186803b15801561199557600080fd5b505afa1580156119a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119cd9190613f65565b6101608501526101408401819052611a11576040517fbd84c8ab00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82608001518361014001511015611a54576040517fdfee2c0b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825160408051602080820183526000918290526001600160a01b0390931681527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51968352819020815192830190915254808252608c81901c61ffff16610180860181905260849190911c60ff166101a08601819052611ad1916141a5565b6101c0850152606083015161010084015160a085015160e0870151855460028701546040517f81c8c9720000000000000000000000000000000000000000000000000000000081526001600160a01b0395861660048201529385166024850152600060448501526064840192909252608483015260a48201529116906381c8c9729060c401604080518083038186803b158015611b6d57600080fd5b505afa158015611b81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ba59190613f65565b610220860181905261020086019190915284516101008501516040870151606088015160808901516101808a01516101a08b0151611be297612d6e565b60a08701526102c086018190526102a086019190915260408101516101e0860152516080850151611c139190613f4e565b60e08501526102c08401516020015160a0850151611c319190613f4e565b610100850181905260e0850151611c489190613f89565b846101200181815250506000611c7285606001518660000151866101000151886101400151613287565b9050846101200151811015611cb3576040517f7ecb632e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8360a001516001600160a01b031663350fd0be6040518163ffffffff1660e01b815260040160206040518083038186803b158015611cf057600080fd5b505afa158015611d04573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d289190614135565b61028086015261010084015160a08501516040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0391821660048201529116906370a082319060240160206040518083038186803b158015611d9357600080fd5b505afa158015611da7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611dcb9190614135565b61026086015260408051808201909152600a81527f63757272656e63793a20000000000000000000000000000000000000000000006020820152610100850151611e15919061334d565b611e586040518060400160405280601d81526020017f73656e696f72206465706f73697420746f6b656e416464726573733a200000008152508560a0015161334d565b611e9c6040518060400160405280600981526020017f62616c616e63653a2000000000000000000000000000000000000000000000008152508661026001516133c4565b8461028001518561026001511115611ecb57846102800151856102600151611ec49190613f4e565b6102408601525b8460e001518561024001511015611f0e576040517fbb55fd2700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b34856101e001511115611f4d57611f48333034886101e00151611f319190613f4e565b6101008801516001600160a01b03169291906126aa565b611f8b565b34856101e0015114611f8b576040517f7baac84400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000611fc07fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519360190154608088015190613437565b9050612005337fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5193601801546101008801516001600160a01b03908116929116846126aa565b60a085015160e0870151604051634efecaa560e01b815230600482015260248101919091526001600160a01b0390911690634efecaa590604401600060405180830381600087803b15801561205957600080fd5b505af115801561206d573d6000803e3d6000fd5b5050505060e08601516040517f49404b7c00000000000000000000000000000000000000000000000000000000815260048101919091523060248201819052906349404b7c90604401600060405180830381600087803b1580156120d057600080fd5b505af11580156120e4573d6000803e3d6000fd5b505050506120fa8660600151876080015161347a565b855161010086015160608801516102a08901516001600160a01b0393841660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519960209081526040808320958716835294815284822095909316815293825282842090845260059081019091529120908101546006909101546102c08801516020808201929092529190915286015160608701516040517f318c8a05000000000000000000000000000000000000000000000000000000008152309263318c8a05926121cf928d908d906004016141c7565b600060405180830381600087803b1580156121e957600080fd5b505af11580156121fd573d6000803e3d6000fd5b5050505061221f86600001518661010001518860600151896102a00151612761565b505061223785876102c001516020015161121f6122d5565b8461010001516001600160a01b031686600001516001600160a01b031687606001516001600160a01b03167f445cc7189b699aba312bd54ce4e386e25919e7992981f28a29855412132fce9c896102a001518a608001518b60a001518c61022001516040516122bf949392919093845260208401929092526040830152606082015260800190565b60405180910390a4505050505050505050505050565b60006014361080159061231157507fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51a9546001600160a01b031633145b1561234157507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c90565b503390565b61234e613aec565b6001600160a01b0385811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519960209081526040808320888516845282528083209387168352928152828220858352600581019091529190207fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519391906123d6613aec565b8154815260018201546020808301919091526002830154604080840191909152600384015460608085019190915260048501546080850152815190810182526005850154815260068501549281019290925260078401549082015260c0820152600882015460e08201526009820154610100820152600a820154610120820152600c820154610160820152600b820154610140820152600e909101546101808201526001600160a01b03871660a082015292505050949350505050565b6000806124a08484613437565b90506124ac8482613f4e565b949350505050565b606060006124c38686866134d5565b6000848152600582016020908152604091829020600f81018054845181850281018501909552808552949550909390929183919083018282801561252657602002820191906000526020600020905b815481526020019060010190808311612512575b5050505050935060005b815481101561260f576001600160a01b03891660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51a460205260408120835490919084908490811061258757612587613fa1565b60009182526020808320909101548352820192909252604001812080547fffffffffffffffffffffff000000000000000000000000000000000000000000168155600181018290556002810180547fffffffffffffffffffffffff000000000000000000000000000000000000000016905560030155806126078161408c565b915050612530565b5060008581526005808501602052604082208281556001810183905560028101839055600381018390556004810183905590810182905560068101829055600781018290556008810182905560098101829055600a8101829055600b8101829055600c810182905590612685600d830182613b7f565b600e820160009055600f8201600061269d9190613ba3565b5050505050949350505050565b6040516001600160a01b038085166024830152831660448201526064810182905261275b9085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261352b565b50505050565b6000806127ce60405180610120016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160a01b0380881680835287821660208401819052918716606084018190526000928392612801929091906134d5565b83516020808601516001600160a01b0392831660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a835260408082209490921681529282528083208a8452600585019092528220600e810180549495509193909260019291612875908490613f89565b90915550506004810154600e8201541415612a2557600f810160005b81548110156129435786516001600160a01b031660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51a460205260408120835482908590859081106128e8576128e8613fa1565b6000918252602080832091909101548352820192909252604001902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169115159190911790558061293b8161408c565b915050612891565b5060008981526005808601602052604082208281556001810183905560028101839055600381018390556004810183905590810182905560068101829055600781018290556008810182905560098101829055600a8101829055600b8101829055600c8101829055906129b9600d830182613b7f565b600e820160009055600f820160006129d19190613ba3565b505060608601516001600160a01b0316600090815260038401602052604090205460019550612a009086613f89565b60608701516001600160a01b0316600090815260038501602052604090205550612b48565b6005810154600b820154612a399190613f89565b600b8201556006810154600c820154612a529190613f89565b600c8201556040805160a08101825260009181018290526060810182905260808101919091526006820154602082018190526005830154808352612a969190613f89565b6040820190815264ffffffffff42811660608401908152600d850180546001818101835560009283526020928390208751600490930201918255918601519181019190915592516002840155516003928301805460808601511515650100000000000265ffffffffffff199091169290931691909117919091179055820154600e8301546201518091612b2891613f2f565b612b329190613f2f565b8260090154612b419190613f89565b600a830155505b60058101546002840154612b5c9190613f4e565b600284015560068101546003840154612b759190613f4e565b6003840155600581015482541415612b935760006002830155612bef565b60088101546005820154600091612baa9190613610565b60028401548454612bba91613610565b612bc49190613f4e565b60058301548454919250600091612bdb9190613f4e565b9050612be78282613654565b600285015550505b60058101548254612c009190613f4e565b825560a08501516001830154612c169190613f4e565b6001830155600d81015415612c3b57600d810154612c3690600190613f4e565b612c3e565b60005b9b939a509298505050505050505050565b6040516001600160a01b038316602482015260448101829052612c989084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064016126f7565b505050565b6000612d09612cfe85610100015160408051602080820183526000918290526001600160a01b039390931681527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51968352819020815192830190915254815290565b5160741c61ffff1690565b90506000612d178483613437565b60a0860151610100870151919250612d3b916001600160a01b0316908590846126aa565b612d678386608001518387612d509190613f4e565b6101008901516001600160a01b03169291906126aa565b5050505050565b6000612d9460405180606001604052806000815260200160008152602001600081525090565b6000612e0060405180610120016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160a01b038c81168083528c8216602080850182905260408086018f9052938d166060860152608085018c905260c085018b905260e085018a9052610100850189905260009283527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a81528383209183525290812090506000612e938360000151846020015185606001516134d5565b6001810154600081815260058301602052604090206080860151815560c0860151600282015560e08601516003820155610100860151600882015591925090612edf620151808b613f2f565b612eec620151808d613f2f565b612ef691906141a5565b60048201554260098201556003810154600090612f17906201518090613f2f565b612f25906301e133806141a5565b905060008183600401548460080154612f3e9190613f2f565b612f4891906141a5565b8354909150612f579082613610565b6001840155604080516060810182526000808252602082018190529181019190915260048401548454612f8a91906141a5565b815260048401546001850154612fa091906141a5565b602082018190528151612fb39190613f89565b6040808301829052825160058701556020808401516006880155600787019290925589810151600f8701805460018101825560009182528482200191909155815160a08101835281815292830181905290820181905260608201819052608082015288516001600160a01b039081166020838101919091526040808c0151908401528a01511660608201526080808a01519082015260018152807fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51938a516001600160a01b03908116600090815260119290920160209081526040808420818f0151855282529283902084518154928601517fffffffffffffffffffffff0000000000000000000000000000000000000000009093169015157fffffffffffffffffffffff0000000000000000000000000000000000000000ff1617610100928416929092029190911781559183015160018084019190915560608401516002840180547fffffffffffffffffffffffff0000000000000000000000000000000000000000169190931617909155608090920151600391820155860154600e87015462015180926131639190613f89565b61316d9190613f2f565b6131779190613f2f565b85600901546131869190613f89565b600a86015560018701805490600061319d8361408c565b90915550506004870180549060006131b48361408c565b91905055508f87600201546131c99190613f89565b6002880155600185015460038801546131e29190613f89565b6003880155600885015485546000916131fb9190613610565b60028a01548a5461320b91613610565b6132159190613f89565b86548a549192506000916132299190613f89565b90506132358282613654565b60028b015586548a546132489190613f89565b8a55600180880154908b015461325e9190613f89565b60019a8b0155505050929095015492985090965090945050505050985098509895505050505050565b6001600160a01b0383811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a6020908152604080832086851684528252808320938816835260039093019052908120547fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5193908261330a826001613f89565b61331c90670de0b6b3a7640000613f2f565b905060006133298261368f565b613334906001613f89565b90506133408187613f2f565b9998505050505050505050565b6133c082826040516024016133639291906141fe565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f319af33300000000000000000000000000000000000000000000000000000000179052613758565b5050565b6133c082826040516024016133da929190614229565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f9710a9d000000000000000000000000000000000000000000000000000000000179052613758565b600081157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec778390048411151761346c57600080fd5b506127109102611388010490565b600080600080600085875af1905080612c985760405162461bcd60e51b815260206004820152601360248201527f4554485f5452414e534645525f4641494c4544000000000000000000000000006044820152606401610443565b6001600160a01b0383811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519960209081526040808320868516845282528083209385168352929052205b9392505050565b6000613580826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166137799092919063ffffffff16565b805190915015612c98578080602001905181019061359e9190614113565b612c985760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401610443565b60006b033b2e3c9fd0803ce80000006136298385613f2f565b61364060026b033b2e3c9fd0803ce80000006141a5565b61364a9190613f89565b61352491906141a5565b6000806136626002846141a5565b90508261367b6b033b2e3c9fd0803ce800000086613f2f565b6136859083613f89565b6124ac91906141a5565b6000670de0b6b3a76400008210156136d6576040517fd88504dc00000000000000000000000000000000000000000000000000000000815260048101839052602401610443565b60006136eb670de0b6b3a76400008404613788565b670de0b6b3a7640000808202935090915083821c9081141561370e575050919050565b6706f05b59d3b200005b801561375057670de0b6b3a7640000828002049150671bc16d674ec800008210613748579283019260019190911c905b60011c613718565b505050919050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b60606124ac8484600085613881565b600070010000000000000000000000000000000082106137b557608091821c916137b29082613f89565b90505b6801000000000000000082106137d857604091821c916137d59082613f89565b90505b64010000000082106137f757602091821c916137f49082613f89565b90505b62010000821061381457601091821c916138119082613f89565b90505b610100821061383057600891821c9161382d9082613f89565b90505b6010821061384b57600491821c916138489082613f89565b90505b6004821061386657600291821c916138639082613f89565b90505b6002821061387c57613879600182613f89565b90505b919050565b6060824710156138f95760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401610443565b6001600160a01b0385163b6139505760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610443565b600080866001600160a01b0316858760405161396c919061424b565b60006040518083038185875af1925050503d80600081146139a9576040519150601f19603f3d011682016040523d82523d6000602084013e6139ae565b606091505b50915091506139be8282866139c9565b979650505050505050565b606083156139d8575081613524565b8251156139e85782518084602001fd5b8160405162461bcd60e51b81526004016104439190614079565b604051806102e0016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001613ae760405180606001604052806000815260200160008152602001600081525090565b905290565b604051806101a00160405280600081526020016000815260200160008152602001600081526020016000815260200160006001600160a01b03168152602001613b4f60405180606001604052806000815260200160008152602001600081525090565b81526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b5080546000825560040290600052602060002090810190613ba09190613bc1565b50565b5080546000825590600052602060002090810190613ba09190613bf8565b5b80821115613bf457600080825560018201819055600282015560038101805465ffffffffffff19169055600401613bc2565b5090565b5b80821115613bf45760008155600101613bf9565b6001600160a01b0381168114613ba057600080fd5b600080600060608486031215613c3757600080fd5b8335613c4281613c0d565b92506020840135613c5281613c0d565b929592945050506040919091013590565b600080600060608486031215613c7857600080fd5b8335613c8381613c0d565b9250602084013591506040840135613c9a81613c0d565b809150509250925092565b60008060408385031215613cb857600080fd5b8235613cc381613c0d565b91506020830135613cd381613c0d565b809150509250929050565b60008060408385031215613cf157600080fd5b8235613cfc81613c0d565b946020939093013593505050565b81516001600160a01b0316815261032081016020830151613d3660208401826001600160a01b03169052565b50604083015160408301526060830151613d5b60608401826001600160a01b03169052565b506080838101519083015260a0808401519083015260c0808401519083015260e08084015190830152610100808401519083015261012080840151908301526101408084015190830152610160808401519083015261018080840151908301526101a080840151908301526101c080840151908301526101e08084015190830152610200808401519083015261022080840151908301526102408084015190830152610260808401519083015261028080840151908301526102a080840151908301526102c08084015180518285015260208101516102e08501526040810151610300850152505092915050565b600060208284031215613e5b57600080fd5b813561352481613c0d565b60008060008060008060a08789031215613e7f57600080fd5b8635613e8a81613c0d565b9550602087013594506040870135613ea181613c0d565b93506060870135613eb181613c0d565b9250608087013567ffffffffffffffff80821115613ece57600080fd5b818901915089601f830112613ee257600080fd5b813581811115613ef157600080fd5b8a6020828501011115613f0357600080fd5b6020830194508093505050509295509295509295565b634e487b7160e01b600052601160045260246000fd5b6000816000190483118215151615613f4957613f49613f19565b500290565b600082821015613f6057613f60613f19565b500390565b60008060408385031215613f7857600080fd5b505080516020909101519092909150565b60008219821115613f9c57613f9c613f19565b500190565b634e487b7160e01b600052603260045260246000fd5b60005b83811015613fd2578181015183820152602001613fba565b8381111561275b5750506000910152565b7fffffffff00000000000000000000000000000000000000000000000000000000831681526000825161401d816004850160208701613fb7565b919091016004019392505050565b60008151808452614043816020860160208601613fb7565b601f01601f19169290920160200192915050565b6001600160a01b03831681526040602082015260006124ac604083018461402b565b602081526000613524602083018461402b565b60006000198214156140a0576140a0613f19565b5060010190565b6000608082016001600160a01b038088168452602081881681860152818716604086015260806060860152829150855180845260a086019250818701935060005b81811015614104578451845293820193928201926001016140e8565b50919998505050505050505050565b60006020828403121561412557600080fd5b8151801515811461352457600080fd5b60006020828403121561414757600080fd5b5051919050565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b6001600160a01b038416815260406020820152600061419c60408301848661414e565b95945050505050565b6000826141c257634e487b7160e01b600052601260045260246000fd5b500490565b60006001600160a01b038087168352808616602084015250606060408301526141f460608301848661414e565b9695505050505050565b604081526000614211604083018561402b565b90506001600160a01b03831660208301529392505050565b60408152600061423c604083018561402b565b90508260208301529392505050565b6000825161425d818460208701613fb7565b919091019291505056fea2646970667358221220821b02778ea072e11e77288cf8c4db3b35f8626be5c1504b00705e36d87e5c3964736f6c63430008090033",
  "deployedBytecode": "0x60806040526004361061007b5760003560e01c8063bcd859e61161004e578063bcd859e61461013e578063cc8400481461016b578063e68fc0ee14610295578063f5fe1bb4146103c257600080fd5b806326c01303146100805780635ceae9c4146100a25780637a935d6e146100c25780638a0695fd14610109575b600080fd5b34801561008c57600080fd5b506100a061009b366004613c22565b6103d5565b005b3480156100ae57600080fd5b506100a06100bd366004613c63565b610f1b565b3480156100ce57600080fd5b506100f67f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b34801561011557600080fd5b50610129610124366004613ca5565b6112d7565b60408051928352602083019190915201610100565b34801561014a57600080fd5b5061015e610159366004613cde565b61141f565b6040516101009190613d0a565b34801561017757600080fd5b506100f6610186366004613e49565b6001600160a01b0390811660008181527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51966020908152604080832081516101808101835281546101608201908152815260018083015482860152600283015482850152600383015488166060830152600483015488166080830152600583015480891660a084015264ffffffffff600160a01b808304821660c0860152600160c81b9092041660e084015260068401548916610100840181905260079094015498891661012084015260ff9804979097161515610140909101529383527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a825280832093835292905220015490565b3480156102a157600080fd5b506100f66102b0366004613e49565b6001600160a01b0390811660008181527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519660209081526040808320815161018081018352815461016082019081528152600182015481850152600282015481840152600382015487166060820152600482015487166080820152600582015480881660a083015264ffffffffff600160a01b808304821660c0850152600160c81b9092041660e083015260068301548816610100830181905260079093015497881661012083015260ff9704969096161515610140909601959095529282527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a81528282209382529290925290205490565b6100a06103d0366004613e66565b6116ab565b7fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519b5460ff161561044c5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a207061757365640000000000000000000000000000000060448201526064015b60405180910390fd5b610523604051806102e0016040528060006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581525090565b6001600160a01b0384811680835260009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51966020818152604080842081516101808101835281546101608201908152815260018201548185015260028201548184015260038201548716606080830191909152600483015488166080830152600583015480891660a084015264ffffffffff600160a01b808304821660c0860152600160c81b9092041660e0840152600684015489166101008401819052600790940154808a1661012085015260ff9190041615156101408301528489019290925287518351808601855287905287168652938352938190208151928301825254825293871693850193909352908301849052906106416122d5565b6001600160a01b03166101c0840152805161ffff811690609c1c60ff16610220850152610240840152825160208401516040850151606086015160009361068b9390929091612346565b9050806101200151421115806106c35750620151808461022001516106b09190613f2f565b6101208201516106c09042613f4e565b11155b156106fa576040517f4283aca500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61012083015184516040517f3d47d2270000000000000000000000000000000000000000000000000000000081526001600160a01b03918216600482015290821690633d47d22790602401604080518083038186803b15801561075c57600080fd5b505afa158015610770573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107949190613f65565b6102008701526101e086018190526107d8576040517fbd84c8ab00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b845160208087015160408089015160608a01516001600160a01b0395861660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5199865283812094871681529385528284209590911683529383528082209382526005938401909252209081015460069091015460c087015260a0860181905260e086018190526101008601526101e085015161024086015161087d9190612493565b61012086018190526101e08601516108959190613f4e565b8561014001818152505060006108bd86600001518760200151886040015189606001516124b4565b9050600081518761014001516108d39190613f2f565b6101c088015160208901519192506108f6916001600160a01b03169030846126aa565b80876101a0018181516109099190613f89565b90525060005b8251811015610a625760006323b872dd60e01b90506000818a604001518b6101c0015187868151811061094457610944613fa1565b602002602001015160405160200161097d939291906001600160a01b039384168152919092166020820152604081019190915260600190565b60408051601f198184030181529082905261099b9291602001613fe3565b604051602081830303815290604052905060008a60000151826040516020016109c5929190614057565b60408051601f19818403018152908290527f55f8650100000000000000000000000000000000000000000000000000000000825291506001600160a01b038e16906355f8650190610a1a908490600401614079565b600060405180830381600087803b158015610a3457600080fd5b505af1158015610a48573d6000803e3d6000fd5b505050505050508080610a5a9061408c565b91505061090f565b507fd962e6df5bdd4ce87790a1227be78c10db04edf19dbf9499f903ad20e610896287600001518860400151896101c0015185604051610aa594939291906140a7565b60405180910390a1808760e001511115610ad457808760e00151610ac99190613f4e565b610100880152610ba6565b60008760e0015182610ae69190613f4e565b60208901516040808b015190517fa9059cbb0000000000000000000000000000000000000000000000000000000081526001600160a01b03918216600482015260248101849052929350169063a9059cbb90604401602060405180830381600087803b158015610b5557600080fd5b505af1158015610b69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8d9190614113565b5080886101a001818151610ba19190613f4e565b905250505b61010087015115610d7b5785608001516001600160a01b03166301e1d1146040518163ffffffff1660e01b815260040160206040518083038186803b158015610bee57600080fd5b505afa158015610c02573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c269190614135565b6102a0880181905261010088015111610cce576080860151610100880151604051634efecaa560e01b815230600482015260248101919091526001600160a01b0390911690634efecaa590604401600060405180830381600087803b158015610c8e57600080fd5b505af1158015610ca2573d6000803e3d6000fd5b5050505061010087015161018088018190526101a088018051610cc6908390613f89565b905250610d7b565b60808601516102a0880151604051634efecaa560e01b815230600482015260248101919091526001600160a01b0390911690634efecaa590604401600060405180830381600087803b158015610d2357600080fd5b505af1158015610d37573d6000803e3d6000fd5b505050506102a087015161018088018190526101a088018051610d5b908390613f89565b9052506102a0870151610100880151610d749190613f4e565b6102808801525b610d978760000151886020015189604001518a60600151612761565b15156102c08901526080880152865160408801516001600160a01b039182169116610dc06122d5565b6001600160a01b03167f55e5b05f9c04dc83acdd02d65dd9895ed44041625004ad61c4977959b40a4ed38a602001518b606001518c608001518d60e001518e6102c00151604051610e409594939291906001600160a01b039590951685526020850193909352604084019190915260608301521515608082015260a00190565b60405180910390a4610e738660a00151886101a0015189602001516001600160a01b0316612c4f9092919063ffffffff16565b86602001516001600160a01b0316896001600160a01b0316610e936122d5565b6001600160a01b03167fb0dbe18c6ffdf0da655dd690e77211d379205c497be44c64447c3f5f021b51678a606001518b608001518c60e001518d61018001518e6102800151604051610f07959493929190948552602085019390935260408401919091526060830152608082015260a00190565b60405180910390a450505050505050505050565b7fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519b5460ff1615610f8d5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606401610443565b610fb86040518060800160405280600081526020016000815260200160008152602001600081525090565b6001600160a01b03841660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51966020526040812060408051610180810182528254610160820190815281526001830154602082015260028301549181019190915260038201546001600160a01b039081166060830152600483015481166080830152600583015480821660a084015264ffffffffff600160a01b808304821660c0860152600160c81b9092041660e08401526006840154821661010084015260079093015480821661012084015260ff939004929092161515610140820152915083166110e66110a96122d5565b6001600160a01b0390811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51a260205260409020541690565b6001600160a01b031614611126576040517fd7a2ae6a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6101008101516001600160a01b0386811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5199602090815260408083209484168352938152838220928716825291825282812087825260059081018352929020918201546006909201549084018190528184526111a691613f89565b6111dc576040517fd49e030600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b602082015182516111ed9190613f89565b82604001818152505060008061120a878461010001518789612761565b9150915061122483856020015161121f6122d5565b612c9d565b61124d61122f6122d5565b60a085015186516101008701516001600160a01b03169291906126aa565b866001600160a01b0316856001600160a01b03166112696122d5565b61010086015160408089015181516001600160a01b039384168152602081018d9052918201889052606082015285151560808201529116907f55e5b05f9c04dc83acdd02d65dd9895ed44041625004ad61c4977959b40a4ed39060a00160405180910390a450505050505050565b6000806000611319856001600160a01b031660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51966020526040902090565b60408051610180810182528254610160820190815281526001830154602080830191909152600280850154838501526003808601546001600160a01b039081166060860152600487015481166080860152600587015480821660a087015264ffffffffff600160a01b808304821660c0890152600160c81b9092041660e087015260068801548216610100870181905260079098015480831661012088015260ff9190041615156101409095019490945299831660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5199835284812095815294825283852098909216845296909652902093840154939094015492949293505050565b611427613a02565b61142f613a02565b6001600160a01b03841660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5196602052604081206040805161018081018252825461016082019081528152600183015460208083019190915260028401548284015260038401546001600160a01b039081166060840152600485015481166080840152600585015480821660a085015264ffffffffff600160a01b808304821660c0870152600160c81b9092041660e08501526006860154821661010085015260079095015480821661012085015260ff9590049490941615156101408301528251808201845260009081905293891684527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5196815282842083519182019093529154825292508051608c81901c61ffff1661018086015260841c60ff166101a08501526101008301516001600160a01b0388811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a602090815260408083209390941682529190915290812091925090606084015161010085015160a0860151835460028501546040517f81c8c9720000000000000000000000000000000000000000000000000000000081526001600160a01b039485166004820152928416602484015260006044840152606483018c9052608483019190915260a482015292935016906381c8c9729060c401604080518083038186803b15801561165c57600080fd5b505afa158015611670573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116949190613f65565b610220860152610200850152509195945050505050565b7fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519b5460ff161561171d5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606401610443565b611725613a02565b6001600160a01b038781168083526040808401899052878316606080860191825288851660208088019190915260009485527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519681528385208451610180810186528154610160820190815281526001820154818401526002820154818701526003820154881693810193909352600481015487166080840152600581015480881660a085015264ffffffffff600160a01b808304821660c0870152600160c81b9092041660e085015260068201548816610100850181905260079092015480891661012086015260ff9190041615156101408401528751871686527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a8252848620908652905291909220915190921661185f6110a96122d5565b6001600160a01b03161461189f576040517fd7a2ae6a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040517fff40e1b4000000000000000000000000000000000000000000000000000000008152309063ff40e1b4906118df90899089908990600401614179565b60206040518083038186803b1580156118f757600080fd5b505afa15801561190b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061192f9190614135565b608084015261012082015183516040517f3d47d2270000000000000000000000000000000000000000000000000000000081526001600160a01b039182166004820152911690633d47d22790602401604080518083038186803b15801561199557600080fd5b505afa1580156119a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119cd9190613f65565b6101608501526101408401819052611a11576040517fbd84c8ab00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82608001518361014001511015611a54576040517fdfee2c0b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825160408051602080820183526000918290526001600160a01b0390931681527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51968352819020815192830190915254808252608c81901c61ffff16610180860181905260849190911c60ff166101a08601819052611ad1916141a5565b6101c0850152606083015161010084015160a085015160e0870151855460028701546040517f81c8c9720000000000000000000000000000000000000000000000000000000081526001600160a01b0395861660048201529385166024850152600060448501526064840192909252608483015260a48201529116906381c8c9729060c401604080518083038186803b158015611b6d57600080fd5b505afa158015611b81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ba59190613f65565b610220860181905261020086019190915284516101008501516040870151606088015160808901516101808a01516101a08b0151611be297612d6e565b60a08701526102c086018190526102a086019190915260408101516101e0860152516080850151611c139190613f4e565b60e08501526102c08401516020015160a0850151611c319190613f4e565b610100850181905260e0850151611c489190613f89565b846101200181815250506000611c7285606001518660000151866101000151886101400151613287565b9050846101200151811015611cb3576040517f7ecb632e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8360a001516001600160a01b031663350fd0be6040518163ffffffff1660e01b815260040160206040518083038186803b158015611cf057600080fd5b505afa158015611d04573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d289190614135565b61028086015261010084015160a08501516040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0391821660048201529116906370a082319060240160206040518083038186803b158015611d9357600080fd5b505afa158015611da7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611dcb9190614135565b61026086015260408051808201909152600a81527f63757272656e63793a20000000000000000000000000000000000000000000006020820152610100850151611e15919061334d565b611e586040518060400160405280601d81526020017f73656e696f72206465706f73697420746f6b656e416464726573733a200000008152508560a0015161334d565b611e9c6040518060400160405280600981526020017f62616c616e63653a2000000000000000000000000000000000000000000000008152508661026001516133c4565b8461028001518561026001511115611ecb57846102800151856102600151611ec49190613f4e565b6102408601525b8460e001518561024001511015611f0e576040517fbb55fd2700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b34856101e001511115611f4d57611f48333034886101e00151611f319190613f4e565b6101008801516001600160a01b03169291906126aa565b611f8b565b34856101e0015114611f8b576040517f7baac84400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000611fc07fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519360190154608088015190613437565b9050612005337fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5193601801546101008801516001600160a01b03908116929116846126aa565b60a085015160e0870151604051634efecaa560e01b815230600482015260248101919091526001600160a01b0390911690634efecaa590604401600060405180830381600087803b15801561205957600080fd5b505af115801561206d573d6000803e3d6000fd5b5050505060e08601516040517f49404b7c00000000000000000000000000000000000000000000000000000000815260048101919091523060248201819052906349404b7c90604401600060405180830381600087803b1580156120d057600080fd5b505af11580156120e4573d6000803e3d6000fd5b505050506120fa8660600151876080015161347a565b855161010086015160608801516102a08901516001600160a01b0393841660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519960209081526040808320958716835294815284822095909316815293825282842090845260059081019091529120908101546006909101546102c08801516020808201929092529190915286015160608701516040517f318c8a05000000000000000000000000000000000000000000000000000000008152309263318c8a05926121cf928d908d906004016141c7565b600060405180830381600087803b1580156121e957600080fd5b505af11580156121fd573d6000803e3d6000fd5b5050505061221f86600001518661010001518860600151896102a00151612761565b505061223785876102c001516020015161121f6122d5565b8461010001516001600160a01b031686600001516001600160a01b031687606001516001600160a01b03167f445cc7189b699aba312bd54ce4e386e25919e7992981f28a29855412132fce9c896102a001518a608001518b60a001518c61022001516040516122bf949392919093845260208401929092526040830152606082015260800190565b60405180910390a4505050505050505050505050565b60006014361080159061231157507fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51a9546001600160a01b031633145b1561234157507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c90565b503390565b61234e613aec565b6001600160a01b0385811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519960209081526040808320888516845282528083209387168352928152828220858352600581019091529190207fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519391906123d6613aec565b8154815260018201546020808301919091526002830154604080840191909152600384015460608085019190915260048501546080850152815190810182526005850154815260068501549281019290925260078401549082015260c0820152600882015460e08201526009820154610100820152600a820154610120820152600c820154610160820152600b820154610140820152600e909101546101808201526001600160a01b03871660a082015292505050949350505050565b6000806124a08484613437565b90506124ac8482613f4e565b949350505050565b606060006124c38686866134d5565b6000848152600582016020908152604091829020600f81018054845181850281018501909552808552949550909390929183919083018282801561252657602002820191906000526020600020905b815481526020019060010190808311612512575b5050505050935060005b815481101561260f576001600160a01b03891660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51a460205260408120835490919084908490811061258757612587613fa1565b60009182526020808320909101548352820192909252604001812080547fffffffffffffffffffffff000000000000000000000000000000000000000000168155600181018290556002810180547fffffffffffffffffffffffff000000000000000000000000000000000000000016905560030155806126078161408c565b915050612530565b5060008581526005808501602052604082208281556001810183905560028101839055600381018390556004810183905590810182905560068101829055600781018290556008810182905560098101829055600a8101829055600b8101829055600c810182905590612685600d830182613b7f565b600e820160009055600f8201600061269d9190613ba3565b5050505050949350505050565b6040516001600160a01b038085166024830152831660448201526064810182905261275b9085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261352b565b50505050565b6000806127ce60405180610120016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160a01b0380881680835287821660208401819052918716606084018190526000928392612801929091906134d5565b83516020808601516001600160a01b0392831660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a835260408082209490921681529282528083208a8452600585019092528220600e810180549495509193909260019291612875908490613f89565b90915550506004810154600e8201541415612a2557600f810160005b81548110156129435786516001600160a01b031660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51a460205260408120835482908590859081106128e8576128e8613fa1565b6000918252602080832091909101548352820192909252604001902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169115159190911790558061293b8161408c565b915050612891565b5060008981526005808601602052604082208281556001810183905560028101839055600381018390556004810183905590810182905560068101829055600781018290556008810182905560098101829055600a8101829055600b8101829055600c8101829055906129b9600d830182613b7f565b600e820160009055600f820160006129d19190613ba3565b505060608601516001600160a01b0316600090815260038401602052604090205460019550612a009086613f89565b60608701516001600160a01b0316600090815260038501602052604090205550612b48565b6005810154600b820154612a399190613f89565b600b8201556006810154600c820154612a529190613f89565b600c8201556040805160a08101825260009181018290526060810182905260808101919091526006820154602082018190526005830154808352612a969190613f89565b6040820190815264ffffffffff42811660608401908152600d850180546001818101835560009283526020928390208751600490930201918255918601519181019190915592516002840155516003928301805460808601511515650100000000000265ffffffffffff199091169290931691909117919091179055820154600e8301546201518091612b2891613f2f565b612b329190613f2f565b8260090154612b419190613f89565b600a830155505b60058101546002840154612b5c9190613f4e565b600284015560068101546003840154612b759190613f4e565b6003840155600581015482541415612b935760006002830155612bef565b60088101546005820154600091612baa9190613610565b60028401548454612bba91613610565b612bc49190613f4e565b60058301548454919250600091612bdb9190613f4e565b9050612be78282613654565b600285015550505b60058101548254612c009190613f4e565b825560a08501516001830154612c169190613f4e565b6001830155600d81015415612c3b57600d810154612c3690600190613f4e565b612c3e565b60005b9b939a509298505050505050505050565b6040516001600160a01b038316602482015260448101829052612c989084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064016126f7565b505050565b6000612d09612cfe85610100015160408051602080820183526000918290526001600160a01b039390931681527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51968352819020815192830190915254815290565b5160741c61ffff1690565b90506000612d178483613437565b60a0860151610100870151919250612d3b916001600160a01b0316908590846126aa565b612d678386608001518387612d509190613f4e565b6101008901516001600160a01b03169291906126aa565b5050505050565b6000612d9460405180606001604052806000815260200160008152602001600081525090565b6000612e0060405180610120016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160a01b038c81168083528c8216602080850182905260408086018f9052938d166060860152608085018c905260c085018b905260e085018a9052610100850189905260009283527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a81528383209183525290812090506000612e938360000151846020015185606001516134d5565b6001810154600081815260058301602052604090206080860151815560c0860151600282015560e08601516003820155610100860151600882015591925090612edf620151808b613f2f565b612eec620151808d613f2f565b612ef691906141a5565b60048201554260098201556003810154600090612f17906201518090613f2f565b612f25906301e133806141a5565b905060008183600401548460080154612f3e9190613f2f565b612f4891906141a5565b8354909150612f579082613610565b6001840155604080516060810182526000808252602082018190529181019190915260048401548454612f8a91906141a5565b815260048401546001850154612fa091906141a5565b602082018190528151612fb39190613f89565b6040808301829052825160058701556020808401516006880155600787019290925589810151600f8701805460018101825560009182528482200191909155815160a08101835281815292830181905290820181905260608201819052608082015288516001600160a01b039081166020838101919091526040808c0151908401528a01511660608201526080808a01519082015260018152807fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c51938a516001600160a01b03908116600090815260119290920160209081526040808420818f0151855282529283902084518154928601517fffffffffffffffffffffff0000000000000000000000000000000000000000009093169015157fffffffffffffffffffffff0000000000000000000000000000000000000000ff1617610100928416929092029190911781559183015160018084019190915560608401516002840180547fffffffffffffffffffffffff0000000000000000000000000000000000000000169190931617909155608090920151600391820155860154600e87015462015180926131639190613f89565b61316d9190613f2f565b6131779190613f2f565b85600901546131869190613f89565b600a86015560018701805490600061319d8361408c565b90915550506004870180549060006131b48361408c565b91905055508f87600201546131c99190613f89565b6002880155600185015460038801546131e29190613f89565b6003880155600885015485546000916131fb9190613610565b60028a01548a5461320b91613610565b6132159190613f89565b86548a549192506000916132299190613f89565b90506132358282613654565b60028b015586548a546132489190613f89565b8a55600180880154908b015461325e9190613f89565b60019a8b0155505050929095015492985090965090945050505050985098509895505050505050565b6001600160a01b0383811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519a6020908152604080832086851684528252808320938816835260039093019052908120547fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c5193908261330a826001613f89565b61331c90670de0b6b3a7640000613f2f565b905060006133298261368f565b613334906001613f89565b90506133408187613f2f565b9998505050505050505050565b6133c082826040516024016133639291906141fe565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f319af33300000000000000000000000000000000000000000000000000000000179052613758565b5050565b6133c082826040516024016133da929190614229565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f9710a9d000000000000000000000000000000000000000000000000000000000179052613758565b600081157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec778390048411151761346c57600080fd5b506127109102611388010490565b600080600080600085875af1905080612c985760405162461bcd60e51b815260206004820152601360248201527f4554485f5452414e534645525f4641494c4544000000000000000000000000006044820152606401610443565b6001600160a01b0383811660009081527fcefae263aa054db53617928bc915f31f052caa2df6a635924d36f37f8c9c519960209081526040808320868516845282528083209385168352929052205b9392505050565b6000613580826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166137799092919063ffffffff16565b805190915015612c98578080602001905181019061359e9190614113565b612c985760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401610443565b60006b033b2e3c9fd0803ce80000006136298385613f2f565b61364060026b033b2e3c9fd0803ce80000006141a5565b61364a9190613f89565b61352491906141a5565b6000806136626002846141a5565b90508261367b6b033b2e3c9fd0803ce800000086613f2f565b6136859083613f89565b6124ac91906141a5565b6000670de0b6b3a76400008210156136d6576040517fd88504dc00000000000000000000000000000000000000000000000000000000815260048101839052602401610443565b60006136eb670de0b6b3a76400008404613788565b670de0b6b3a7640000808202935090915083821c9081141561370e575050919050565b6706f05b59d3b200005b801561375057670de0b6b3a7640000828002049150671bc16d674ec800008210613748579283019260019190911c905b60011c613718565b505050919050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b60606124ac8484600085613881565b600070010000000000000000000000000000000082106137b557608091821c916137b29082613f89565b90505b6801000000000000000082106137d857604091821c916137d59082613f89565b90505b64010000000082106137f757602091821c916137f49082613f89565b90505b62010000821061381457601091821c916138119082613f89565b90505b610100821061383057600891821c9161382d9082613f89565b90505b6010821061384b57600491821c916138489082613f89565b90505b6004821061386657600291821c916138639082613f89565b90505b6002821061387c57613879600182613f89565b90505b919050565b6060824710156138f95760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401610443565b6001600160a01b0385163b6139505760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610443565b600080866001600160a01b0316858760405161396c919061424b565b60006040518083038185875af1925050503d80600081146139a9576040519150601f19603f3d011682016040523d82523d6000602084013e6139ae565b606091505b50915091506139be8282866139c9565b979650505050505050565b606083156139d8575081613524565b8251156139e85782518084602001fd5b8160405162461bcd60e51b81526004016104439190614079565b604051806102e0016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001613ae760405180606001604052806000815260200160008152602001600081525090565b905290565b604051806101a00160405280600081526020016000815260200160008152602001600081526020016000815260200160006001600160a01b03168152602001613b4f60405180606001604052806000815260200160008152602001600081525090565b81526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b5080546000825560040290600052602060002090810190613ba09190613bc1565b50565b5080546000825590600052602060002090810190613ba09190613bf8565b5b80821115613bf457600080825560018201819055600282015560038101805465ffffffffffff19169055600401613bc2565b5090565b5b80821115613bf45760008155600101613bf9565b6001600160a01b0381168114613ba057600080fd5b600080600060608486031215613c3757600080fd5b8335613c4281613c0d565b92506020840135613c5281613c0d565b929592945050506040919091013590565b600080600060608486031215613c7857600080fd5b8335613c8381613c0d565b9250602084013591506040840135613c9a81613c0d565b809150509250925092565b60008060408385031215613cb857600080fd5b8235613cc381613c0d565b91506020830135613cd381613c0d565b809150509250929050565b60008060408385031215613cf157600080fd5b8235613cfc81613c0d565b946020939093013593505050565b81516001600160a01b0316815261032081016020830151613d3660208401826001600160a01b03169052565b50604083015160408301526060830151613d5b60608401826001600160a01b03169052565b506080838101519083015260a0808401519083015260c0808401519083015260e08084015190830152610100808401519083015261012080840151908301526101408084015190830152610160808401519083015261018080840151908301526101a080840151908301526101c080840151908301526101e08084015190830152610200808401519083015261022080840151908301526102408084015190830152610260808401519083015261028080840151908301526102a080840151908301526102c08084015180518285015260208101516102e08501526040810151610300850152505092915050565b600060208284031215613e5b57600080fd5b813561352481613c0d565b60008060008060008060a08789031215613e7f57600080fd5b8635613e8a81613c0d565b9550602087013594506040870135613ea181613c0d565b93506060870135613eb181613c0d565b9250608087013567ffffffffffffffff80821115613ece57600080fd5b818901915089601f830112613ee257600080fd5b813581811115613ef157600080fd5b8a6020828501011115613f0357600080fd5b6020830194508093505050509295509295509295565b634e487b7160e01b600052601160045260246000fd5b6000816000190483118215151615613f4957613f49613f19565b500290565b600082821015613f6057613f60613f19565b500390565b60008060408385031215613f7857600080fd5b505080516020909101519092909150565b60008219821115613f9c57613f9c613f19565b500190565b634e487b7160e01b600052603260045260246000fd5b60005b83811015613fd2578181015183820152602001613fba565b8381111561275b5750506000910152565b7fffffffff00000000000000000000000000000000000000000000000000000000831681526000825161401d816004850160208701613fb7565b919091016004019392505050565b60008151808452614043816020860160208601613fb7565b601f01601f19169290920160200192915050565b6001600160a01b03831681526040602082015260006124ac604083018461402b565b602081526000613524602083018461402b565b60006000198214156140a0576140a0613f19565b5060010190565b6000608082016001600160a01b038088168452602081881681860152818716604086015260806060860152829150855180845260a086019250818701935060005b81811015614104578451845293820193928201926001016140e8565b50919998505050505050505050565b60006020828403121561412557600080fd5b8151801515811461352457600080fd5b60006020828403121561414757600080fd5b5051919050565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b6001600160a01b038416815260406020820152600061419c60408301848661414e565b95945050505050565b6000826141c257634e487b7160e01b600052601260045260246000fd5b500490565b60006001600160a01b038087168352808616602084015250606060408301526141f460608301848661414e565b9695505050505050565b604081526000614211604083018561402b565b90506001600160a01b03831660208301529392505050565b60408152600061423c604083018561402b565b90508260208301529392505050565b6000825161425d818460208701613fb7565b919091019291505056fea2646970667358221220821b02778ea072e11e77288cf8c4db3b35f8626be5c1504b00705e36d87e5c3964736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "interestBalance(address)": {
        "params": {
          "_collection": "the address of the underlying nft collection."
        },
        "returns": {
          "_0": "The total outstanding interest owed to depositors."
        }
      },
      "principalBalance(address)": {
        "params": {
          "_collection": "the address of the underlying nft collection."
        },
        "returns": {
          "_0": "The total outstanding principal owed to depositors."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "interestBalance(address)": {
        "notice": "Returns the total outstanding interest debt for a particular underlying asset pool"
      },
      "principalBalance(address)": {
        "notice": "Returns the total outstanding principal debt for a particular underlying asset pool"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}