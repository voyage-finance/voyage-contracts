// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.9;

import 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';
import 'openzeppelin-solidity/contracts/utils/math/SafeMath.sol';
import '../libraries/math/WadRayMath.sol';
import '../libraries/CoreLibrary.sol';
import '../component/liquidity/LiquidityManager.sol';

contract JuniorDepositToken is ERC20 {
    using WadRayMath for uint256;
    using SafeMath for uint256;

    mapping(address => uint256) private userJuniorIndexes;
    address public underlyingAssetAddress;
    LiquidityManager private liquidityManager;

    /**
     * @dev emitted after the mint action
     * @param _from the address performing the mint
     * @param _value the amount to be minted
     * @param _fromBalanceIncrease the cumulated balance since the last update of the user
     * @param _fromIndex the last index of the user
     **/
    event MintOnDeposit(
        address indexed _from,
        uint256 _value,
        uint256 _fromBalanceIncrease,
        uint256 _fromIndex,
        CoreLibrary.Tranche tranche
    );

    /**
     * @dev emitted after the redeem action
     * @param _from the address performing the redeem
     * @param _value the amount to be redeemed
     * @param _fromBalanceIncrease the cumulated balance since the last update of the user
     * @param _fromIndex the last index of the user
     **/
    event Redeem(
        address indexed _from,
        uint256 _value,
        uint256 _fromBalanceIncrease,
        uint256 _fromIndex
    );

    modifier onlyLiquidityManager() {
        require(
            msg.sender == address(liquidityManager),
            'The caller of this function must be liquidityManager'
        );
        _;
    }

    constructor(
        address _underlyingAsset,
        uint8 _underlyingAssetDecimals,
        string memory _name,
        string memory _symbol
    ) ERC20(_name, _symbol) {}

    /**
     * @dev calculates the balance of the user, which is the
     * principal balance + interest generated by the principal balance
     * @param _user the user for which the balance is being calculated
     * @return the total balance of the user
     */
    function balanceOf(address _user) public view override returns (uint256) {
        // current principal balance of the user
        uint256 currentPrincipalBalance = super.balanceOf(_user);
        uint256 currentJuniorCumulatedBalance = calculateCumulatedBalanceInternal(
                _user,
                currentPrincipalBalance
            );
        return currentPrincipalBalance.add(currentJuniorCumulatedBalance);
    }

    /**
     * @dev accumulates the accrued interest of the user to the principal balance
     * @param _user the address of the user for which the interest is being accumulated
     * @return the previous principal balance, the new principal balance, the balance increase
     * and the new user index
     **/
    function calculateCumulatedBalanceInternal(address _user, uint256 _balance)
        internal
        view
        returns (uint256)
    {
        return
            _balance
                .wadToRay()
                .rayMul(
                    liquidityManager.getReserveNormalizedIncome(
                        underlyingAssetAddress,
                        CoreLibrary.Tranche.JUNIOR
                    )
                )
                .rayDiv(userJuniorIndexes[_user])
                .rayToWad();
    }

    /**
     * @dev accumulates the accrued interest of the user to the principal balance
     * @param _user the address of the user for which the interest is being accumulated
     * @return the previous principal balance, the new principal balance, the balance increase
     * and the new user index
     **/
    function cumulateBalanceInternal(address _user)
        internal
        returns (
            uint256,
            uint256,
            uint256,
            uint256
        )
    {
        uint256 previousPrincipalBalance = super.balanceOf(_user);

        //calculate the accrued interest for both tranches since the last accumulation
        uint256 balanceIncrease = balanceOf(_user).sub(
            previousPrincipalBalance
        );
        //mints an amount of tokens equivalent to the amount accumulated
        _mint(_user, balanceIncrease);
        //updates the user index for current _tranche
        uint256 index = userJuniorIndexes[_user] = liquidityManager
            .getReserveNormalizedIncome(
                underlyingAssetAddress,
                CoreLibrary.Tranche.JUNIOR
            );

        return (
            previousPrincipalBalance,
            previousPrincipalBalance.add(balanceIncrease),
            balanceIncrease,
            index
        );
    }

    function mintOnDeposit(address _account, uint256 _amount)
        external
        onlyLiquidityManager
    {
        //cumulates the balance of the user
        (, , uint256 balanceIncrease, uint256 index) = cumulateBalanceInternal(
            _account
        );

        //mint an equivalent amount of tokens to cover the new deposit
        _mint(_account, _amount);

        emit MintOnDeposit(
            _account,
            _amount,
            balanceIncrease,
            index,
            CoreLibrary.Tranche.JUNIOR
        );
    }
}
