// SPDX-License-Identifier: GPL-3.0
pragma solidity  ^0.8.9;

import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/math/SafeMath.sol";
import '../libraries/math/WadRayMath.sol';
import "../libraries/CoreLibrary.sol";
import '../LiquidityManager.sol';

contract OToken is ERC20 {
    using WadRayMath for uint256;
    using SafeMath for uint256;

    mapping (address => uint256) private userIndexes;
    address public underlyingAssetAddress;
    LiquidityManager private liquidityManager;

    /**
    * @dev emitted after the mint action
    * @param _from the address performing the mint
    * @param _value the amount to be minted
    * @param _fromBalanceIncrease the cumulated balance since the last update of the user
    * @param _fromIndex the last index of the user
    **/
    event MintOnDeposit(
        address indexed _from,
        uint256 _value,
        uint256 _fromBalanceIncrease,
        uint256 _fromIndex
    );

     /**
    * @dev emitted after the redeem action
    * @param _from the address performing the redeem
    * @param _value the amount to be redeemed
    * @param _fromBalanceIncrease the cumulated balance since the last update of the user
    * @param _fromIndex the last index of the user
    **/
    event Redeem(
        address indexed _from,
        uint256 _value,
        uint256 _fromBalanceIncrease,
        uint256 _fromIndex
    );

    modifier onlyLiquidityManager {
        require(
            msg.sender ==  address(liquidityManager),
            'The caller of this function must be liquidityManager'
        );
        _;
    }

    constructor(
        address _underlyingAsset,
        uint8 _underlyingAssetDecimals,
        string memory _name,
        string memory _symbol
    ) ERC20(_name, _symbol) {

    }


    /**
    * @dev calculates the balance of the user, which is the
    * principal balance + interest generated by the principal balance
    * @param _user the user for which the balance is being calculated
    * @return the total balance of the user
     */
    function balanceOf(address _user) public override view returns (uint256) {
        // current principal balance of the user
        uint256 currentPrincipalBalance = super.balanceOf(_user);
        return currentPrincipalBalance.add(
            calculateCumulatedBalanceInternal(
                _user,
                currentPrincipalBalance
            )
        );
    }


    function calculateCumulatedBalanceInternal(
        address _user,
        uint256 _balance
    ) internal view returns (uint256) {
          return _balance
            .wadToRay()
            .rayMul(liquidityManager.getReserveNormalizedIncome(underlyingAssetAddress))
            .rayDiv(userIndexes[_user])
            .rayToWad();
    }

    /**
    * @dev accumulates the accrued interest of the user to the principal balance
    * @param _user the address of the user for which the interest is being accumulated
    * @return the previous principal balance, the new principal balance, the balance increase
    * and the new user index
    **/
    function cumulateBalanceInternal(address _user)
        internal
        returns(uint256, uint256, uint256, uint256) {

        uint256 previousPrincipalBalance = super.balanceOf(_user);

        //calculate the accrued interest since the last accumulation
        uint256 balanceIncrease = balanceOf(_user).sub(previousPrincipalBalance);
        //mints an amount of tokens equivalent to the amount accumulated
        _mint(_user, balanceIncrease);
        //updates the user index
        uint256 index = userIndexes[_user] = liquidityManager.getReserveNormalizedIncome(underlyingAssetAddress);
        return (
            previousPrincipalBalance,
            previousPrincipalBalance.add(balanceIncrease),
            balanceIncrease,
            index
        );
    }

    function mintOnDeposit(address _account, uint256 _amount) external onlyLiquidityManager {
        //cumulates the balance of the user
        (,
        ,
        uint256 balanceIncrease,
        uint256 index) = cumulateBalanceInternal(_account);

        //mint an equivalent amount of tokens to cover the new deposit
        _mint(_account, _amount);

        emit MintOnDeposit(_account, _amount, balanceIncrease, index);
    }

    /**
    * @dev redeems oToken for the underlying asset
    * @param _amount the amount being redeemed
    **/
    function redeem(uint256 _amount) external {
        require(_amount > 0, "Amount to redeem needs to be > 0");

        //cumulates the balance of the user
        (,
        uint256 currentBalance,
        uint256 balanceIncrease,
        uint256 index) = cumulateBalanceInternal(msg.sender);



        uint256 amountToRedeem = _amount;

        require(amountToRedeem <= currentBalance, "User cannot redeem more than the available balance");

        // todo check that the user is allowed to redeem the amount

        // burns tokens equivalent to the amount requested
        _burn(msg.sender, amountToRedeem);

        bool userIndexReset = false;
        //reset the user data if the remaining balance is 0
        if(currentBalance.sub(amountToRedeem) == 0){
          userIndexes[msg.sender] = 0;
          userIndexReset = true;
        }

        // todo call main contract

        emit Redeem(msg.sender, amountToRedeem, balanceIncrease, userIndexReset ? 0 : index);

    }


}